<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistiche - GFV Platform</title>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #B0E0E6 0%, #228B22 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(180deg, #2E8B57 0%, #256E4A 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info span {
            font-size: 0.9em;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-primary:hover {
            background: rgba(255,255,255,0.3);
        }

        .content {
            padding: 30px;
        }

        .filters {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            margin: 0;
        }

        .filters input,
        .filters select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .filters input[type="date"] {
            min-width: 150px;
        }

        .filters select {
            min-width: 150px;
        }

        .filter-range {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }

        .filter-range-text {
            padding-bottom: 8px;
            font-size: 14px;
            color: #666;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        /* Metriche Cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, #2E8B57 0%, #228B22 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }

        .metric-card.blue {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        }

        .metric-card.orange {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }

        .metric-card.purple {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .metric-label {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .metric-subtitle {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* Grafici */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chart-card h3 {
            color: #2E8B57;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        .chart-container.tall {
            height: 400px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .user-info {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“Š Statistiche e Dashboard</h1>
            <p>Analisi delle attivitÃ  e metriche aziendali</p>
            <div class="user-info">
                <span id="user-name">Caricamento...</span>
                <button class="btn btn-primary" onclick="window.location.href='dashboard-standalone.html'">Dashboard</button>
            </div>
        </div>

        <div class="content">
            <!-- Filtri -->
            <div class="filters">
                <div class="filter-group">
                    <label>Periodo</label>
                    <div class="filter-range">
                        <input type="date" id="filter-data-da" class="form-control">
                        <span class="filter-range-text">a</span>
                        <input type="date" id="filter-data-a" class="form-control">
                    </div>
                </div>
                <div class="filter-group">
                    <label>Terreno</label>
                    <select id="filter-terreno" class="form-control">
                        <option value="">Tutti i terreni</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Tipo Lavoro</label>
                    <select id="filter-tipo-lavoro" class="form-control">
                        <option value="">Tutti i tipi</option>
                    </select>
                </div>
                <div class="filter-group">
                    <button class="btn btn-secondary" onclick="applyFilters()">Applica Filtri</button>
                </div>
                <div class="filter-group">
                    <button class="btn btn-secondary" onclick="resetFilters()">Reset</button>
                </div>
            </div>

            <!-- Metriche -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="metric-terreni">-</div>
                    <div class="metric-label">Terreni Totali</div>
                </div>
                <div class="metric-card blue">
                    <div class="metric-value" id="metric-ore">-</div>
                    <div class="metric-label">Ore Lavorate</div>
                    <div class="metric-subtitle" id="metric-ore-subtitle">Periodo selezionato</div>
                </div>
                <div class="metric-card orange">
                    <div class="metric-value" id="metric-attivita">-</div>
                    <div class="metric-label">AttivitÃ  Totali</div>
                    <div class="metric-subtitle" id="metric-attivita-subtitle">Periodo selezionato</div>
                </div>
                <div class="metric-card purple">
                    <div class="metric-value" id="metric-ore-mese">-</div>
                    <div class="metric-label">Ore/Mese (Media)</div>
                    <div class="metric-subtitle" id="metric-ore-mese-subtitle">Periodo selezionato</div>
                </div>
            </div>

            <!-- Grafici -->
            <div class="charts-grid">
                <div class="chart-card">
                    <h3>Ore per Tipo Lavoro</h3>
                    <div class="chart-container">
                        <canvas id="chart-ore-tipo"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h3>AttivitÃ  per Terreno</h3>
                    <div class="chart-container">
                        <canvas id="chart-attivita-terreno"></canvas>
                    </div>
                </div>
                <div class="chart-card" style="grid-column: 1 / -1;">
                    <h3>Ore Lavorate per Mese</h3>
                    <div class="chart-container tall">
                        <canvas id="chart-ore-mese"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h3>Top 5 Tipi Lavoro</h3>
                    <div class="chart-container">
                        <canvas id="chart-top-lavori"></canvas>
                    </div>
                </div>
            </div>

            <!-- Sezione Statistiche Macchine (solo se modulo Parco Macchine attivo) -->
            <div id="statistiche-macchine-section" style="display: none; margin-top: 40px; padding-top: 40px; border-top: 2px solid #e9ecef;">
                <h2 style="color: #2E8B57; font-size: 2em; margin-bottom: 30px; text-align: center;">ðŸšœ Statistiche Macchine</h2>
                
                <!-- Metriche Macchine -->
                <div class="metrics-grid">
                    <div class="metric-card" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);">
                        <div class="metric-value" id="metric-ore-macchine-totali">-</div>
                        <div class="metric-label">Ore Macchine Totali</div>
                        <div class="metric-subtitle" id="metric-ore-macchine-subtitle">Periodo selezionato</div>
                    </div>
                    <div class="metric-card" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);">
                        <div class="metric-value" id="metric-macchine-utilizzate">-</div>
                        <div class="metric-label">Macchine Utilizzate</div>
                        <div class="metric-subtitle" id="metric-macchine-utilizzate-subtitle">Periodo selezionato</div>
                    </div>
                    <div class="metric-card" style="background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);">
                        <div class="metric-value" id="metric-manutenzioni-scadenza">-</div>
                        <div class="metric-label">Manutenzioni in Scadenza</div>
                        <div class="metric-subtitle">Prossimi 30 giorni / 50 ore</div>
                    </div>
                    <div class="metric-card" style="background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);">
                        <div class="metric-value" id="metric-utilizzo-medio">-</div>
                        <div class="metric-label">Utilizzo Medio Macchina</div>
                        <div class="metric-subtitle" id="metric-utilizzo-medio-subtitle">Ore/macchina</div>
                    </div>
                </div>

                <!-- Grafici Macchine -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <h3>Top 5 Macchine PiÃ¹ Utilizzate</h3>
                        <div class="chart-container">
                            <canvas id="chart-top-macchine"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h3>Ore Macchina per Terreno</h3>
                        <div class="chart-container">
                            <canvas id="chart-ore-macchina-terreno"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h3>Ore Macchina vs Ore Lavoratore</h3>
                        <div class="chart-container">
                            <canvas id="chart-ore-macchina-vs-lavoratore"></canvas>
                        </div>
                    </div>
                    <div class="chart-card" style="grid-column: 1 / -1;">
                        <h3>Ore Macchine per Mese</h3>
                        <div class="chart-container tall">
                            <canvas id="chart-ore-macchine-mese"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Firebase config from external file -->
    <!-- Fallback: usa raw GitHub se il file locale non Ã¨ disponibile (per GitHub Pages) -->
    <script>
        function loadConfig() {
            return new Promise((resolve, reject) => {
                if (typeof window.firebaseConfig !== 'undefined') {
                    resolve();
                    return;
                }

                const configScript = document.createElement('script');
                configScript.src = 'config/firebase-config.js';
                
                configScript.onload = function() {
                    setTimeout(() => {
                        if (typeof window.firebaseConfig !== 'undefined') {
                            resolve();
                        } else {
                            loadFallbackConfig().then(resolve).catch(reject);
                        }
                    }, 100);
                };
                
                configScript.onerror = function() {
                    loadFallbackConfig().then(resolve).catch(reject);
                };
                
                document.head.appendChild(configScript);
            });
        }

        function loadFallbackConfig() {
            return new Promise((resolve, reject) => {
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://raw.githubusercontent.com/VitaraDragon/gfv-platform/main/core/config/firebase-config.js';
                
                fallbackScript.onload = function() {
                    setTimeout(() => {
                        if (typeof window.firebaseConfig !== 'undefined') {
                            resolve();
                        } else {
                            reject(new Error('Firebase config not found even after loading from GitHub'));
                        }
                    }, 100);
                };
                
                fallbackScript.onerror = function() {
                    reject(new Error('Failed to load Firebase config from GitHub'));
                };
                
                document.head.appendChild(fallbackScript);
            });
        }

        loadConfig().catch(error => {
            console.error('Errore caricamento config:', error);
        });
    </script>
    
    <!-- Firebase SDK -->
    <script type="module">
        // Attendi che lo script config sia caricato
        function waitForConfig() {
            return new Promise((resolve, reject) => {
                if (typeof window.firebaseConfig !== 'undefined') {
                    resolve(window.firebaseConfig);
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 50;
                
                const checkInterval = setInterval(() => {
                    attempts++;
                    if (typeof window.firebaseConfig !== 'undefined') {
                        clearInterval(checkInterval);
                        resolve(window.firebaseConfig);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        reject(new Error('Firebase config not loaded after 5 seconds'));
                    }
                }, 100);
            });
        }

        const firebaseConfig = await waitForConfig();

        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { 
            getFirestore, 
            collection, 
            doc, 
            getDoc, 
            getDocs, 
            query, 
            where, 
            orderBy 
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Inizializza Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Variabili globali
        let currentTenantId = null;
        let hasParcoMacchineModule = false;
        let macchineList = [];

        // Funzione helper: ottieni tenant ID
        async function getTenantId(userId) {
            if (currentTenantId) return currentTenantId;
            
            try {
                const userDoc = await getDoc(doc(db, 'users', userId));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    currentTenantId = userData.tenantId;
                    return currentTenantId;
                }
            } catch (error) {
                console.error('Errore recupero tenant:', error);
            }
            return null;
        }

        // Funzione helper: ottieni collection
        function getTerreniCollection(tenantId) {
            if (!tenantId) throw new Error('Tenant ID non disponibile');
            return collection(db, `tenants/${tenantId}/terreni`);
        }

        function getAttivitaCollection(tenantId) {
            if (!tenantId) throw new Error('Tenant ID non disponibile');
            return collection(db, `tenants/${tenantId}/attivita`);
        }

        function getMacchineCollection(tenantId) {
            if (!tenantId) throw new Error('Tenant ID non disponibile');
            return collection(db, `tenants/${tenantId}/macchine`);
        }

        // Carica macchine
        async function loadMacchine() {
            if (!currentTenantId) return;
            
            try {
                const macchineRef = getMacchineCollection(currentTenantId);
                const snapshot = await getDocs(macchineRef);
                macchineList = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    macchineList.push({
                        id: doc.id,
                        ...data
                    });
                });
                console.log(`âœ… Caricate ${macchineList.length} macchine`);
            } catch (error) {
                console.error('Errore caricamento macchine:', error);
                macchineList = [];
            }
        }

        // Verifica autenticazione
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                window.location.href = './auth/login-standalone.html';
                return;
            }

            try {
                // Carica dati utente e tenant
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    const nomeCompleto = `${userData.nome || ''} ${userData.cognome || ''}`.trim();
                    const email = userData.email || user.email;
                    document.getElementById('user-name').textContent = nomeCompleto || email || 'Utente';
                    
                    currentTenantId = userData.tenantId;
                    
                    // Verifica modulo Parco Macchine
                    try {
                        const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                        if (tenantDoc.exists()) {
                            const tenantData = tenantDoc.data();
                            hasParcoMacchineModule = tenantData.modules && tenantData.modules.includes('parcoMacchine');
                            
                            // Mostra/nascondi sezione statistiche macchine
                            const macchineSection = document.getElementById('statistiche-macchine-section');
                            if (macchineSection) {
                                macchineSection.style.display = hasParcoMacchineModule ? 'block' : 'none';
                            }
                            
                            // Carica macchine se modulo attivo
                            if (hasParcoMacchineModule) {
                                await loadMacchine();
                            }
                        }
                    } catch (error) {
                        console.error('Errore verifica modulo Parco Macchine:', error);
                    }
                } else {
                    document.getElementById('user-name').textContent = user.email || 'Utente';
                }
            } catch (error) {
                console.error('Errore caricamento utente:', error);
                document.getElementById('user-name').textContent = user.email || 'Utente';
            }

            // Inizializza app
            await initApp();
        });

        // Funzioni statistiche
        async function getAllTerreni() {
            if (!currentTenantId) {
                const user = auth.currentUser;
                if (user) {
                    currentTenantId = await getTenantId(user.uid);
                }
            }
            
            if (!currentTenantId) return [];
            
            try {
                const q = query(getTerreniCollection(currentTenantId));
                const snapshot = await getDocs(q);
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error('Errore caricamento terreni:', error);
                return [];
            }
        }

        async function getAllAttivita(filters = {}) {
            if (!currentTenantId) {
                const user = auth.currentUser;
                if (user) {
                    currentTenantId = await getTenantId(user.uid);
                }
            }
            
            if (!currentTenantId) return [];
            
            try {
                let q = query(getAttivitaCollection(currentTenantId));

                // Conta quanti filtri sono attivi
                const hasTerrenoId = !!filters.terrenoId;
                const hasTipoLavoro = !!filters.tipoLavoro;
                const hasDataDa = !!filters.dataDa;
                const hasDataA = !!filters.dataA;
                const filterCount = [hasTerrenoId, hasTipoLavoro, hasDataDa, hasDataA].filter(Boolean).length;

                // Applica filtri
                if (hasTerrenoId) {
                    q = query(q, where('terrenoId', '==', filters.terrenoId));
                }
                if (hasTipoLavoro) {
                    q = query(q, where('tipoLavoro', '==', filters.tipoLavoro));
                }
                if (hasDataDa) {
                    q = query(q, where('data', '>=', filters.dataDa));
                }
                if (hasDataA) {
                    q = query(q, where('data', '<=', filters.dataA));
                }

                // Ordina per data (richiede indice composito se ci sono 2+ filtri)
                q = query(q, orderBy('data', 'desc'));
                const snapshot = await getDocs(q);
                let results = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Se la query fallisce per mancanza di indice, prova senza orderBy e ordina in memoria
                return results;
            } catch (error) {
                // Se l'errore Ã¨ relativo agli indici, prova senza orderBy
                if (error.code === 'failed-precondition' && error.message.includes('index')) {
                    console.warn('Indice Firestore mancante, carico senza orderBy e ordino in memoria...');
                    try {
                        // Ricarica senza orderBy
                        let q = query(getAttivitaCollection(currentTenantId));
                        if (filters.terrenoId) q = query(q, where('terrenoId', '==', filters.terrenoId));
                        if (filters.tipoLavoro) q = query(q, where('tipoLavoro', '==', filters.tipoLavoro));
                        if (filters.dataDa) q = query(q, where('data', '>=', filters.dataDa));
                        if (filters.dataA) q = query(q, where('data', '<=', filters.dataA));
                        
                        const snapshot = await getDocs(q);
                        let results = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        
                        // Ordina in memoria per data
                        results.sort((a, b) => {
                            if (!a.data || !b.data) return 0;
                            return b.data.localeCompare(a.data);
                        });
                        
                        // Filtra per data se necessario (giÃ  fatto nella query, ma per sicurezza)
                        if (filters.dataDa) {
                            results = results.filter(att => att.data >= filters.dataDa);
                        }
                        if (filters.dataA) {
                            results = results.filter(att => att.data <= filters.dataA);
                        }
                        
                        // Mostra messaggio informativo
                        const indexLink = error.message.match(/https:\/\/[^\s]+/);
                        if (indexLink) {
                            console.warn('Per migliorare le prestazioni, crea l\'indice Firestore:', indexLink[0]);
                        }
                        
                        return results;
                    } catch (retryError) {
                        console.error('Errore anche senza orderBy:', retryError);
                        const indexLink = error.message.match(/https:\/\/[^\s]+/);
                        if (indexLink) {
                            alert(`Ãˆ necessario creare un indice Firestore per i filtri multipli.\n\nApri questo link per crearlo automaticamente:\n\n${indexLink[0]}\n\nDopo aver creato l'indice, attendi qualche minuto e riprova.`);
                        }
                        return [];
                    }
                } else {
                    console.error('Errore caricamento attivitÃ :', error);
                    return [];
                }
            }
        }

        // Funzioni statistiche
        async function getTotaleTerreni() {
            const terreni = await getAllTerreni();
            return terreni.length;
        }

        async function getTotaleOre(periodo = {}) {
            const attivita = await getAllAttivita(periodo);
            const totaleOre = attivita.reduce((sum, att) => sum + (att.oreNette || 0), 0);
            return parseFloat(totaleOre.toFixed(2));
        }

        async function getTotaleAttivita(periodo = {}) {
            const attivita = await getAllAttivita(periodo);
            return attivita.length;
        }

        async function getOrePerTipoLavoro(periodo = {}) {
            const attivita = await getAllAttivita(periodo);
            const orePerTipo = {};
            attivita.forEach(att => {
                const tipo = att.tipoLavoro || 'Non specificato';
                if (!orePerTipo[tipo]) {
                    orePerTipo[tipo] = 0;
                }
                orePerTipo[tipo] += att.oreNette || 0;
            });
            return Object.entries(orePerTipo)
                .map(([tipoLavoro, ore]) => ({
                    tipoLavoro,
                    ore: parseFloat(ore.toFixed(2))
                }))
                .sort((a, b) => b.ore - a.ore);
        }

        async function getAttivitaPerTerreno(periodo = {}) {
            const attivita = await getAllAttivita(periodo);
            const attivitaPerTerreno = {};
            attivita.forEach(att => {
                const terrenoNome = att.terrenoNome || 'Non specificato';
                if (!attivitaPerTerreno[terrenoNome]) {
                    attivitaPerTerreno[terrenoNome] = {
                        terrenoNome,
                        numeroAttivita: 0,
                        oreTotali: 0
                    };
                }
                attivitaPerTerreno[terrenoNome].numeroAttivita++;
                attivitaPerTerreno[terrenoNome].oreTotali += att.oreNette || 0;
            });
            return Object.values(attivitaPerTerreno)
                .map(item => ({
                    ...item,
                    oreTotali: parseFloat(item.oreTotali.toFixed(2))
                }))
                .sort((a, b) => b.numeroAttivita - a.numeroAttivita);
        }

        async function getOrePerMese(periodo = {}) {
            const attivita = await getAllAttivita(periodo);
            const orePerMese = {};
            attivita.forEach(att => {
                if (!att.data) return;
                const mese = att.data.substring(0, 7);
                if (!orePerMese[mese]) {
                    orePerMese[mese] = 0;
                }
                orePerMese[mese] += att.oreNette || 0;
            });
            return Object.entries(orePerMese)
                .map(([mese, ore]) => ({
                    mese,
                    ore: parseFloat(ore.toFixed(2))
                }))
                .sort((a, b) => a.mese.localeCompare(b.mese));
        }

        async function getTipiLavoroPiuFrequenti(periodo = {}, limit = 5) {
            const attivita = await getAllAttivita(periodo);
            const frequenza = {};
            attivita.forEach(att => {
                const tipo = att.tipoLavoro || 'Non specificato';
                frequenza[tipo] = (frequenza[tipo] || 0) + 1;
            });
            return Object.entries(frequenza)
                .map(([tipoLavoro, frequenza]) => ({
                    tipoLavoro,
                    frequenza
                }))
                .sort((a, b) => b.frequenza - a.frequenza)
                .slice(0, limit);
        }

        // Grafici
        let chartOreTipo = null;
        let chartAttivitaTerreno = null;
        let chartOreMese = null;
        let chartTopLavori = null;
        
        // Grafici Macchine
        let chartTopMacchine = null;
        let chartOreMacchinaTerreno = null;
        let chartOreMacchinaVsLavoratore = null;
        let chartOreMacchineMese = null;

        function formatOre(ore) {
            const oreInt = Math.floor(ore);
            const minuti = Math.round((ore - oreInt) * 60);
            if (minuti === 0) {
                return `${oreInt}h`;
            }
            return `${oreInt}h ${minuti}min`;
        }

        function formatMese(mese) {
            const [anno, meseNum] = mese.split('-');
            const mesi = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            return `${mesi[parseInt(meseNum) - 1]} ${anno}`;
        }

        function updateChartOreTipo(data) {
            // Trova sempre il container direttamente dal DOM usando querySelector
            let chartContainer = document.querySelector('.chart-card:has(canvas#chart-ore-tipo)') || 
                                 document.querySelector('.chart-card:has([id*="chart-ore-tipo"])') ||
                                 document.querySelector('#chart-ore-tipo')?.closest('.chart-card');
            
            // Se non trovato, cerca tra tutti i chart-card (fallback)
            if (!chartContainer) {
                const containers = document.querySelectorAll('.chart-card');
                // Il primo chart-card dovrebbe essere quello delle ore per tipo
                chartContainer = containers[0];
            }
            
            if (!chartContainer) {
                console.error('Container per chart-ore-tipo non trovato');
                return;
            }
            
            let canvas = chartContainer.querySelector('canvas#chart-ore-tipo');
            
            // Se il canvas non esiste o Ã¨ stato sostituito, ricrearlo
            if (!canvas || canvas.tagName !== 'CANVAS') {
                chartContainer.innerHTML = '<canvas id="chart-ore-tipo"></canvas>';
                canvas = document.getElementById('chart-ore-tipo');
            }
            
            if (chartOreTipo) {
                chartOreTipo.destroy();
            }
            
            if (data.length === 0) {
                chartContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“Š</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartOreTipo = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: data.map(d => d.tipoLavoro),
                    datasets: [{
                        data: data.map(d => d.ore),
                        backgroundColor: [
                            '#2E8B57', '#007bff', '#ff9800', '#9c27b0', '#e91e63',
                            '#00bcd4', '#4caf50', '#ffc107', '#795548', '#607d8b'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${formatOre(context.parsed)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChartAttivitaTerreno(data) {
            // Trova sempre il container direttamente dal DOM
            let chartContainer = document.querySelector('.chart-card:has(canvas#chart-attivita-terreno)') || 
                                 document.querySelector('#chart-attivita-terreno')?.closest('.chart-card');
            
            // Se non trovato, cerca tra tutti i chart-card (fallback)
            if (!chartContainer) {
                const containers = document.querySelectorAll('.chart-card');
                // Il secondo chart-card dovrebbe essere quello delle attivitÃ  per terreno
                chartContainer = containers[1];
            }
            
            if (!chartContainer) {
                console.error('Container per chart-attivita-terreno non trovato');
                return;
            }
            
            let canvas = chartContainer.querySelector('canvas#chart-attivita-terreno');
            
            // Se il canvas non esiste o Ã¨ stato sostituito, ricrearlo
            if (!canvas || canvas.tagName !== 'CANVAS') {
                chartContainer.innerHTML = '<canvas id="chart-attivita-terreno"></canvas>';
                canvas = document.getElementById('chart-attivita-terreno');
            }
            
            if (chartAttivitaTerreno) {
                chartAttivitaTerreno.destroy();
            }
            
            if (data.length === 0) {
                chartContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“Š</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartAttivitaTerreno = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.terrenoNome),
                    datasets: [{
                        label: 'Numero AttivitÃ ',
                        data: data.map(d => d.numeroAttivita),
                        backgroundColor: '#2E8B57'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        function updateChartOreMese(data) {
            // Trova sempre il container direttamente dal DOM
            let chartContainer = document.querySelector('.chart-card:has(canvas#chart-ore-mese)') || 
                                 document.querySelector('#chart-ore-mese')?.closest('.chart-card');
            
            // Se non trovato, cerca tra tutti i chart-card (fallback)
            if (!chartContainer) {
                const containers = document.querySelectorAll('.chart-card');
                // Il terzo chart-card dovrebbe essere quello delle ore per mese
                chartContainer = containers[2];
            }
            
            if (!chartContainer) {
                console.error('Container per chart-ore-mese non trovato');
                return;
            }
            
            let canvas = chartContainer.querySelector('canvas#chart-ore-mese');
            
            // Se il canvas non esiste o Ã¨ stato sostituito, ricrearlo
            if (!canvas || canvas.tagName !== 'CANVAS') {
                chartContainer.innerHTML = '<canvas id="chart-ore-mese"></canvas>';
                canvas = document.getElementById('chart-ore-mese');
            }
            
            if (chartOreMese) {
                chartOreMese.destroy();
            }
            
            if (data.length === 0) {
                chartContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“Š</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartOreMese = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => formatMese(d.mese)),
                    datasets: [{
                        label: 'Ore Lavorate',
                        data: data.map(d => d.ore),
                        borderColor: '#2E8B57',
                        backgroundColor: 'rgba(46, 139, 87, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${formatOre(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatOre(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChartTopLavori(data) {
            // Trova sempre il container direttamente dal DOM
            let chartContainer = document.querySelector('.chart-card:has(canvas#chart-top-lavori)') || 
                                 document.querySelector('#chart-top-lavori')?.closest('.chart-card');
            
            // Se non trovato, cerca tra tutti i chart-card (fallback)
            if (!chartContainer) {
                const containers = document.querySelectorAll('.chart-card');
                // Il quarto chart-card dovrebbe essere quello dei top lavori
                chartContainer = containers[3];
            }
            
            if (!chartContainer) {
                console.error('Container per chart-top-lavori non trovato');
                return;
            }
            
            let canvas = chartContainer.querySelector('canvas#chart-top-lavori');
            
            // Se il canvas non esiste o Ã¨ stato sostituito, ricrearlo
            if (!canvas || canvas.tagName !== 'CANVAS') {
                chartContainer.innerHTML = '<canvas id="chart-top-lavori"></canvas>';
                canvas = document.getElementById('chart-top-lavori');
            }
            
            if (chartTopLavori) {
                chartTopLavori.destroy();
            }
            
            if (data.length === 0) {
                chartContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“Š</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartTopLavori = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.tipoLavoro),
                    datasets: [{
                        label: 'Frequenza',
                        data: data.map(d => d.frequenza),
                        backgroundColor: '#007bff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Carica dati e aggiorna UI
        async function loadStatistiche() {
            try {
                // Ottieni filtri
                const dataDa = document.getElementById('filter-data-da').value;
                const dataA = document.getElementById('filter-data-a').value;
                const terrenoId = document.getElementById('filter-terreno').value;
                const tipoLavoro = document.getElementById('filter-tipo-lavoro').value;

                const periodo = {};
                if (dataDa) periodo.dataDa = dataDa;
                if (dataA) periodo.dataA = dataA;
                if (terrenoId) periodo.terrenoId = terrenoId;
                if (tipoLavoro) periodo.tipoLavoro = tipoLavoro;

                // Calcola statistiche
                const [totaleTerreni, totaleOre, totaleAttivita, orePerTipoLavoro, attivitaPerTerreno, orePerMese, tipiLavoroPiuFrequenti] = await Promise.all([
                    getTotaleTerreni(),
                    getTotaleOre(periodo),
                    getTotaleAttivita(periodo),
                    getOrePerTipoLavoro(periodo),
                    getAttivitaPerTerreno(periodo),
                    getOrePerMese(periodo),
                    getTipiLavoroPiuFrequenti(periodo, 5)
                ]);

                // Aggiorna metriche
                document.getElementById('metric-terreni').textContent = totaleTerreni;
                document.getElementById('metric-ore').textContent = formatOre(totaleOre);
                document.getElementById('metric-attivita').textContent = totaleAttivita;
                
                // Calcola media ore/mese
                const mediaOreMese = orePerMese.length > 0 ? (totaleOre / orePerMese.length).toFixed(1) : 0;
                document.getElementById('metric-ore-mese').textContent = formatOre(parseFloat(mediaOreMese));

                // Aggiorna sottotitoli
                const periodoText = dataDa && dataA ? `${dataDa} - ${dataA}` : 'Tutti i periodi';
                document.getElementById('metric-ore-subtitle').textContent = periodoText;
                document.getElementById('metric-attivita-subtitle').textContent = periodoText;
                document.getElementById('metric-ore-mese-subtitle').textContent = periodoText;

                // Aggiorna grafici
                updateChartOreTipo(orePerTipoLavoro);
                updateChartAttivitaTerreno(attivitaPerTerreno);
                updateChartOreMese(orePerMese);
                updateChartTopLavori(tipiLavoroPiuFrequenti);

                // Carica statistiche macchine se modulo attivo
                if (hasParcoMacchineModule) {
                    await loadStatisticheMacchine(periodo);
                }
            } catch (error) {
                console.error('Errore caricamento statistiche:', error);
                alert('Errore nel caricamento delle statistiche: ' + error.message);
            }
        }

        // Funzioni statistiche macchine
        async function getOreMacchineTotali(periodo = {}) {
            if (!hasParcoMacchineModule) return 0;
            
            try {
                const attivita = await getAllAttivita(periodo);
                let totaleOre = 0;
                
                // Somma ore macchina da attivitÃ  Core Base
                attivita.forEach(att => {
                    if (att.oreMacchina && att.oreMacchina > 0) {
                        totaleOre += att.oreMacchina;
                    }
                });
                
                // Se modulo Manodopera attivo, aggiungi anche ore da lavori
                try {
                    const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                    if (tenantDoc.exists()) {
                        const tenantData = tenantDoc.data();
                        const hasManodoperaModule = tenantData.modules && tenantData.modules.includes('manodopera');
                        
                        if (hasManodoperaModule) {
                            const lavoriRef = collection(db, 'tenants', currentTenantId, 'lavori');
                            const lavoriSnapshot = await getDocs(lavoriRef);
                            
                            for (const lavoroDoc of lavoriSnapshot.docs) {
                                const lavoro = lavoroDoc.data();
                                const lavoroId = lavoroDoc.id;
                                
                                // Filtra per periodo se necessario
                                if (periodo.dataDa || periodo.dataA) {
                                    const dataInizio = lavoro.dataInizio?.toDate ? lavoro.dataInizio.toDate() : new Date(lavoro.dataInizio);
                                    const dataInizioString = dataInizio.toISOString().split('T')[0];
                                    
                                    if (periodo.dataDa && dataInizioString < periodo.dataDa) continue;
                                    if (periodo.dataA && dataInizioString > periodo.dataA) continue;
                                }
                                
                                // Carica ore validate per questo lavoro
                                const oreRef = collection(db, 'tenants', currentTenantId, 'lavori', lavoroId, 'oreOperai');
                                const oreQuery = query(oreRef, where('stato', '==', 'validate'));
                                const oreSnapshot = await getDocs(oreQuery);
                                
                                oreSnapshot.forEach(oraDoc => {
                                    const ora = oraDoc.data();
                                    if (ora.oreMacchina && ora.oreMacchina > 0) {
                                        totaleOre += ora.oreMacchina;
                                    }
                                });
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Errore caricamento ore macchine da Manodopera:', error);
                }
                
                return parseFloat(totaleOre.toFixed(2));
            } catch (error) {
                console.error('Errore calcolo ore macchine totali:', error);
                return 0;
            }
        }

        async function getMacchinePiuUtilizzate(periodo = {}, limit = 5) {
            if (!hasParcoMacchineModule) return [];
            
            try {
                const attivita = await getAllAttivita(periodo);
                const orePerMacchina = {};
                
                // Conta ore per macchina da attivitÃ  Core Base
                attivita.forEach(att => {
                    if (att.macchinaId && att.oreMacchina && att.oreMacchina > 0) {
                        if (!orePerMacchina[att.macchinaId]) {
                            orePerMacchina[att.macchinaId] = 0;
                        }
                        orePerMacchina[att.macchinaId] += att.oreMacchina;
                    }
                    if (att.attrezzoId && att.oreMacchina && att.oreMacchina > 0) {
                        if (!orePerMacchina[att.attrezzoId]) {
                            orePerMacchina[att.attrezzoId] = 0;
                        }
                        orePerMacchina[att.attrezzoId] += att.oreMacchina;
                    }
                });
                
                // Se modulo Manodopera attivo, aggiungi anche ore da lavori
                try {
                    const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                    if (tenantDoc.exists()) {
                        const tenantData = tenantDoc.data();
                        const hasManodoperaModule = tenantData.modules && tenantData.modules.includes('manodopera');
                        
                        if (hasManodoperaModule) {
                            const lavoriRef = collection(db, 'tenants', currentTenantId, 'lavori');
                            const lavoriSnapshot = await getDocs(lavoriRef);
                            
                            for (const lavoroDoc of lavoriSnapshot.docs) {
                                const lavoro = lavoroDoc.data();
                                const lavoroId = lavoroDoc.id;
                                
                                // Filtra per periodo se necessario
                                if (periodo.dataDa || periodo.dataA) {
                                    const dataInizio = lavoro.dataInizio?.toDate ? lavoro.dataInizio.toDate() : new Date(lavoro.dataInizio);
                                    const dataInizioString = dataInizio.toISOString().split('T')[0];
                                    
                                    if (periodo.dataDa && dataInizioString < periodo.dataDa) continue;
                                    if (periodo.dataA && dataInizioString > periodo.dataA) continue;
                                }
                                
                                // Carica ore validate per questo lavoro
                                const oreRef = collection(db, 'tenants', currentTenantId, 'lavori', lavoroId, 'oreOperai');
                                const oreQuery = query(oreRef, where('stato', '==', 'validate'));
                                const oreSnapshot = await getDocs(oreQuery);
                                
                                oreSnapshot.forEach(oraDoc => {
                                    const ora = oraDoc.data();
                                    if (ora.macchinaId && ora.oreMacchina && ora.oreMacchina > 0) {
                                        if (!orePerMacchina[ora.macchinaId]) {
                                            orePerMacchina[ora.macchinaId] = 0;
                                        }
                                        orePerMacchina[ora.macchinaId] += ora.oreMacchina;
                                    }
                                    if (ora.attrezzoId && ora.oreMacchina && ora.oreMacchina > 0) {
                                        if (!orePerMacchina[ora.attrezzoId]) {
                                            orePerMacchina[ora.attrezzoId] = 0;
                                        }
                                        orePerMacchina[ora.attrezzoId] += ora.oreMacchina;
                                    }
                                });
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Errore caricamento ore macchine da Manodopera:', error);
                }
                
                // Assicurati che le macchine siano caricate
                if (macchineList.length === 0) {
                    await loadMacchine();
                }
                
                // Crea mappa macchine
                const macchineMap = {};
                macchineList.forEach(m => {
                    macchineMap[m.id] = m;
                });
                
                console.log('ðŸ“Š Statistiche Macchine - Debug:');
                console.log('  - Macchine caricate:', macchineList.length);
                console.log('  - Macchine con ore:', Object.keys(orePerMacchina).length);
                console.log('  - ID macchine con ore:', Object.keys(orePerMacchina));
                console.log('  - ID macchine caricate:', macchineList.map(m => m.id));
                console.log('  - Nomi macchine caricate:', macchineList.map(m => ({ id: m.id, nome: m.nome })));
                
                return Object.entries(orePerMacchina)
                    .map(([macchinaId, ore]) => {
                        const macchina = macchineMap[macchinaId];
                        if (!macchina) {
                            console.warn(`âš ï¸ Macchina ID "${macchinaId}" non trovata nella lista`);
                            console.warn(`  - ID cercato: "${macchinaId}"`);
                            console.warn(`  - ID disponibili:`, macchineList.map(m => `"${m.id}"`));
                        } else {
                            console.log(`âœ… Macchina ID "${macchinaId}" trovata: "${macchina.nome}"`);
                        }
                        return {
                            macchinaId,
                            nome: macchina?.nome || `Macchina ${macchinaId.substring(0, 8)}...`,
                            tipo: macchina?.tipoMacchina || macchina?.tipo || 'macchina',
                            ore: parseFloat(ore.toFixed(2))
                        };
                    })
                    .sort((a, b) => b.ore - a.ore)
                    .slice(0, limit);
            } catch (error) {
                console.error('Errore calcolo macchine piÃ¹ utilizzate:', error);
                return [];
            }
        }

        async function getManutenzioniInScadenza() {
            if (!hasParcoMacchineModule) return 0;
            
            try {
                const oggi = new Date();
                oggi.setHours(0, 0, 0, 0);
                const tra30Giorni = new Date(oggi);
                tra30Giorni.setDate(tra30Giorni.getDate() + 30);
                
                let count = 0;
                
                macchineList.forEach(macchina => {
                    if (macchina.stato === 'dismesso') return;
                    
                    // Verifica per ore
                    if (macchina.oreProssimaManutenzione && macchina.oreAttuali) {
                        const oreRimanenti = macchina.oreProssimaManutenzione - macchina.oreAttuali;
                        if (oreRimanenti <= 50 && oreRimanenti > 0) {
                            count++;
                        }
                    }
                    
                    // Verifica per data
                    if (macchina.prossimaManutenzione) {
                        const scadenza = macchina.prossimaManutenzione.toDate 
                            ? macchina.prossimaManutenzione.toDate() 
                            : new Date(macchina.prossimaManutenzione);
                        scadenza.setHours(0, 0, 0, 0);
                        
                        if (scadenza >= oggi && scadenza <= tra30Giorni) {
                            count++;
                        }
                    }
                });
                
                return count;
            } catch (error) {
                console.error('Errore calcolo manutenzioni in scadenza:', error);
                return 0;
            }
        }

        async function getOreMacchinaPerTerreno(periodo = {}) {
            if (!hasParcoMacchineModule) return [];
            
            try {
                const attivita = await getAllAttivita(periodo);
                const orePerTerreno = {};
                
                attivita.forEach(att => {
                    if (att.terrenoNome && att.oreMacchina && att.oreMacchina > 0) {
                        if (!orePerTerreno[att.terrenoNome]) {
                            orePerTerreno[att.terrenoNome] = 0;
                        }
                        orePerTerreno[att.terrenoNome] += att.oreMacchina;
                    }
                });
                
                // Se modulo Manodopera attivo, aggiungi anche ore da lavori
                try {
                    const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                    if (tenantDoc.exists()) {
                        const tenantData = tenantDoc.data();
                        const hasManodoperaModule = tenantData.modules && tenantData.modules.includes('manodopera');
                        
                        if (hasManodoperaModule) {
                            const lavoriRef = collection(db, 'tenants', currentTenantId, 'lavori');
                            const lavoriSnapshot = await getDocs(lavoriRef);
                            
                            for (const lavoroDoc of lavoriSnapshot.docs) {
                                const lavoro = lavoroDoc.data();
                                const lavoroId = lavoroDoc.id;
                                
                                // Filtra per periodo se necessario
                                if (periodo.dataDa || periodo.dataA) {
                                    const dataInizio = lavoro.dataInizio?.toDate ? lavoro.dataInizio.toDate() : new Date(lavoro.dataInizio);
                                    const dataInizioString = dataInizio.toISOString().split('T')[0];
                                    
                                    if (periodo.dataDa && dataInizioString < periodo.dataDa) continue;
                                    if (periodo.dataA && dataInizioString > periodo.dataA) continue;
                                }
                                
                                // Carica terreno
                                const terrenoId = lavoro.terrenoId;
                                if (!terrenoId) continue;
                                
                                const terrenoDoc = await getDoc(doc(db, 'tenants', currentTenantId, 'terreni', terrenoId));
                                const terrenoNome = terrenoDoc.exists() ? terrenoDoc.data().nome : 'Terreno sconosciuto';
                                
                                // Carica ore validate per questo lavoro
                                const oreRef = collection(db, 'tenants', currentTenantId, 'lavori', lavoroId, 'oreOperai');
                                const oreQuery = query(oreRef, where('stato', '==', 'validate'));
                                const oreSnapshot = await getDocs(oreQuery);
                                
                                oreSnapshot.forEach(oraDoc => {
                                    const ora = oraDoc.data();
                                    if (ora.oreMacchina && ora.oreMacchina > 0) {
                                        if (!orePerTerreno[terrenoNome]) {
                                            orePerTerreno[terrenoNome] = 0;
                                        }
                                        orePerTerreno[terrenoNome] += ora.oreMacchina;
                                    }
                                });
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Errore caricamento ore macchine da Manodopera:', error);
                }
                
                return Object.entries(orePerTerreno)
                    .map(([terrenoNome, ore]) => ({
                        terrenoNome,
                        ore: parseFloat(ore.toFixed(2))
                    }))
                    .sort((a, b) => b.ore - a.ore);
            } catch (error) {
                console.error('Errore calcolo ore macchina per terreno:', error);
                return [];
            }
        }

        async function getOreMacchinaVsLavoratore(periodo = {}) {
            if (!hasParcoMacchineModule) return { oreLavoratore: 0, oreMacchina: 0 };
            
            try {
                const attivita = await getAllAttivita(periodo);
                let oreLavoratore = 0;
                let oreMacchina = 0;
                
                attivita.forEach(att => {
                    if (att.oreNette) oreLavoratore += att.oreNette;
                    if (att.oreMacchina) oreMacchina += att.oreMacchina;
                });
                
                return {
                    oreLavoratore: parseFloat(oreLavoratore.toFixed(2)),
                    oreMacchina: parseFloat(oreMacchina.toFixed(2))
                };
            } catch (error) {
                console.error('Errore calcolo ore macchina vs lavoratore:', error);
                return { oreLavoratore: 0, oreMacchina: 0 };
            }
        }

        async function getOreMacchinePerMese(periodo = {}) {
            if (!hasParcoMacchineModule) return [];
            
            try {
                const attivita = await getAllAttivita(periodo);
                const orePerMese = {};
                
                attivita.forEach(att => {
                    if (!att.data || !att.oreMacchina) return;
                    const mese = att.data.substring(0, 7);
                    if (!orePerMese[mese]) {
                        orePerMese[mese] = 0;
                    }
                    orePerMese[mese] += att.oreMacchina;
                });
                
                // Se modulo Manodopera attivo, aggiungi anche ore da lavori
                try {
                    const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                    if (tenantDoc.exists()) {
                        const tenantData = tenantDoc.data();
                        const hasManodoperaModule = tenantData.modules && tenantData.modules.includes('manodopera');
                        
                        if (hasManodoperaModule) {
                            const lavoriRef = collection(db, 'tenants', currentTenantId, 'lavori');
                            const lavoriSnapshot = await getDocs(lavoriRef);
                            
                            for (const lavoroDoc of lavoriSnapshot.docs) {
                                const lavoro = lavoroDoc.data();
                                const lavoroId = lavoroDoc.id;
                                
                                // Carica ore validate per questo lavoro
                                const oreRef = collection(db, 'tenants', currentTenantId, 'lavori', lavoroId, 'oreOperai');
                                const oreQuery = query(oreRef, where('stato', '==', 'validate'));
                                const oreSnapshot = await getDocs(oreQuery);
                                
                                oreSnapshot.forEach(oraDoc => {
                                    const ora = oraDoc.data();
                                    if (ora.data && ora.oreMacchina && ora.oreMacchina > 0) {
                                        const dataOra = ora.data.toDate ? ora.data.toDate() : new Date(ora.data);
                                        const mese = dataOra.toISOString().substring(0, 7);
                                        
                                        // Filtra per periodo se necessario
                                        if (periodo.dataDa && mese < periodo.dataDa.substring(0, 7)) return;
                                        if (periodo.dataA && mese > periodo.dataA.substring(0, 7)) return;
                                        
                                        if (!orePerMese[mese]) {
                                            orePerMese[mese] = 0;
                                        }
                                        orePerMese[mese] += ora.oreMacchina;
                                    }
                                });
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Errore caricamento ore macchine da Manodopera:', error);
                }
                
                return Object.entries(orePerMese)
                    .map(([mese, ore]) => ({
                        mese,
                        ore: parseFloat(ore.toFixed(2))
                    }))
                    .sort((a, b) => a.mese.localeCompare(b.mese));
            } catch (error) {
                console.error('Errore calcolo ore macchine per mese:', error);
                return [];
            }
        }

        // Carica e aggiorna statistiche macchine
        async function loadStatisticheMacchine(periodo = {}) {
            try {
                // Assicurati che le macchine siano caricate
                if (macchineList.length === 0) {
                    await loadMacchine();
                }
                
                const [
                    oreMacchineTotali,
                    macchinePiuUtilizzate,
                    manutenzioniScadenza,
                    oreMacchinaPerTerreno,
                    oreMacchinaVsLavoratore,
                    oreMacchinePerMese
                ] = await Promise.all([
                    getOreMacchineTotali(periodo),
                    getMacchinePiuUtilizzate(periodo, 5),
                    getManutenzioniInScadenza(),
                    getOreMacchinaPerTerreno(periodo),
                    getOreMacchinaVsLavoratore(periodo),
                    getOreMacchinePerMese(periodo)
                ]);

                // Aggiorna metriche
                document.getElementById('metric-ore-macchine-totali').textContent = formatOre(oreMacchineTotali);
                document.getElementById('metric-macchine-utilizzate').textContent = macchinePiuUtilizzate.length;
                
                const macchineTotali = macchineList.filter(m => m.stato !== 'dismesso').length;
                const utilizzoMedio = macchineTotali > 0 ? (oreMacchineTotali / macchineTotali).toFixed(1) : 0;
                document.getElementById('metric-utilizzo-medio').textContent = formatOre(parseFloat(utilizzoMedio));
                document.getElementById('metric-manutenzioni-scadenza').textContent = manutenzioniScadenza;

                // Aggiorna sottotitoli
                const periodoText = periodo.dataDa && periodo.dataA ? `${periodo.dataDa} - ${periodo.dataA}` : 'Tutti i periodi';
                document.getElementById('metric-ore-macchine-subtitle').textContent = periodoText;
                document.getElementById('metric-macchine-utilizzate-subtitle').textContent = periodoText;

                // Aggiorna grafici
                updateChartTopMacchine(macchinePiuUtilizzate);
                updateChartOreMacchinaTerreno(oreMacchinaPerTerreno);
                updateChartOreMacchinaVsLavoratore(oreMacchinaVsLavoratore);
                updateChartOreMacchineMese(oreMacchinePerMese);
            } catch (error) {
                console.error('Errore caricamento statistiche macchine:', error);
            }
        }

        // Funzioni aggiornamento grafici macchine
        function updateChartTopMacchine(data) {
            const chartContainer = document.querySelector('#chart-top-macchine')?.closest('.chart-card');
            if (!chartContainer) return;
            
            let canvas = chartContainer.querySelector('canvas#chart-top-macchine');
            if (!canvas) {
                chartContainer.querySelector('.chart-container').innerHTML = '<canvas id="chart-top-macchine"></canvas>';
                canvas = document.getElementById('chart-top-macchine');
            }
            
            if (chartTopMacchine) chartTopMacchine.destroy();
            
            if (data.length === 0) {
                chartContainer.querySelector('.chart-container').innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸšœ</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartTopMacchine = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.nome),
                    datasets: [{
                        label: 'Ore Utilizzate',
                        data: data.map(d => d.ore),
                        backgroundColor: '#007bff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${formatOre(context.parsed.x)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatOre(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChartOreMacchinaTerreno(data) {
            const chartContainer = document.querySelector('#chart-ore-macchina-terreno')?.closest('.chart-card');
            if (!chartContainer) return;
            
            let canvas = chartContainer.querySelector('canvas#chart-ore-macchina-terreno');
            if (!canvas) {
                chartContainer.querySelector('.chart-container').innerHTML = '<canvas id="chart-ore-macchina-terreno"></canvas>';
                canvas = document.getElementById('chart-ore-macchina-terreno');
            }
            
            if (chartOreMacchinaTerreno) chartOreMacchinaTerreno.destroy();
            
            if (data.length === 0) {
                chartContainer.querySelector('.chart-container').innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸšœ</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartOreMacchinaTerreno = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.terrenoNome),
                    datasets: [{
                        label: 'Ore Macchina',
                        data: data.map(d => d.ore),
                        backgroundColor: '#2E8B57'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${formatOre(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatOre(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChartOreMacchinaVsLavoratore(data) {
            const chartContainer = document.querySelector('#chart-ore-macchina-vs-lavoratore')?.closest('.chart-card');
            if (!chartContainer) return;
            
            let canvas = chartContainer.querySelector('canvas#chart-ore-macchina-vs-lavoratore');
            if (!canvas) {
                chartContainer.querySelector('.chart-container').innerHTML = '<canvas id="chart-ore-macchina-vs-lavoratore"></canvas>';
                canvas = document.getElementById('chart-ore-macchina-vs-lavoratore');
            }
            
            if (chartOreMacchinaVsLavoratore) chartOreMacchinaVsLavoratore.destroy();
            
            if (data.oreLavoratore === 0 && data.oreMacchina === 0) {
                chartContainer.querySelector('.chart-container').innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸšœ</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartOreMacchinaVsLavoratore = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Ore Lavoratore', 'Ore Macchina'],
                    datasets: [{
                        data: [data.oreLavoratore, data.oreMacchina],
                        backgroundColor: ['#2E8B57', '#007bff']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'right' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${formatOre(context.parsed)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChartOreMacchineMese(data) {
            const chartContainer = document.querySelector('#chart-ore-macchine-mese')?.closest('.chart-card');
            if (!chartContainer) return;
            
            let canvas = chartContainer.querySelector('canvas#chart-ore-macchine-mese');
            if (!canvas) {
                chartContainer.querySelector('.chart-container').innerHTML = '<canvas id="chart-ore-macchine-mese"></canvas>';
                canvas = document.getElementById('chart-ore-macchine-mese');
            }
            
            if (chartOreMacchineMese) chartOreMacchineMese.destroy();
            
            if (data.length === 0) {
                chartContainer.querySelector('.chart-container').innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸšœ</div><p>Nessun dato disponibile</p></div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            chartOreMacchineMese = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => formatMese(d.mese)),
                    datasets: [{
                        label: 'Ore Macchine',
                        data: data.map(d => d.ore),
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${formatOre(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatOre(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        // Carica dropdown filtri
        async function loadFilters() {
            try {
                if (!currentTenantId) {
                    const user = auth.currentUser;
                    if (user) {
                        currentTenantId = await getTenantId(user.uid);
                    }
                }
                
                if (!currentTenantId) {
                    console.warn('Tenant ID non disponibile per caricare filtri');
                    return;
                }

                // Carica terreni
                const terreni = await getAllTerreni();
                const selectTerreno = document.getElementById('filter-terreno');
                selectTerreno.innerHTML = '<option value="">Tutti i terreni</option>';
                terreni.forEach(terreno => {
                    const option = document.createElement('option');
                    option.value = terreno.id;
                    option.textContent = terreno.nome;
                    selectTerreno.appendChild(option);
                });

                // Carica tipi lavoro dalle liste personalizzate
                try {
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    
                    let tipiLavoro = [];
                    if (listeSnap.exists()) {
                        const data = listeSnap.data();
                        tipiLavoro = data.tipiLavoro || [];
                    } else {
                        // Predefiniti
                        tipiLavoro = ['Potatura', 'Raccolta', 'Trattamento', 'Semina', 'Aratura', 'Irrigazione', 'Concimazione', 'Diserbo', 'Raccolta frutta', 'Raccolta verdura'];
                    }
                    
                    const selectTipoLavoro = document.getElementById('filter-tipo-lavoro');
                    selectTipoLavoro.innerHTML = '<option value="">Tutti i tipi</option>';
                    tipiLavoro.forEach(tipo => {
                        const option = document.createElement('option');
                        option.value = tipo;
                        option.textContent = tipo;
                        selectTipoLavoro.appendChild(option);
                    });
                } catch (error) {
                    console.error('Errore caricamento tipi lavoro:', error);
                    // Fallback: carica dalle attivitÃ 
                    const attivita = await getAllAttivita();
                    const tipiLavoro = [...new Set(attivita.map(a => a.tipoLavoro).filter(Boolean))].sort();
                    const selectTipoLavoro = document.getElementById('filter-tipo-lavoro');
                    selectTipoLavoro.innerHTML = '<option value="">Tutti i tipi</option>';
                    tipiLavoro.forEach(tipo => {
                        const option = document.createElement('option');
                        option.value = tipo;
                        option.textContent = tipo;
                        selectTipoLavoro.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Errore caricamento filtri:', error);
            }
        }

        // Funzioni filtri
        window.applyFilters = function() {
            loadStatistiche();
        };

        window.resetFilters = function() {
            document.getElementById('filter-data-da').value = '';
            document.getElementById('filter-data-a').value = '';
            document.getElementById('filter-terreno').value = '';
            document.getElementById('filter-tipo-lavoro').value = '';
            loadStatistiche();
        };

        // Inizializza app
        async function initApp() {
            try {
                await loadFilters();
                await loadStatistiche();
            } catch (error) {
                console.error('Errore inizializzazione app:', error);
            }
        }
    </script>
</body>
</html>


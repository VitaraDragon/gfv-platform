<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impostazioni - GFV Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #2E8B57 0%, #228B22 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 28px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
            display: inline-block;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.3);
        }

        .content {
            display: grid;
            gap: 20px;
        }

        .card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #2E8B57;
            margin-bottom: 20px;
            font-size: 20px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #2E8B57;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .btn-primary {
            background: #2E8B57;
            color: white;
            padding: 12px 24px;
        }

        .btn-primary:hover {
            background: #228B22;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .info-text {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }

        .list-container {
            display: grid;
            gap: 10px;
        }

        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .list-item-name {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-custom {
            background: #ffc107;
            color: #212529;
        }

        .badge-predefinito {
            background: #28a745;
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            margin: auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 15px;
        }

        .modal-header h3 {
            color: #2E8B57;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal:hover {
            color: #333;
        }

        #podere-map-container {
            position: relative;
        }

        .map-marker-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-size: 12px;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>‚öôÔ∏è Impostazioni</h1>
                <p style="opacity: 0.9; margin-top: 5px;">Configura azienda e account</p>
            </div>
            <a href="../dashboard-standalone.html" class="btn btn-secondary">‚Üê Dashboard</a>
        </div>

        <div class="content">
            <div id="alert-container"></div>

            <!-- Impostazioni Azienda (solo Manager/Amministratore) -->
            <div class="card" id="azienda-section" style="display: none;">
                <h2>Informazioni Azienda</h2>
                <form id="azienda-form" onsubmit="handleSaveAzienda(event)">
                    <div class="form-group">
                        <label for="azienda-nome">Nome Azienda *</label>
                        <input type="text" id="azienda-nome" required placeholder="Es: Vigneto Rossi">
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="azienda-piva">Partita IVA</label>
                            <input type="text" id="azienda-piva" placeholder="IT12345678901">
                        </div>
                        <div class="form-group">
                            <label for="azienda-cf">Codice Fiscale</label>
                            <input type="text" id="azienda-cf" placeholder="RSSMRA80A01H501U">
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="azienda-indirizzo">Indirizzo</label>
                        <input type="text" id="azienda-indirizzo" placeholder="Via Roma 123">
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="azienda-citta">Citt√†</label>
                            <input type="text" id="azienda-citta" placeholder="Milano">
                        </div>
                        <div class="form-group">
                            <label for="azienda-cap">CAP</label>
                            <input type="text" id="azienda-cap" placeholder="20100">
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="azienda-provincia">Provincia</label>
                        <input type="text" id="azienda-provincia" placeholder="MI">
                    </div>

                    <div class="form-group">
                        <label for="azienda-telefono">Telefono</label>
                        <input type="tel" id="azienda-telefono" placeholder="+39 02 1234567">
                    </div>

                    <div class="form-group">
                        <label for="azienda-email">Email Aziendale</label>
                        <input type="email" id="azienda-email" placeholder="info@azienda.it">
                    </div>

                    <div class="form-group">
                        <label for="azienda-note">Note</label>
                        <textarea id="azienda-note" placeholder="Note aggiuntive sull'azienda"></textarea>
                    </div>

                    <div class="form-group">
                        <label for="azienda-logo">Logo Aziendale</label>
                        <div style="display: flex; gap: 15px; align-items: flex-start; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 200px;">
                                <input type="file" id="azienda-logo" accept="image/*" onchange="handleLogoUpload(event)" style="margin-bottom: 10px;">
                                <small style="display: block; color: #666; margin-top: 5px;">
                                    Formati supportati: PNG, JPG, SVG (max 2MB). Il logo verr√† usato nei preventivi inviati ai clienti.
                                </small>
                            </div>
                            <div id="logo-preview-container" style="min-width: 150px;">
                                <div id="logo-preview" style="display: none; margin-top: 10px;">
                                    <img id="logo-preview-img" src="" alt="Logo preview" style="max-width: 150px; max-height: 80px; border: 1px solid #ddd; border-radius: 4px; padding: 5px; background: white;">
                                    <button type="button" onclick="rimuoviLogo()" style="display: block; margin-top: 5px; padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Rimuovi Logo</button>
                                </div>
                                <div id="logo-current" style="display: none; margin-top: 10px;">
                                    <p style="font-size: 12px; color: #666; margin-bottom: 5px;">Logo attuale:</p>
                                    <img id="logo-current-img" src="" alt="Logo attuale" style="max-width: 150px; max-height: 80px; border: 1px solid #ddd; border-radius: 4px; padding: 5px; background: white;">
                                </div>
                            </div>
                        </div>
                    </div>

                    <button type="submit" class="btn btn-primary">Salva Impostazioni Azienda</button>
                </form>
            </div>

            <!-- Comunicazioni Squadra (solo Caposquadra) -->
            <div class="card" id="comunicazioni-section" style="display: none;">
                <h2>üì¢ Comunicazioni Squadra</h2>
                <p class="info-text" style="margin-bottom: 20px;">Invia comunicazioni di ritrovo alla tua squadra. Gli operai riceveranno la notifica nella loro dashboard.</p>
                
                <form id="comunicazione-form" onsubmit="handleSendComunicazione(event)">
                    <div class="form-group">
                        <label for="comunicazione-lavoro">Seleziona Lavoro (opzionale)</label>
                        <select id="comunicazione-lavoro" onchange="handleLavoroChange()">
                            <option value="">-- Seleziona lavoro per pre-compilare --</option>
                        </select>
                        <div class="info-text" style="margin-top: 5px;">Seleziona un lavoro per pre-compilare automaticamente podere e terreno</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="comunicazione-podere">Podere *</label>
                        <select id="comunicazione-podere" required>
                            <option value="">-- Seleziona podere --</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="comunicazione-terreno">Campo/Terreno *</label>
                        <select id="comunicazione-terreno" required>
                            <option value="">-- Seleziona terreno --</option>
                        </select>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="comunicazione-data">Data Ritrovo *</label>
                            <input type="date" id="comunicazione-data" required>
                        </div>
                        <div class="form-group">
                            <label for="comunicazione-orario">Orario Ritrovo *</label>
                            <input type="time" id="comunicazione-orario" required value="07:00">
                            <div class="info-text">Orario di default: 7:00</div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="comunicazione-note">Note Aggiuntive</label>
                        <textarea id="comunicazione-note" placeholder="Eventuali note o istruzioni particolari per la squadra..." rows="3"></textarea>
                    </div>
                    
                    <button type="submit" class="btn btn-primary">üì§ Invia alla Squadra</button>
                </form>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e9ecef;">
                    <h3 style="color: #2E8B57; font-size: 18px; margin-bottom: 15px;">Comunicazioni Inviate</h3>
                    <div id="comunicazioni-list" class="list-container">
                        <!-- Lista verr√† popolata dinamicamente -->
                    </div>
                </div>
            </div>

            <!-- Impostazioni Account (tutti i ruoli) -->
            <div class="card" id="account-section">
                <h2>Impostazioni Account Personale</h2>
                <form id="account-form" onsubmit="handleSaveAccount(event)">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="account-nome">Nome *</label>
                            <input type="text" id="account-nome" required>
                        </div>
                        <div class="form-group">
                            <label for="account-cognome">Cognome *</label>
                            <input type="text" id="account-cognome" required>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="account-email">Email</label>
                        <input type="email" id="account-email" readonly>
                        <div class="info-text">L'email non pu√≤ essere modificata</div>
                    </div>

                    <div class="form-group">
                        <label for="account-telefono">Telefono</label>
                        <input type="tel" id="account-telefono" placeholder="+39 333 1234567">
                    </div>

                    <button type="submit" class="btn btn-primary">Salva Impostazioni Account</button>
                </form>
            </div>

            <!-- Cambio Password (tutti i ruoli) -->
            <div class="card" id="password-section">
                <h2>Cambio Password</h2>
                <form id="password-form" onsubmit="handleChangePassword(event)">
                    <div class="form-group">
                        <label for="password-current">Password Attuale *</label>
                        <input type="password" id="password-current" required>
                    </div>

                    <div class="form-group">
                        <label for="password-new">Nuova Password *</label>
                        <input type="password" id="password-new" required minlength="6">
                        <div class="info-text">Minimo 6 caratteri</div>
                    </div>

                    <div class="form-group">
                        <label for="password-confirm">Conferma Nuova Password *</label>
                        <input type="password" id="password-confirm" required minlength="6">
                    </div>

                    <button type="submit" class="btn btn-primary">Cambia Password</button>
                </form>
            </div>

            <!-- Gestione Poderi (solo Manager/Amministratore) -->
            <div class="card" id="poderi-section" style="display: none;">
                <h2>üè° Gestione Poderi</h2>
                <p class="info-text" style="margin-bottom: 20px;">Gestisci i poderi dell'azienda. I poderi possono essere assegnati ai terreni e utilizzati per filtri e report.</p>
                
                <div class="form-group" style="margin-bottom: 20px;">
                    <button type="button" class="btn btn-primary" onclick="openPodereModal()">‚ûï Aggiungi Podere</button>
                </div>

                <div id="poderi-list" class="list-container">
                    <!-- Lista verr√† popolata dinamicamente -->
                </div>
            </div>

            <!-- Liste Personalizzate (solo Manager/Amministratore) -->
            <div class="card" id="liste-section" style="display: none;">
                <h2>üìã Liste Personalizzate</h2>
                <p class="info-text" style="margin-bottom: 20px;">Gestisci tipi lavoro e colture personalizzate. Gli elementi predefiniti non possono essere eliminati.</p>
                
                <!-- Tipi Lavoro -->
                <div style="margin-bottom: 40px;">
                    <h3 style="color: #2E8B57; font-size: 18px; margin-bottom: 15px; border-bottom: 1px solid #e9ecef; padding-bottom: 8px;">Tipi Lavoro</h3>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label for="tipo-lavoro-categoria-select" style="display: block; margin-bottom: 5px; font-weight: 500;">Categoria *</label>
                        <div style="display: flex; gap: 10px;">
                            <select id="tipo-lavoro-categoria-select" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" onchange="updateSottocategorieDropdown()">
                                <option value="">-- Seleziona categoria --</option>
                            </select>
                            <button type="button" class="btn btn-primary" onclick="openAddCategoriaTipoLavoroModal()" style="padding: 8px 15px; white-space: nowrap;" title="Aggiungi nuova categoria">‚ûï</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 20px; display: none;" id="tipo-lavoro-sottocategoria-group">
                        <label for="tipo-lavoro-sottocategoria-select" style="display: block; margin-bottom: 5px; font-weight: 500;">Sottocategoria</label>
                        <div style="display: flex; gap: 10px;">
                            <select id="tipo-lavoro-sottocategoria-select" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" onchange="updateTipiLavoroPredefinitiDropdown().catch(console.error)">
                                <option value="">-- Seleziona sottocategoria (opzionale) --</option>
                            </select>
                            <button type="button" class="btn btn-primary" onclick="openAddSottocategoriaTipoLavoroModal()" style="padding: 8px 15px; white-space: nowrap;" title="Aggiungi nuova sottocategoria">‚ûï</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Seleziona tipo lavoro predefinito o aggiungi personalizzato</label>
                        <select id="new-tipo-lavoro-predeterminato" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;" onchange="onTipoLavoroPredeterminatoChange()">
                            <option value="">-- Seleziona un tipo lavoro predefinito (opzionale) --</option>
                        </select>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span style="color: #666; font-size: 14px;">oppure</span>
                            <input type="text" id="new-tipo-lavoro" placeholder="Digita nome tipo lavoro personalizzato..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <button type="button" class="btn btn-primary" onclick="addTipoLavoro()">‚ûï Aggiungi</button>
                        </div>
                    </div>

                    <div id="tipi-lavoro-list" class="list-container">
                        <!-- Lista verr√† popolata dinamicamente (solo tipi custom) -->
                    </div>
                </div>

                <!-- Colture -->
                <div>
                    <h3 style="color: #2E8B57; font-size: 18px; margin-bottom: 15px; border-bottom: 1px solid #e9ecef; padding-bottom: 8px;">Colture</h3>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label for="coltura-categoria-select" style="display: block; margin-bottom: 5px; font-weight: 500;">Categoria *</label>
                        <div style="display: flex; gap: 10px;">
                            <select id="coltura-categoria-select" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="">-- Seleziona categoria --</option>
                            </select>
                            <button type="button" class="btn btn-primary" onclick="openAddCategoriaColturaModal()" style="padding: 8px 15px; white-space: nowrap;" title="Aggiungi nuova categoria">‚ûï</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Seleziona coltura predefinita o aggiungi personalizzata</label>
                        <select id="new-coltura-predeterminata" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;" onchange="onColturaPredeterminataChange()">
                            <option value="">-- Seleziona una coltura predefinita (opzionale) --</option>
                        </select>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span style="color: #666; font-size: 14px;">oppure</span>
                            <input type="text" id="new-coltura" placeholder="Digita nome coltura personalizzata..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <button type="button" class="btn btn-primary" onclick="addColtura()">‚ûï Aggiungi</button>
                        </div>
                    </div>

                    <div id="colture-list" class="list-container">
                        <!-- Lista verr√† popolata dinamicamente per categoria -->
                    </div>
                </div>
            </div>

            <!-- Modal Aggiungi Categoria Coltura -->
            <div id="categoria-coltura-modal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Aggiungi Nuova Categoria Coltura</h3>
                        <button class="close-modal" onclick="closeAddCategoriaColturaModal()">&times;</button>
                    </div>
                    <form onsubmit="event.preventDefault(); addCategoriaColtura();">
                        <div class="form-group">
                            <label for="new-categoria-coltura-nome">Nome Categoria *</label>
                            <input type="text" id="new-categoria-coltura-nome" required placeholder="Es: Leguminose, Cereali...">
                            <small style="color: #666;">Il codice verr√† generato automaticamente dal nome</small>
                        </div>
                        <div class="form-group">
                            <label for="new-categoria-coltura-descrizione">Descrizione</label>
                            <textarea id="new-categoria-coltura-descrizione" rows="3" placeholder="Descrizione opzionale della categoria"></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button type="button" class="btn btn-secondary" onclick="closeAddCategoriaColturaModal()">Annulla</button>
                            <button type="submit" class="btn btn-primary">Aggiungi Categoria</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

            <!-- Tariffe Operai (solo Manager/Amministratore) -->
            <div class="card" id="tariffe-section" style="display: none;">
                <h2>üí∞ Tariffe</h2>
                
                <!-- Tariffe Operai (solo se modulo Manodopera attivo) -->
                <div id="tariffe-operai-section" style="display: none;">
                    <h3 style="margin-bottom: 15px;">üë∑ Tariffe Operai</h3>
                    <p class="info-text" style="margin-bottom: 20px;">Configura le tariffe orarie di default per ogni tipo operaio. Queste tariffe verranno utilizzate per il calcolo compensi. Puoi anche impostare tariffe personalizzate per singoli operai nella pagina Gestione Operai.</p>
                    
                    <div id="tariffe-list" class="list-container">
                        <!-- Lista verr√† popolata dinamicamente -->
                    </div>
                </div>
                
                <!-- Tariffa Proprietario (sempre visibile) -->
                <div id="tariffa-proprietario-section" style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <h3 style="margin-bottom: 15px;">üë§ Tariffa Proprietario</h3>
                    <p class="info-text" style="margin-bottom: 15px;">Configura la tariffa oraria per il calcolo dei costi. Questa tariffa verr√† utilizzata per calcolare il costo della manodopera quando i lavori vengono tracciati nel Diario Attivit√†, specialmente quando il modulo Manodopera non √® attivo.</p>
                    
                    <div class="form-group" style="max-width: 300px;">
                        <label for="tariffa-proprietario">Tariffa Oraria Proprietario (‚Ç¨/ora) *</label>
                        <input type="number" id="tariffa-proprietario" step="0.01" min="0" placeholder="15.00" required>
                        <small>Tariffa oraria utilizzata per calcolare i costi quando il proprietario svolge i lavori direttamente</small>
                    </div>
                    
                    <button type="button" class="btn btn-primary" onclick="saveTariffaProprietario()">üíæ Salva Tariffa Proprietario</button>
                </div>
            </div>

            <!-- Coefficienti Morfologia Conto Terzi (solo Manager/Amministratore) -->
            <div class="card" id="coefficienti-morfologia-section" style="display: none;">
                <h2>‚õ∞Ô∏è Coefficienti Morfologia Terreni (Conto Terzi)</h2>
                <p class="info-text" style="margin-bottom: 20px;">Configura le maggiorazioni percentuali per le diverse morfologie del terreno rispetto alla pianura. Questi coefficienti verranno utilizzati automaticamente quando crei tariffe per tutte le morfologie. La tariffa finale sar√† calcolata come: Tariffa Base √ó (1 + Maggiorazione%).</p>
                
                <form id="coefficienti-morfologia-form" onsubmit="handleSaveCoefficientiMorfologia(event)">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="coeff-pianura">üèûÔ∏è Pianura</label>
                            <input type="number" id="coeff-pianura" required step="1" min="0" max="1000" value="0" placeholder="0" readonly style="background-color: #f5f5f5;">
                            <small>Base di riferimento (0% = nessuna maggiorazione)</small>
                        </div>
                        <div class="form-group">
                            <label for="coeff-collina">‚õ∞Ô∏è Collina</label>
                            <input type="number" id="coeff-collina" required step="1" min="0" max="1000" value="20" placeholder="20">
                            <small>Maggiorazione percentuale rispetto alla pianura (es: 20% = +20%)</small>
                        </div>
                        <div class="form-group">
                            <label for="coeff-montagna">üèîÔ∏è Montagna</label>
                            <input type="number" id="coeff-montagna" required step="1" min="0" max="1000" value="50" placeholder="50">
                            <small>Maggiorazione percentuale rispetto alla pianura (es: 50% = +50%)</small>
                        </div>
                    </div>

                    <button type="submit" class="btn btn-primary">üíæ Salva Coefficienti</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal Podere -->
    <div id="podere-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="podere-modal-title">Aggiungi Podere</h3>
                <button class="close-modal" onclick="closePodereModal()">&times;</button>
            </div>
            <form id="podere-form" onsubmit="handleSavePodere(event)">
                <div class="form-group">
                    <label for="podere-nome">Nome Podere *</label>
                    <input type="text" id="podere-nome" required placeholder="Es. Podere San Giovanni">
                </div>
                <div class="form-group">
                    <label for="podere-indirizzo">Indirizzo</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <input type="text" id="podere-indirizzo" placeholder="Via Roma 123, Citt√†" style="flex: 1;">
                        <button type="button" class="btn btn-primary" onclick="searchPodereAddress()" style="white-space: nowrap;">üîç Cerca</button>
                    </div>
                    <div id="podere-map-container" style="height: 300px; width: 100%; border: 1px solid #ced4da; border-radius: 6px; margin-top: 10px; display: none; position: relative;">
                        <div id="podere-map" style="height: 100%; width: 100%;"></div>
                        <div id="podere-map-actions" style="position: absolute; top: 10px; right: 10px; display: none;">
                            <button type="button" class="btn btn-primary" onclick="openDirections()" style="font-size: 12px; padding: 6px 12px; white-space: nowrap;">üó∫Ô∏è Indicazioni</button>
                        </div>
                    </div>
                    <small style="display: block; margin-top: 5px;">Cerca l'indirizzo per posizionare il marker sulla mappa. Puoi anche cliccare sulla mappa per posizionare il marker manualmente.</small>
                </div>
                <div class="form-group">
                    <label for="podere-note">Note</label>
                    <textarea id="podere-note" placeholder="Note aggiuntive sul podere..."></textarea>
                </div>
                <div class="form-group" style="display: flex; gap: 10px; margin-top: 20px;">
                    <button type="submit" class="btn btn-primary" style="flex: 1;">Salva</button>
                    <button type="button" class="btn btn-secondary" onclick="closePodereModal()">Annulla</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Load Firebase config from external file -->
    <!-- Fallback: usa raw GitHub se il file locale non √® disponibile (per GitHub Pages) -->
    <script>
        const configScript = document.createElement('script');
        configScript.src = '../config/firebase-config.js';
        configScript.onerror = function() {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = 'https://raw.githubusercontent.com/VitaraDragon/gfv-platform/main/core/config/firebase-config.js';
            document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(configScript);
    </script>
    
    <!-- Load Google Maps config -->
    <script>
        const mapsConfigScript = document.createElement('script');
        mapsConfigScript.src = '../config/google-maps-config.js';
        mapsConfigScript.onerror = function() {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = 'https://raw.githubusercontent.com/VitaraDragon/gfv-platform/main/core/config/google-maps-config.js';
            document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(mapsConfigScript);
    </script>
    
    <!-- Firebase SDK -->
    <script type="module">
        // Funzione per attendere il caricamento della configurazione Firebase
        function waitForConfig() {
            return new Promise((resolve, reject) => {
                if (typeof window.firebaseConfig !== 'undefined') {
                    resolve(window.firebaseConfig);
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 50;
                
                const checkInterval = setInterval(() => {
                    attempts++;
                    if (typeof window.firebaseConfig !== 'undefined') {
                        clearInterval(checkInterval);
                        resolve(window.firebaseConfig);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        reject(new Error('Firebase config not loaded after 5 seconds'));
                    }
                }, 100);
            });
        }

        const firebaseConfig = await waitForConfig();
        
        // Attendi Google Maps config e carica API
        function waitForMapsConfig() {
            return new Promise((resolve, reject) => {
                if (typeof window.GOOGLE_MAPS_API_KEY !== 'undefined') {
                    resolve(window.GOOGLE_MAPS_API_KEY);
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 50;
                
                const checkInterval = setInterval(() => {
                    attempts++;
                    if (typeof window.GOOGLE_MAPS_API_KEY !== 'undefined') {
                        clearInterval(checkInterval);
                        resolve(window.GOOGLE_MAPS_API_KEY);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        resolve(null); // Non fallire, solo non caricare Maps
                    }
                }, 100);
            });
        }
        
        // Carica Google Maps API se disponibile
        try {
            GOOGLE_MAPS_API_KEY = await waitForMapsConfig();
            
            if (GOOGLE_MAPS_API_KEY && GOOGLE_MAPS_API_KEY !== 'YOUR_GOOGLE_MAPS_API_KEY_HERE') {
                const script = document.createElement('script');
                script.async = true;
                script.defer = true;
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=geometry&loading=async&callback=initGoogleMapsPodere`;
                document.head.appendChild(script);
                
                window.initGoogleMapsPodere = function() {

                    window.googleMapsReadyPodere = true;
                };
            } else {
                console.warn('Google Maps API key non disponibile');
                window.googleMapsReadyPodere = false;
            }
        } catch (e) {
            console.warn('Google Maps config non disponibile:', e);
            window.googleMapsReadyPodere = false;
        }

        const {
            initializeFirebase,
            getAuthInstance,
            getDb,
            getAppInstance,
            onAuthStateChanged,
            doc,
            getDoc,
            updateDoc,
            setDoc,
            serverTimestamp,
            query,
            collection,
            where,
            getDocs,
            addDoc,
            deleteDoc,
            orderBy
        } = await import('../services/firebase-service.js');
        initializeFirebase(firebaseConfig);
        const app = getAppInstance();
        const auth = getAuthInstance();
        const db = getDb();
        const { updatePassword, reauthenticateWithCredential, EmailAuthProvider } = await import('https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js');
        const { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } = await import('https://www.gstatic.com/firebasejs/11.0.0/firebase-storage.js');
        const storage = getStorage(app);

        let currentUserData = null;
        let currentTenantId = null;
        let currentPodereId = null;
        let poderiList = [];
        let podereMap = null;
        let podereMarker = null;
        let logoFileToUpload = null;
        
        // Liste predefinite
        const TIPI_LAVORO_PREDEFINITI = [
            'Potatura', 'Raccolta', 'Trattamento', 'Semina', 'Aratura',
            'Irrigazione', 'Concimazione', 'Diserbo', 'Raccolta frutta', 'Raccolta verdura'
        ];
        const COLTURE_PREDEFINITE = [
            'Vite', 'Frutteto', 'Seminativo', 'Orto', 'Prato', 'Olivo', 'Agrumeto', 'Bosco'
        ];

        // Carica dati utente
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                window.location.href = '../auth/login-standalone.html';
                return;
            }

            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (userDoc.exists()) {
                    currentUserData = userDoc.data();
                    
                    // Pre-compila form account
                    document.getElementById('account-nome').value = currentUserData.nome || '';
                    document.getElementById('account-cognome').value = currentUserData.cognome || '';
                    document.getElementById('account-email').value = currentUserData.email || user.email;
                    document.getElementById('account-telefono').value = currentUserData.telefono || '';

                    // Salva tenant ID
                    currentTenantId = currentUserData.tenantId;
                    
                    // Imposta tenantId nel tenant-service per i servizi
                    try {
                        const { setCurrentTenantId } = await import('../services/tenant-service.js');
                        setCurrentTenantId(currentTenantId);
                    } catch (error) {
                        console.warn('Impossibile impostare tenantId nel servizio:', error);
                    }
                    
                    // Controlla ruoli e mostra/nascondi sezioni
                    const ruoli = currentUserData.ruoli || [];
                    const isManager = ruoli.includes('manager') || ruoli.includes('amministratore');
                    const isCaposquadra = ruoli.includes('caposquadra');
                    
                    // Mostra/nascondi sezioni in base al ruolo
                    if (isManager) {
                        // Manager/Amministratore: mostra tutto
                        document.getElementById('azienda-section').style.display = 'block';
                        document.getElementById('poderi-section').style.display = 'block';
                        document.getElementById('liste-section').style.display = 'block';
                        document.getElementById('tariffe-section').style.display = 'block';
                        document.getElementById('coefficienti-morfologia-section').style.display = 'block';
                        
                        // Carica dati azienda
                        if (currentTenantId) {
                            const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                            let hasManodoperaModule = false;
                            let hasContoTerziModule = false;
                            
                            if (tenantDoc.exists()) {
                                const tenantData = tenantDoc.data();
                                document.getElementById('azienda-nome').value = tenantData.nome || '';
                                document.getElementById('azienda-piva').value = tenantData.piva || '';
                                document.getElementById('azienda-cf').value = tenantData.cf || '';
                                document.getElementById('azienda-indirizzo').value = tenantData.indirizzo || '';
                                document.getElementById('azienda-citta').value = tenantData.citta || '';
                                document.getElementById('azienda-cap').value = tenantData.cap || '';
                                document.getElementById('azienda-provincia').value = tenantData.provincia || '';
                                document.getElementById('azienda-telefono').value = tenantData.telefono || '';
                                document.getElementById('azienda-email').value = tenantData.email || '';
                                document.getElementById('azienda-note').value = tenantData.note || '';
                                
                                // Verifica moduli attivi
                                hasManodoperaModule = tenantData.modules && tenantData.modules.includes('manodopera');
                                hasContoTerziModule = tenantData.modules && tenantData.modules.includes('contoTerzi');
                                
                                // Carica logo esistente se presente
                                if (tenantData.logoUrl) {
                                    document.getElementById('logo-current-img').src = tenantData.logoUrl;
                                    document.getElementById('logo-current').style.display = 'block';
                                }
                            }
                            
                            // Mostra/nascondi tariffe operai in base al modulo Manodopera
                            const tariffeOperaiSection = document.getElementById('tariffe-operai-section');
                            if (tariffeOperaiSection) {
                                tariffeOperaiSection.style.display = hasManodoperaModule ? 'block' : 'none';
                            }
                            
                            // Tariffa proprietario sempre visibile (serve anche senza manodopera)
                            const tariffaProprietarioSection = document.getElementById('tariffa-proprietario-section');
                            if (tariffaProprietarioSection) {
                                tariffaProprietarioSection.style.display = 'block';
                            }
                            
                            // Mostra/nascondi coefficienti morfologia in base al modulo Conto Terzi
                            const coefficientiMorfologiaSection = document.getElementById('coefficienti-morfologia-section');
                            if (coefficientiMorfologiaSection) {
                                coefficientiMorfologiaSection.style.display = hasContoTerziModule ? 'block' : 'none';
                            }
                            
                            // Carica liste personalizzate, poderi e tariffe
                            await loadListe();
                            await loadPoderi();
                            
                            // Carica tariffe operai solo se modulo Manodopera attivo
                            if (hasManodoperaModule) {
                                await loadTariffe();
                            }
                            
                            // Carica sempre tariffa proprietario
                            await loadTariffaProprietario();
                            
                            // Carica coefficienti morfologia solo se modulo Conto Terzi attivo
                            if (hasContoTerziModule) {
                                await loadCoefficientiMorfologia();
                            }
                        }
                    } else {
                        // Nascondi sezioni azienda per non-manager
                        document.getElementById('azienda-section').style.display = 'none';
                        document.getElementById('poderi-section').style.display = 'none';
                        document.getElementById('liste-section').style.display = 'none';
                        document.getElementById('tariffe-section').style.display = 'none';
                        document.getElementById('coefficienti-morfologia-section').style.display = 'none';
                    }
                    
                    if (isCaposquadra) {
                        // Caposquadra: mostra sezione comunicazioni
                        document.getElementById('comunicazioni-section').style.display = 'block';
                        
                        // Carica poderi, terreni e lavori per dropdown comunicazioni
                        if (currentTenantId) {
                            await loadPoderiForComunicazioni();
                            await loadTerreniForComunicazioni();
                            await loadLavoriAttiviForComunicazioni();
                            await loadComunicazioniInviate();
                            
                            // Pre-compila con il primo lavoro attivo se disponibile
                            await precompilaDaPrimoLavoro();
                        }
                    } else {
                        document.getElementById('comunicazioni-section').style.display = 'none';
                    }
                    
                    // Account e Password sempre visibili per tutti
                    document.getElementById('account-section').style.display = 'block';
                    document.getElementById('password-section').style.display = 'block';
                }
            } catch (error) {
                console.error('Errore caricamento dati:', error);
                showAlert('Errore caricamento dati', 'error');
            }
        });

        // Gestisce upload logo
        window.handleLogoUpload = async function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Verifica se l'app √® aperta con file:// (problema CORS)
            if (window.location.protocol === 'file:') {
                showAlert('‚ö†Ô∏è L\'app √® aperta con file://. Per caricare il logo, apri l\'app da un server HTTP (es. GitHub Pages o server locale).', 'error');
                event.target.value = '';
                return;
            }
            
            // Validazione file
            const maxSize = 2 * 1024 * 1024; // 2MB
            if (file.size > maxSize) {
                showAlert('Il file √® troppo grande. Dimensione massima: 2MB', 'error');
                event.target.value = '';
                return;
            }
            
            const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml'];
            if (!validTypes.includes(file.type)) {
                showAlert('Formato file non supportato. Usa PNG, JPG o SVG', 'error');
                event.target.value = '';
                return;
            }
            
            // Mostra preview
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('logo-preview-img').src = e.target.result;
                document.getElementById('logo-preview').style.display = 'block';
                document.getElementById('logo-current').style.display = 'none';
            };
            reader.readAsDataURL(file);
            
            // Salva file per upload successivo
            logoFileToUpload = file;
        };
        
        // Rimuove logo
        window.rimuoviLogo = async function() {
            if (!currentTenantId) return;
            
            try {
                // Verifica autenticazione
                const user = auth.currentUser;
                if (!user) {
                    showAlert('Utente non autenticato. Effettua il login.', 'error');
                    return;
                }
                
                const tenantRef = doc(db, 'tenants', currentTenantId);
                const tenantSnap = await getDoc(tenantRef);
                
                if (tenantSnap.exists()) {
                    const tenantData = tenantSnap.data();
                    
                    // Elimina logo da Storage se presente
                    if (tenantData.logoUrl) {
                        try {
                            // Estrai percorso dal URL completo
                            const urlParts = tenantData.logoUrl.split('/o/');
                            if (urlParts.length > 1) {
                                const pathPart = urlParts[1].split('?')[0];
                                const decodedPath = decodeURIComponent(pathPart);
                                const logoRef = ref(storage, decodedPath);
                                await deleteObject(logoRef);

                            }
                        } catch (storageError) {
                            console.warn('‚ö†Ô∏è Errore eliminazione logo da Storage (non critico):', storageError);
                            // Continua comunque
                        }
                    }
                    
                    // Rimuovi URL logo dal tenant
                    await updateDoc(tenantRef, {
                        logoUrl: null,
                        aggiornatoIl: serverTimestamp()
                    });
                    
                    // Aggiorna UI
                    document.getElementById('logo-preview').style.display = 'none';
                    document.getElementById('logo-current').style.display = 'none';
                    document.getElementById('azienda-logo').value = '';
                    logoFileToUpload = null;
                    
                    showAlert('Logo rimosso con successo', 'success');
                }
            } catch (error) {
                console.error('Errore rimozione logo:', error);
                showAlert('Errore durante la rimozione del logo: ' + error.message, 'error');
            }
        };

        // Salva impostazioni azienda
        async function handleSaveAzienda(e) {
            e.preventDefault();
            
            if (!currentUserData || !currentUserData.tenantId) {
                showAlert('Tenant non trovato', 'error');
                return;
            }

            try {
                const tenantRef = doc(db, 'tenants', currentUserData.tenantId);
                const tenantSnap = await getDoc(tenantRef);
                
                let logoUrl = null;
                
                // Upload logo se presente
                if (logoFileToUpload) {
                    try {
                        // Verifica autenticazione
                        const user = auth.currentUser;
                        if (!user) {
                            throw new Error('Utente non autenticato. Effettua il login.');
                        }
                        
                        // Normalizza tenantId per percorso Storage (rimuovi spazi e caratteri speciali)
                        const normalizedTenantId = currentUserData.tenantId
                            .replace(/[^a-zA-Z0-9_-]/g, '_')
                            .replace(/_+/g, '_')
                            .replace(/^_|_$/g, '');
                        
                        // Estrai estensione file
                        const fileExtension = logoFileToUpload.name.split('.').pop().toLowerCase();
                        const logoFileName = `tenants/${normalizedTenantId}/logo_${Date.now()}.${fileExtension}`;

                        const logoStorageRef = ref(storage, logoFileName);
                        
                        // Elimina logo vecchio se presente
                        if (tenantSnap.exists()) {
                            const oldTenantData = tenantSnap.data();
                            if (oldTenantData.logoUrl) {
                                try {
                                    // Estrai percorso dal URL completo
                                    const urlParts = oldTenantData.logoUrl.split('/o/');
                                    if (urlParts.length > 1) {
                                        const pathPart = urlParts[1].split('?')[0];
                                        const decodedPath = decodeURIComponent(pathPart);
                                        const oldLogoRef = ref(storage, decodedPath);
                                        await deleteObject(oldLogoRef);

                                    }
                                } catch (deleteError) {
                                    console.warn('‚ö†Ô∏è Errore eliminazione logo vecchio (non critico):', deleteError);
                                    // Continua comunque
                                }
                            }
                        }
                        
                        // Upload nuovo logo con metadata
                        const metadata = {
                            contentType: logoFileToUpload.type,
                            customMetadata: {
                                uploadedBy: user.uid,
                                tenantId: normalizedTenantId,
                                uploadedAt: new Date().toISOString()
                            }
                        };
                        
                        await uploadBytes(logoStorageRef, logoFileToUpload, metadata);
                        logoUrl = await getDownloadURL(logoStorageRef);

                    } catch (uploadError) {
                        console.error('‚ùå Errore upload logo:', uploadError);
                        
                        let errorMessage = 'Errore durante il caricamento del logo';
                        const errorCode = uploadError.code || '';
                        const errorMsg = uploadError.message || '';
                        
                        if (window.location.protocol === 'file:') {
                            errorMessage = '‚ö†Ô∏è ERRORE CORS: L\'app √® aperta con file://. Per caricare il logo:\n\n' +
                                         '1. Apri l\'app da GitHub Pages: https://vitaradragon.github.io/gfv-platform/\n' +
                                         '2. Oppure usa un server locale (es. Live Server in VS Code)\n\n' +
                                         'Firebase Storage richiede un\'origine HTTP valida.';
                        } else if (errorMsg.includes('CORS') || errorMsg.includes('origin') || errorMsg.includes('preflight')) {
                            errorMessage = '‚ö†Ô∏è ERRORE CORS: Configurazione CORS mancante sul bucket Storage.\n\n' +
                                         'SOLUZIONE:\n' +
                                         '1. Vai su Firebase Console ‚Üí Storage ‚Üí Settings\n' +
                                         '2. Copia il nome del bucket (es: gfv-platform.firebasestorage.app)\n' +
                                         '3. Segui le istruzioni in CONFIGURA_CORS_STORAGE.md\n' +
                                         '4. Oppure usa: gsutil cors set cors.json gs://[BUCKET_NAME]\n\n' +
                                         'Vedi il file CONFIGURA_CORS_STORAGE.md per istruzioni dettagliate.';
                        } else if (errorCode.includes('unauthorized') || errorMsg.includes('permission') || errorCode === 'storage/unauthorized') {
                            errorMessage = '‚ùå Errore permessi Storage. Verifica:\n\n' +
                                         '1. Le regole Storage sono deployate: firebase deploy --only storage\n' +
                                         '2. Sei autenticato correttamente\n' +
                                         '3. Il tuo tenantId √® corretto';
                        } else if (errorCode.includes('network') || errorCode === 'storage/network-request-failed' || errorMsg.includes('network')) {
                            errorMessage = 'üåê Errore di rete. Verifica:\n\n' +
                                         '1. La connessione internet\n' +
                                         '2. Che Firebase Storage sia abilitato nel progetto Firebase Console';
                        } else if (errorCode === 'storage/bucket-not-found' || errorMsg.includes('bucket')) {
                            errorMessage = '‚ùå Bucket Storage non trovato. Verifica:\n\n' +
                                         '1. Storage √® abilitato in Firebase Console ‚Üí Storage\n' +
                                         '2. Il nome bucket in firebase-config.js √® corretto';
                        } else {
                            errorMessage = `Errore: ${errorMsg || errorCode || 'Errore sconosciuto durante l\'upload'}\n\n` +
                                         `Codice: ${errorCode || 'N/A'}\n` +
                                         `Messaggio: ${errorMsg || 'N/A'}`;
                        }
                        
                        showAlert(errorMessage, 'error');
                        return;
                    }
                } else if (tenantSnap.exists()) {
                    // Mantieni logo esistente se non c'√® nuovo upload
                    const existingData = tenantSnap.data();
                    logoUrl = existingData.logoUrl || null;
                }
                
                const tenantData = {
                    nome: document.getElementById('azienda-nome').value,
                    piva: document.getElementById('azienda-piva').value,
                    cf: document.getElementById('azienda-cf').value,
                    indirizzo: document.getElementById('azienda-indirizzo').value,
                    citta: document.getElementById('azienda-citta').value,
                    cap: document.getElementById('azienda-cap').value,
                    provincia: document.getElementById('azienda-provincia').value,
                    telefono: document.getElementById('azienda-telefono').value,
                    email: document.getElementById('azienda-email').value,
                    note: document.getElementById('azienda-note').value,
                    aggiornatoIl: serverTimestamp()
                };
                
                // Aggiungi logoUrl se presente
                if (logoUrl !== null) {
                    tenantData.logoUrl = logoUrl;
                }

                // Se il documento esiste, aggiorna; altrimenti crea
                if (tenantSnap.exists()) {
                    await updateDoc(tenantRef, tenantData);
                } else {
                    // Crea nuovo documento tenant
                    tenantData.creatoIl = serverTimestamp();
                    await setDoc(tenantRef, tenantData);
                }
                
                // Aggiorna preview logo
                if (logoUrl) {
                    document.getElementById('logo-current-img').src = logoUrl;
                    document.getElementById('logo-current').style.display = 'block';
                    document.getElementById('logo-preview').style.display = 'none';
                }
                
                // Reset upload
                logoFileToUpload = null;
                document.getElementById('azienda-logo').value = '';
                
                showAlert('Impostazioni azienda salvate con successo', 'success');
            } catch (error) {
                console.error('Errore salvataggio azienda:', error);
                showAlert('Errore durante il salvataggio: ' + error.message, 'error');
            }
        }

        // Salva impostazioni account
        async function handleSaveAccount(e) {
            e.preventDefault();
            
            const user = auth.currentUser;
            if (!user) return;

            try {
                const accountData = {
                    nome: document.getElementById('account-nome').value,
                    cognome: document.getElementById('account-cognome').value,
                    telefono: document.getElementById('account-telefono').value
                };

                await updateDoc(doc(db, 'users', user.uid), accountData);
                showAlert('Impostazioni account salvate con successo', 'success');
            } catch (error) {
                console.error('Errore salvataggio account:', error);
                showAlert('Errore durante il salvataggio: ' + error.message, 'error');
            }
        }

        // Cambia password
        async function handleChangePassword(e) {
            e.preventDefault();
            
            const user = auth.currentUser;
            if (!user) return;

            const currentPassword = document.getElementById('password-current').value;
            const newPassword = document.getElementById('password-new').value;
            const confirmPassword = document.getElementById('password-confirm').value;

            if (newPassword !== confirmPassword) {
                showAlert('Le password non corrispondono', 'error');
                return;
            }

            if (newPassword.length < 6) {
                showAlert('La password deve essere almeno 6 caratteri', 'error');
                return;
            }

            try {
                // Ri-autentica utente
                const credential = EmailAuthProvider.credential(user.email, currentPassword);
                await reauthenticateWithCredential(user, credential);

                // Aggiorna password
                await updatePassword(user, newPassword);
                
                showAlert('Password cambiata con successo', 'success');
                document.getElementById('password-form').reset();
            } catch (error) {
                console.error('Errore cambio password:', error);
                let errorMsg = 'Errore durante il cambio password';
                if (error.code === 'auth/wrong-password') {
                    errorMsg = 'Password attuale errata';
                } else if (error.code === 'auth/weak-password') {
                    errorMsg = 'La nuova password √® troppo debole';
                }
                showAlert(errorMsg, 'error');
            }
        }

        // Utility: mostra alert
        function showAlert(message, type = 'success') {
            const container = document.getElementById('alert-container');
            const alertClass = type === 'success' ? 'alert-success' : 'alert-info';
            container.innerHTML = `<div class="alert ${alertClass}">${message}</div>`;
            
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }

        // ========== Liste Personalizzate ==========
        
        // Carica liste personalizzate
        async function loadListe() {
            if (!currentTenantId) return;
            
            try {
                // Carica tipi lavoro da tipiLavoro (fonte unica di verit√†)
                // IMPORTANTE: Carica i documenti completi per avere il campo predefinito
                let tipiLavoroDocs = [];
                try {
                    const tipiRef = collection(db, `tenants/${currentTenantId}/tipiLavoro`);
                    const snapshot = await getDocs(query(tipiRef, orderBy('nome', 'asc')));
                    tipiLavoroDocs = [];
                    snapshot.forEach(doc => {
                        tipiLavoroDocs.push({ id: doc.id, nome: doc.data().nome, predefinito: doc.data().predefinito || false });
                    });
                    
                    // Se tipiLavoro √® vuoto, prova migrazione automatica
                    if (tipiLavoroDocs.length === 0) {

                        await migraTipiLavoroAutomatica();
                        // Ricarica dopo migrazione
                        const snapshot2 = await getDocs(query(tipiRef, orderBy('nome', 'asc')));
                        snapshot2.forEach(doc => {
                            tipiLavoroDocs.push({ id: doc.id, nome: doc.data().nome, predefinito: doc.data().predefinito || false });
                        });
                    }
                    
                    // Pulisci duplicati dalla collection (mantieni solo il primo per ogni nome)
                    await pulisciDuplicatiTipiLavoro();
                } catch (error) {
                    console.warn('Impossibile caricare da tipiLavoro, uso ListePersonalizzate:', error.message);
                    // Fallback: usa ListePersonalizzate (solo nomi, assumiamo non predefiniti)
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    const nomiTipiLavoro = listeSnap.exists() 
                        ? (listeSnap.data().tipiLavoro || [])
                        : [...TIPI_LAVORO_PREDEFINITI];
                    
                    // Converti nomi in documenti (assumiamo predefiniti solo se nella lista predefinita)
                    tipiLavoroDocs = nomiTipiLavoro.map(nome => ({
                        id: null,
                        nome: nome,
                        predefinito: TIPI_LAVORO_PREDEFINITI.some(p => p.toLowerCase() === nome.toLowerCase())
                    }));
                }
                
                // Rimuovi duplicati dall'array (case-insensitive, mantieni il primo)
                const tipiLavoroUnici = [];
                const tipiLavoroVisti = new Set();
                tipiLavoroDocs.forEach(tipo => {
                    const tipoLower = tipo.nome.toLowerCase();
                    if (!tipiLavoroVisti.has(tipoLower)) {
                        tipiLavoroVisti.add(tipoLower);
                        tipiLavoroUnici.push(tipo);
                    }
                });
                tipiLavoroDocs = tipiLavoroUnici;
                
                // Carica categorie per colture e colture organizzate per categoria
                await loadCategorieColture();
                await loadColturePerCategoria();
                
                // Carica categorie e sottocategorie per tipi lavoro
                await loadCategorieTipiLavoro();
                await loadTipiLavoroPerCategoria();
                
                renderTipiLavoro(tipiLavoroDocs);
            } catch (error) {
                console.error('Errore caricamento liste:', error);
                showAlert('Errore caricamento liste personalizzate', 'error');
            }
        }

        // Pulisci duplicati dalla collection tipiLavoro
        async function pulisciDuplicatiTipiLavoro() {
            try {
                if (!currentTenantId) return;
                
                const tipiRef = collection(db, `tenants/${currentTenantId}/tipiLavoro`);
                const snapshot = await getDocs(tipiRef);
                
                // Raggruppa per nome (case-insensitive)
                const tipiPerNome = new Map();
                snapshot.forEach(doc => {
                    const nome = doc.data().nome;
                    const nomeLower = nome.toLowerCase();
                    
                    if (!tipiPerNome.has(nomeLower)) {
                        tipiPerNome.set(nomeLower, []);
                    }
                    tipiPerNome.get(nomeLower).push({ id: doc.id, data: doc.data() });
                });
                
                // Elimina duplicati (mantieni solo il primo di ogni gruppo)
                let duplicatiEliminati = 0;
                const deletePromises = [];
                
                tipiPerNome.forEach((docs, nomeLower) => {
                    if (docs.length > 1) {
                        // Ordina per createdAt (il pi√π vecchio viene mantenuto) o per id
                        docs.sort((a, b) => {
                            const createdAtA = a.data.createdAt?.toMillis() || 0;
                            const createdAtB = b.data.createdAt?.toMillis() || 0;
                            if (createdAtA !== createdAtB) {
                                return createdAtA - createdAtB;
                            }
                            return a.id.localeCompare(b.id);
                        });
                        
                        // Mantieni il primo, elimina gli altri
                        for (let i = 1; i < docs.length; i++) {
                            // Non eliminare se √® predefinito (mantieni sempre i predefiniti)
                            if (!docs[i].data.predefinito) {
                                deletePromises.push(deleteDoc(doc(db, `tenants/${currentTenantId}/tipiLavoro`, docs[i].id)));
                                duplicatiEliminati++;
                            } else if (!docs[0].data.predefinito) {
                                // Se il primo non √® predefinito ma questo s√¨, mantieni questo e elimina il primo
                                deletePromises.push(deleteDoc(doc(db, `tenants/${currentTenantId}/tipiLavoro`, docs[0].id)));
                                duplicatiEliminati++;
                                // Rimuovi il primo dalla lista e mantieni questo
                                docs.shift();
                            }
                        }
                    }
                });
                
                if (deletePromises.length > 0) {
                    await Promise.all(deletePromises);

                }
            } catch (error) {
                console.error('Errore pulizia duplicati tipi lavoro:', error);
            }
        }
        
        // Migrazione automatica tipi lavoro da ListePersonalizzate a tipiLavoro
        async function migraTipiLavoroAutomatica() {
            try {
                if (!currentTenantId) return;
                
                // Verifica se ci sono gi√† tipi in tipiLavoro
                const tipiRef = collection(db, `tenants/${currentTenantId}/tipiLavoro`);
                const snapshot = await getDocs(tipiRef);
                if (!snapshot.empty) {
                    return; // Gi√† migrato
                }
                
                // Leggi da ListePersonalizzate
                const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                const listeSnap = await getDoc(listeRef);
                
                if (!listeSnap.exists()) {
                    return; // Nessuna lista da migrare
                }
                
                const data = listeSnap.data();
                const tipiLavoroDaMigrare = data.tipiLavoro || [];
                
                if (tipiLavoroDaMigrare.length === 0) {
                    return; // Nessun tipo da migrare
                }
                
                // Carica categorie per mappatura
                const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                const categorieSnapshot = await getDocs(categorieRef);
                const categorieMap = new Map();
                categorieSnapshot.forEach(doc => {
                    const cat = doc.data();
                    if (cat.codice) {
                        categorieMap.set(cat.codice, doc.id);
                    }
                });
                
                // Mappatura tipi predefiniti alle categorie
                const mappaturaPredefiniti = {
                    'Potatura': 'potatura',
                    'Raccolta': 'raccolta',
                    'Raccolta frutta': 'raccolta',
                    'Raccolta verdura': 'raccolta',
                    'Trattamento': 'trattamenti',
                    'Semina': 'semina_piantagione',
                    'Aratura': 'lavorazione_terreno',
                    'Irrigazione': 'trattamenti',
                    'Concimazione': 'trattamenti',
                    'Diserbo': 'gestione_verde'
                };
                
                // Crea tipi lavoro
                for (const nomeTipo of tipiLavoroDaMigrare) {
                    // Verifica se esiste gi√†
                    const tipiEsistenti = await getDocs(query(tipiRef, where('nome', '==', nomeTipo)));
                    if (!tipiEsistenti.empty) {
                        continue; // Gi√† esiste
                    }
                    
                    // Determina categoria
                    const codiceCategoria = mappaturaPredefiniti[nomeTipo] || 'altro';
                    const categoriaId = categorieMap.get(codiceCategoria) || categorieMap.get('altro');
                    
                    if (!categoriaId) {
                        console.warn(`Categoria non trovata per tipo ${nomeTipo}, salto`);
                        continue;
                    }
                    
                    // Crea tipo lavoro
                    await addDoc(tipiRef, {
                        nome: nomeTipo,
                        categoriaId: categoriaId,
                        descrizione: 'Migrato da ListePersonalizzate',
                        predefinito: TIPI_LAVORO_PREDEFINITI.some(p => p.toLowerCase() === nomeTipo.toLowerCase()),
                        creatoDa: currentUser?.uid || 'system',
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    });
                }

            } catch (error) {
                console.error('Errore migrazione automatica tipi lavoro:', error);
                // Non bloccare se migrazione fallisce
            }
        }

        // Inizializza colture predefinite se non presenti (fallback per ambiente file://)
        async function initializeColturePredefiniteImpostazioni() {
            try {
                if (!currentTenantId) return;

                // Carica categorie per ottenere gli ID
                const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                const categorieSnapshot = await getDocs(categorieRef);
                const categorieMap = new Map(); // codice -> id
                categorieSnapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.applicabileA === 'colture' && data.codice) {
                        categorieMap.set(data.codice.toLowerCase(), doc.id);
                    }
                });

                // Carica colture esistenti
                const coltureRef = collection(db, `tenants/${currentTenantId}/colture`);
                const coltureSnapshot = await getDocs(coltureRef);
                const nomiEsistenti = new Set();
                coltureSnapshot.forEach(doc => {
                    const nome = doc.data().nome;
                    if (nome) nomiEsistenti.add(nome.toLowerCase());
                });

                // Colture predefinite
                const COLTURE_PREDEFINITE = [
                    // Frutteto
                    { nome: 'Pesco', categoriaCodice: 'frutteto' }, { nome: 'Melo', categoriaCodice: 'frutteto' },
                    { nome: 'Pero', categoriaCodice: 'frutteto' }, { nome: 'Albicocche', categoriaCodice: 'frutteto' },
                    { nome: 'Prugne', categoriaCodice: 'frutteto' }, { nome: 'Ciliegio', categoriaCodice: 'frutteto' },
                    { nome: 'Susino', categoriaCodice: 'frutteto' }, { nome: 'Fico', categoriaCodice: 'frutteto' },
                    { nome: 'Nocciolo', categoriaCodice: 'frutteto' }, { nome: 'Mandorlo', categoriaCodice: 'frutteto' },
                    { nome: 'Castagno', categoriaCodice: 'frutteto' }, { nome: 'Cotogno', categoriaCodice: 'frutteto' },
                    { nome: 'Sorbo', categoriaCodice: 'frutteto' }, { nome: 'Nespolo', categoriaCodice: 'frutteto' },
                    { nome: 'Giuggiolo', categoriaCodice: 'frutteto' }, { nome: 'Corbezzolo', categoriaCodice: 'frutteto' },
                    { nome: 'Gelso', categoriaCodice: 'frutteto' }, { nome: 'Mora', categoriaCodice: 'frutteto' },
                    { nome: 'Lampone', categoriaCodice: 'frutteto' }, { nome: 'Mirtillo', categoriaCodice: 'frutteto' },
                    { nome: 'Ribes', categoriaCodice: 'frutteto' }, { nome: 'Uva Spina', categoriaCodice: 'frutteto' },
                    { nome: 'Kiwi', categoriaCodice: 'frutteto' }, { nome: 'Melograno', categoriaCodice: 'frutteto' },
                    { nome: 'Fico d\'India', categoriaCodice: 'frutteto' }, { nome: 'Kaki', categoriaCodice: 'frutteto' },
                    { nome: 'Noce', categoriaCodice: 'frutteto' }, { nome: 'Pistacchio', categoriaCodice: 'frutteto' },
                    // Seminativo
                    { nome: 'Grano', categoriaCodice: 'seminativo' }, { nome: 'Mais', categoriaCodice: 'seminativo' },
                    { nome: 'Orzo', categoriaCodice: 'seminativo' }, { nome: 'Favino', categoriaCodice: 'seminativo' },
                    { nome: 'Girasole', categoriaCodice: 'seminativo' }, { nome: 'Soia', categoriaCodice: 'seminativo' },
                    { nome: 'Colza', categoriaCodice: 'seminativo' }, { nome: 'Avena', categoriaCodice: 'seminativo' },
                    { nome: 'Segale', categoriaCodice: 'seminativo' }, { nome: 'Fava', categoriaCodice: 'seminativo' },
                    { nome: 'Lenticchia', categoriaCodice: 'seminativo' }, { nome: 'Cece', categoriaCodice: 'seminativo' },
                    { nome: 'Lupino', categoriaCodice: 'seminativo' }, { nome: 'Cicerchia', categoriaCodice: 'seminativo' },
                    { nome: 'Riso', categoriaCodice: 'seminativo' }, { nome: 'Grano Saraceno', categoriaCodice: 'seminativo' },
                    { nome: 'Amaranto', categoriaCodice: 'seminativo' }, { nome: 'Quinoa', categoriaCodice: 'seminativo' },
                    { nome: 'Canapa', categoriaCodice: 'seminativo' }, { nome: 'Lino', categoriaCodice: 'seminativo' },
                    { nome: 'Carthamo', categoriaCodice: 'seminativo' }, { nome: 'Erba Medica', categoriaCodice: 'seminativo' },
                    { nome: 'Trifoglio', categoriaCodice: 'seminativo' }, { nome: 'Veccia', categoriaCodice: 'seminativo' },
                    { nome: 'Lupinella', categoriaCodice: 'seminativo' }, { nome: 'Sulla', categoriaCodice: 'seminativo' },
                    { nome: 'Sorgo', categoriaCodice: 'seminativo' }, { nome: 'Miglio', categoriaCodice: 'seminativo' },
                    { nome: 'Panico', categoriaCodice: 'seminativo' },
                    // Vite
                    { nome: 'Vite', categoriaCodice: 'vite' },
                    { nome: 'Vite da Tavola', categoriaCodice: 'vite' },
                    { nome: 'Vite da Vino', categoriaCodice: 'vite' },
                    // Ortive
                    { nome: 'Pomodoro', categoriaCodice: 'ortive' }, { nome: 'Zucchine', categoriaCodice: 'ortive' },
                    { nome: 'Melanzane', categoriaCodice: 'ortive' }, { nome: 'Peperoni', categoriaCodice: 'ortive' },
                    { nome: 'Insalata', categoriaCodice: 'ortive' }, { nome: 'Carote', categoriaCodice: 'ortive' },
                    { nome: 'Patate', categoriaCodice: 'ortive' }, { nome: 'Bietole', categoriaCodice: 'ortive' },
                    { nome: 'Fragole', categoriaCodice: 'ortive' }, { nome: 'Cipolle', categoriaCodice: 'ortive' },
                    { nome: 'Aglio', categoriaCodice: 'ortive' }, { nome: 'Fagioli', categoriaCodice: 'ortive' },
                    { nome: 'Fagiolini', categoriaCodice: 'ortive' }, { nome: 'Piselli', categoriaCodice: 'ortive' },
                    { nome: 'Cavolo', categoriaCodice: 'ortive' }, { nome: 'Broccoli', categoriaCodice: 'ortive' },
                    { nome: 'Cavolfiore', categoriaCodice: 'ortive' }, { nome: 'Spinaci', categoriaCodice: 'ortive' },
                    { nome: 'Lattuga', categoriaCodice: 'ortive' }, { nome: 'Radicchio', categoriaCodice: 'ortive' },
                    { nome: 'Finocchi', categoriaCodice: 'ortive' }, { nome: 'Sedano', categoriaCodice: 'ortive' },
                    { nome: 'Cetrioli', categoriaCodice: 'ortive' }, { nome: 'Angurie', categoriaCodice: 'ortive' },
                    { nome: 'Meloni', categoriaCodice: 'ortive' },
                    // Prato
                    { nome: 'Prato', categoriaCodice: 'prato' }, { nome: 'Prato Stabile', categoriaCodice: 'prato' },
                    { nome: 'Pascolo', categoriaCodice: 'prato' },
                    // Olivo
                    { nome: 'Olivo', categoriaCodice: 'olivo' },
                    // Agrumeto
                    { nome: 'Arancio', categoriaCodice: 'agrumeto' }, { nome: 'Limone', categoriaCodice: 'agrumeto' },
                    { nome: 'Mandarino', categoriaCodice: 'agrumeto' }, { nome: 'Clementine', categoriaCodice: 'agrumeto' },
                    { nome: 'Pompelmo', categoriaCodice: 'agrumeto' }, { nome: 'Bergamotto', categoriaCodice: 'agrumeto' },
                    { nome: 'Cedro', categoriaCodice: 'agrumeto' }, { nome: 'Lime', categoriaCodice: 'agrumeto' },
                    { nome: 'Kumquat', categoriaCodice: 'agrumeto' },
                    // Bosco
                    { nome: 'Bosco', categoriaCodice: 'bosco' }
                ];

                // Crea colture predefinite mancanti
                let createCount = 0;
                for (const colturaData of COLTURE_PREDEFINITE) {
                    if (!nomiEsistenti.has(colturaData.nome.toLowerCase())) {
                        const categoriaId = categorieMap.get(colturaData.categoriaCodice);
                        if (categoriaId) {
                            await addDoc(coltureRef, {
                                nome: colturaData.nome,
                                categoriaId: categoriaId,
                                descrizione: null,
                                predefinito: true,
                                creatoDa: 'system',
                                createdAt: serverTimestamp(),
                                updatedAt: serverTimestamp()
                            });
                            nomiEsistenti.add(colturaData.nome.toLowerCase());
                            createCount++;
                        }
                    }
                }

                if (createCount > 0) {

                }
            } catch (error) {
                console.error('Errore inizializzazione colture predefinite:', error);
            }
        }

        // Migrazione automatica colture da ListePersonalizzate a colture
        async function migraColtureAutomatica() {
            // Prevenire chiamate multiple simultanee o tentativi multipli
            if (isMigratingColture || migrazioneTentata) {

                return;
            }
            
            try {
                if (!currentTenantId) return;
                
                isMigratingColture = true;
                migrazioneTentata = true; // Marca come tentata per evitare loop
                
                // Verifica se ci sono gi√† colture in collection colture
                const coltureRef = collection(db, `tenants/${currentTenantId}/colture`);
                const snapshot = await getDocs(coltureRef);
                if (!snapshot.empty) {

                    isMigratingColture = false;
                    return; // Gi√† migrato
                }
                
                // IMPORTANTE: Inizializza categorie PRIMA di migrare colture

                try {
                    // Categorie predefinite per colture
                    const categorieColturePredefinite = [
                        { nome: 'Frutteto', codice: 'frutteto', descrizione: 'Alberi da frutto', applicabileA: 'colture', predefinita: true, ordine: 1 },
                        { nome: 'Seminativo', codice: 'seminativo', descrizione: 'Colture erbacee da granella', applicabileA: 'colture', predefinita: true, ordine: 2 },
                        { nome: 'Vite', codice: 'vite', descrizione: 'Vigneto', applicabileA: 'colture', predefinita: true, ordine: 3 },
                        { nome: 'Ortive', codice: 'ortive', descrizione: 'Colture orticole', applicabileA: 'colture', predefinita: true, ordine: 4 },
                        { nome: 'Prato', codice: 'prato', descrizione: 'Prati e pascoli', applicabileA: 'colture', predefinita: true, ordine: 5 },
                        { nome: 'Olivo', codice: 'olivo', descrizione: 'Oliveto', applicabileA: 'colture', predefinita: true, ordine: 6 },
                        { nome: 'Agrumeto', codice: 'agrumeto', descrizione: 'Agrumi', applicabileA: 'colture', predefinita: true, ordine: 7 },
                        { nome: 'Bosco', codice: 'bosco', descrizione: 'Bosco e foresta', applicabileA: 'colture', predefinita: true, ordine: 8 },
                        { nome: 'Altro', codice: 'altro_colture', descrizione: 'Altre colture non categorizzabili', applicabileA: 'colture', predefinita: true, ordine: 9 }
                    ];
                    
                    // Verifica categorie esistenti
                    const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                    const categorieSnapshot = await getDocs(categorieRef);
                    const codiciEsistenti = new Set();
                    categorieSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.codice) {
                            codiciEsistenti.add(data.codice.toLowerCase());
                        }
                    });
                    
                    // Crea categorie mancanti
                    let categorieCreate = 0;
                    for (const categoriaData of categorieColturePredefinite) {
                        if (!codiciEsistenti.has(categoriaData.codice.toLowerCase())) {
                            await addDoc(categorieRef, {
                                ...categoriaData,
                                codice: categoriaData.codice.toLowerCase(),
                                creatoDa: 'system',
                                createdAt: serverTimestamp(),
                                updatedAt: serverTimestamp()
                            });
                            categorieCreate++;
                            codiciEsistenti.add(categoriaData.codice.toLowerCase());
                        }
                    }

                    // Attendi un momento per assicurarsi che le categorie siano disponibili
                    await new Promise(resolve => setTimeout(resolve, 300));
                } catch (error) {
                    console.error('Errore inizializzazione categorie:', error);
                    isMigratingColture = false;
                    return; // Non continuare se le categorie non possono essere inizializzate
                }
                
                // Leggi da ListePersonalizzate
                const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                const listeSnap = await getDoc(listeRef);
                
                if (!listeSnap.exists()) {

                    isMigratingColture = false;
                    return; // Nessuna lista da migrare
                }
                
                const data = listeSnap.data();
                const coltureDaMigrare = data.colture || [];
                
                if (coltureDaMigrare.length === 0) {

                    isMigratingColture = false;
                    return; // Nessuna coltura da migrare
                }
                
                const currentUser = auth.currentUser;
                
                // Mappatura colture predefinite
                const colturePredefiniteMap = {
                    'Vite': { nome: 'Vite', descrizione: 'Vigneto' },
                    'Frutteto': { nome: 'Frutteto', descrizione: 'Alberi da frutto' },
                    'Seminativo': { nome: 'Seminativo', descrizione: 'Colture erbacee' },
                    'Orto': { nome: 'Orto', descrizione: 'Orticoltura' },
                    'Prato': { nome: 'Prato', descrizione: 'Prati e pascoli' },
                    'Olivo': { nome: 'Olivo', descrizione: 'Oliveto' },
                    'Agrumeto': { nome: 'Agrumeto', descrizione: 'Agrumi' },
                    'Bosco': { nome: 'Bosco', descrizione: 'Bosco e foresta' }
                };
                
                // Carica categorie (ora dovrebbero esistere dopo l'inizializzazione)
                const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                // Carica tutte le categorie e filtra client-side per evitare indice complesso
                const categorieSnapshot = await getDocs(categorieRef);
                
                const categorieMap = new Map();
                categorieSnapshot.forEach(doc => {
                    const data = doc.data();
                    // IMPORTANTE: Solo categorie specifiche per colture, NON quelle per tipi lavoro
                    if (data.applicabileA === 'colture') {
                        categorieMap.set(data.codice.toLowerCase(), doc.id); // Usa lowercase per matching
                    }
                });
                
                // Se non ci sono categorie, non possiamo migrare
                if (categorieMap.size === 0) {
                    console.error('‚ùå Nessuna categoria trovata dopo inizializzazione, impossibile migrare colture');
                    isMigratingColture = false;
                    return;
                }

                // Mappatura nomi colture piatti a categorie
                const mappaturaColture = {
                    'vite': 'vite',
                    'frutteto': 'frutteto',
                    'seminativo': 'seminativo',
                    'orto': 'ortive',
                    'prato': 'prato',
                    'olivo': 'olivo',
                    'agrumeto': 'agrumeto',
                    'bosco': 'bosco'
                };
                
                let coltureCreate = 0;
                let coltureSkipped = 0;
                
                // Migra ogni coltura
                for (const nomeColtura of coltureDaMigrare) {
                    // Verifica se esiste gi√†
                    const q = query(coltureRef, where('nome', '==', nomeColtura));
                    const existingSnapshot = await getDocs(q);
                    if (!existingSnapshot.empty) {
                        coltureSkipped++;
                        continue; // Gi√† esiste, salta
                    }
                    
                    // Determina categoria
                    let categoriaCodice = mappaturaColture[nomeColtura.toLowerCase()];
                    if (!categoriaCodice) {
                        categoriaCodice = 'altro_colture'; // Default
                    }
                    
                    const categoriaId = categorieMap.get(categoriaCodice.toLowerCase());
                    if (!categoriaId) {
                        console.warn(`‚ö†Ô∏è Categoria "${categoriaCodice}" non trovata per coltura "${nomeColtura}", salto`);
                        coltureSkipped++;
                        continue;
                    }
                    
                    // Determina se √® predefinita
                    const colturaPredefinita = colturePredefiniteMap[nomeColtura];
                    const isPredefinita = !!colturaPredefinita;
                    
                    // Crea coltura
                    await addDoc(coltureRef, {
                        nome: nomeColtura,
                        categoriaId: categoriaId,
                        descrizione: colturaPredefinita?.descrizione || null,
                        predefinito: isPredefinita,
                        creatoDa: currentUser?.uid || 'system',
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    });
                    coltureCreate++;
                }

                isMigratingColture = false;
            } catch (error) {
                console.error('‚ùå Errore migrazione automatica colture:', error);
                isMigratingColture = false;
                // Non bloccare se migrazione fallisce, ma marca come tentata per evitare loop
            }
        }
        
        // Variabili globali per tipi lavoro gerarchici
        let categorieTipiLavoroMap = {};
        let tipiLavoroPerCategoria = {};
        
        // Carica categorie per tipi lavoro
        async function loadCategorieTipiLavoro() {
            try {
                if (!currentTenantId) return;
                
                // Prima inizializza le categorie se necessario (inline per evitare CORS)
                try {
                    const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                    const categorieSnapshot = await getDocs(categorieRef);
                    const codiciEsistenti = new Set();
                    categorieSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.codice) {
                            codiciEsistenti.add(data.codice.toLowerCase());
                        }
                    });
                    
                    // Categorie principali predefinite per lavori
                    const categorieLavoriPredefinite = [
                        { nome: 'Lavorazione del Terreno', codice: 'lavorazione_terreno', descrizione: 'Aratura, erpicatura, fresatura, vangatura, ecc.', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Trattamenti', codice: 'trattamenti', descrizione: 'Fitofarmaci, concimazione, irrigazione, ecc.', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        { nome: 'Potatura', codice: 'potatura', descrizione: 'Potatura manuale e meccanica', applicabileA: 'entrambi', predefinita: true, ordine: 3 },
                        { nome: 'Raccolta', codice: 'raccolta', descrizione: 'Raccolta frutta, raccolta verdura, vendemmia, ecc.', applicabileA: 'entrambi', predefinita: true, ordine: 4 },
                        { nome: 'Gestione del Verde', codice: 'gestione_verde', descrizione: 'Falciatura, taglio erba, manutenzione estetica, ecc.', applicabileA: 'entrambi', predefinita: true, ordine: 5 },
                        { nome: 'Diserbo', codice: 'diserbo', descrizione: 'Eliminazione delle erbe infestanti', applicabileA: 'entrambi', predefinita: true, ordine: 6 },
                        { nome: 'Semina e Piantagione', codice: 'semina_piantagione', descrizione: 'Semina, trapianto, piantagione, ecc.', applicabileA: 'entrambi', predefinita: true, ordine: 7 },
                        { nome: 'Manutenzione', codice: 'manutenzione', descrizione: 'Riparazioni, manutenzione impianti, ecc.', applicabileA: 'lavori', predefinita: true, ordine: 9 },
                        { nome: 'Altro', codice: 'altro', descrizione: 'Altri tipi non categorizzabili', applicabileA: 'entrambi', predefinita: true, ordine: 10 }
                    ];
                    
                    // Crea categorie principali mancanti
                    const categorieMap = new Map(); // codice -> id
                    for (const categoriaData of categorieLavoriPredefinite) {
                        if (!codiciEsistenti.has(categoriaData.codice.toLowerCase())) {
                            const categoriaId = await addDoc(categorieRef, {
                                ...categoriaData,
                                codice: categoriaData.codice.toLowerCase(),
                                creatoDa: 'system',
                                createdAt: serverTimestamp(),
                                updatedAt: serverTimestamp()
                            });
                            categorieMap.set(categoriaData.codice.toLowerCase(), categoriaId);
                            codiciEsistenti.add(categoriaData.codice.toLowerCase());
                        } else {
                            // Trova ID esistente
                            const categoriaEsistente = Array.from(categorieSnapshot.docs).find(doc => {
                                const data = doc.data();
                                return data.codice && data.codice.toLowerCase() === categoriaData.codice.toLowerCase();
                            });
                            if (categoriaEsistente) {
                                categorieMap.set(categoriaData.codice.toLowerCase(), categoriaEsistente.id);
                            }
                        }
                    }
                    
                    // Sottocategorie predefinite
                    const sottocategoriePredefinite = [
                        // Lavorazione del Terreno
                        { nome: 'Generale', codice: 'lavorazione_terreno_generale', parentCodice: 'lavorazione_terreno', descrizione: 'Lavorazione standard per campi aperti', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Tra le File', codice: 'lavorazione_terreno_tra_file', parentCodice: 'lavorazione_terreno', descrizione: 'Lavorazione tra le file di frutteti/vigneti', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        { nome: 'Sulla Fila', codice: 'lavorazione_terreno_sulla_fila', parentCodice: 'lavorazione_terreno', descrizione: 'Lavorazione sulla fila di frutteti/vigneti', applicabileA: 'entrambi', predefinita: true, ordine: 3 },
                        // Trattamenti
                        { nome: 'Manuale', codice: 'trattamenti_manuale', parentCodice: 'trattamenti', descrizione: 'Trattamenti eseguiti manualmente', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Meccanico', codice: 'trattamenti_meccanico', parentCodice: 'trattamenti', descrizione: 'Trattamenti eseguiti con macchine', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        // Potatura
                        { nome: 'Manuale', codice: 'potatura_manuale', parentCodice: 'potatura', descrizione: 'Potatura eseguita manualmente', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Meccanico', codice: 'potatura_meccanico', parentCodice: 'potatura', descrizione: 'Potatura eseguita con attrezzi meccanici', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        // Raccolta
                        { nome: 'Raccolta Manuale', codice: 'raccolta_manuale', parentCodice: 'raccolta', descrizione: 'Raccolta eseguita manualmente', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Raccolta Meccanica', codice: 'raccolta_meccanica', parentCodice: 'raccolta', descrizione: 'Raccolta eseguita con macchine', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        // Gestione del Verde
                        { nome: 'Manuale', codice: 'gestione_verde_manuale', parentCodice: 'gestione_verde', descrizione: 'Gestione del verde eseguita manualmente', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Meccanico', codice: 'gestione_verde_meccanico', parentCodice: 'gestione_verde', descrizione: 'Gestione del verde eseguita con macchine', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        // Semina e Piantagione
                        { nome: 'Manuale', codice: 'semina_piantagione_manuale', parentCodice: 'semina_piantagione', descrizione: 'Semina e piantagione eseguite manualmente', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Meccanico', codice: 'semina_piantagione_meccanico', parentCodice: 'semina_piantagione', descrizione: 'Semina e piantagione eseguite con macchine', applicabileA: 'entrambi', predefinita: true, ordine: 2 },
                        // Diserbo
                        { nome: 'Manuale', codice: 'diserbo_manuale', parentCodice: 'diserbo', descrizione: 'Diserbo eseguito manualmente', applicabileA: 'entrambi', predefinita: true, ordine: 1 },
                        { nome: 'Meccanico', codice: 'diserbo_meccanico', parentCodice: 'diserbo', descrizione: 'Diserbo eseguito con macchine', applicabileA: 'entrambi', predefinita: true, ordine: 2 }
                    ];
                    
                    // Rimuovi vecchie sottocategorie obsolete (es. "Meccanica" invece di "Meccanico")
                    const codiciObsoleti = ['potatura_meccanica']; // Vecchi codici da rimuovere
                    for (const codiceObsoleto of codiciObsoleti) {
                        const sottocategoriaObsoleta = Array.from(categorieSnapshot.docs).find(doc => {
                            const data = doc.data();
                            return data.codice && data.codice.toLowerCase() === codiceObsoleto.toLowerCase();
                        });
                        if (sottocategoriaObsoleta) {
                            try {
                                await deleteDoc(doc(categorieRef, sottocategoriaObsoleta.id));

                            } catch (error) {
                                console.warn(`Impossibile rimuovere sottocategoria obsoleta ${codiceObsoleto}:`, error);
                            }
                        }
                    }
                    
                    // Crea sottocategorie mancanti
                    for (const sottocategoriaData of sottocategoriePredefinite) {
                        if (!codiciEsistenti.has(sottocategoriaData.codice.toLowerCase())) {
                            const parentId = categorieMap.get(sottocategoriaData.parentCodice.toLowerCase());
                            if (parentId) {
                                await addDoc(categorieRef, {
                                    nome: sottocategoriaData.nome,
                                    codice: sottocategoriaData.codice.toLowerCase(),
                                    descrizione: sottocategoriaData.descrizione,
                                    parentId: parentId,
                                    applicabileA: sottocategoriaData.applicabileA,
                                    predefinita: true,
                                    ordine: sottocategoriaData.ordine,
                                    creatoDa: 'system',
                                    createdAt: serverTimestamp(),
                                    updatedAt: serverTimestamp()
                                });
                                codiciEsistenti.add(sottocategoriaData.codice.toLowerCase());
                            }
                        }
                    }
                    
                    // Attendi un momento per assicurarsi che le categorie siano disponibili
                    await new Promise(resolve => setTimeout(resolve, 300));
                } catch (error) {
                    console.error('Errore inizializzazione categorie tipi lavoro:', error);
                }
                
                // Ora carica le categorie
                const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                const snapshot = await getDocs(categorieRef);
                
                categorieTipiLavoroMap = {};
                const categorieArray = [];
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    // Solo categorie per lavori (applicabileA === 'lavori' o 'entrambi')
                    if (data.applicabileA === 'lavori' || data.applicabileA === 'entrambi') {
                        if (!data.parentId) { // Solo categorie principali, non sottocategorie
                            categorieTipiLavoroMap[doc.id] = { id: doc.id, ...data };
                            categorieArray.push({ id: doc.id, ...data });
                        }
                    }
                });
                
                // Ordina per ordine o nome
                categorieArray.sort((a, b) => {
                    if (a.ordine !== undefined && b.ordine !== undefined) {
                        return a.ordine - b.ordine;
                    }
                    return (a.nome || '').localeCompare(b.nome || '');
                });
                
                // Popola dropdown categoria
                const select = document.getElementById('tipo-lavoro-categoria-select');
                if (select) {
                    select.innerHTML = '<option value="">-- Seleziona categoria --</option>';
                    categorieArray.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.id;
                        option.textContent = cat.nome || cat.codice || cat.id;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Errore caricamento categorie tipi lavoro:', error);
            }
        }
        
        // Carica tipi lavoro organizzati per categoria e sottocategoria
        async function loadTipiLavoroPerCategoria() {
            try {
                if (!currentTenantId) return;
                
                const tipiRef = collection(db, `tenants/${currentTenantId}/tipiLavoro`);
                const snapshot = await getDocs(tipiRef);
                
                tipiLavoroPerCategoria = {};
                const tipiArray = [];
                
                snapshot.forEach(doc => {
                    tipiArray.push({ id: doc.id, ...doc.data() });
                });
                
                // Ordina client-side per nome
                tipiArray.sort((a, b) => {
                    const nomeA = (a.nome || '').toLowerCase();
                    const nomeB = (b.nome || '').toLowerCase();
                    return nomeA.localeCompare(nomeB);
                });
                
                // Organizza per categoria e sottocategoria
                tipiArray.forEach(tipo => {
                    const categoriaId = tipo.categoriaId || 'senza_categoria';
                    const sottocategoriaId = tipo.sottocategoriaId || 'senza_sottocategoria';
                    
                    if (!tipiLavoroPerCategoria[categoriaId]) {
                        tipiLavoroPerCategoria[categoriaId] = {};
                    }
                    if (!tipiLavoroPerCategoria[categoriaId][sottocategoriaId]) {
                        tipiLavoroPerCategoria[categoriaId][sottocategoriaId] = [];
                    }
                    tipiLavoroPerCategoria[categoriaId][sottocategoriaId].push(tipo);
                });
            } catch (error) {
                console.error('Errore caricamento tipi lavoro per categoria:', error);
            }
        }
        
        // Aggiorna dropdown sottocategorie quando cambia la categoria
        async function updateSottocategorieDropdown() {
            const categoriaSelect = document.getElementById('tipo-lavoro-categoria-select');
            const sottocategoriaSelect = document.getElementById('tipo-lavoro-sottocategoria-select');
            const sottocategoriaGroup = document.getElementById('tipo-lavoro-sottocategoria-group');
            
            if (!categoriaSelect || !sottocategoriaSelect || !sottocategoriaGroup) return;
            
            const categoriaId = categoriaSelect.value;
            sottocategoriaSelect.innerHTML = '<option value="">-- Seleziona sottocategoria (opzionale) --</option>';
            
            if (!categoriaId) {
                sottocategoriaGroup.style.display = 'none';
                updateTipiLavoroPredefinitiDropdown();
                return;
            }
            
            sottocategoriaGroup.style.display = 'block';
            
            try {
                // Carica sottocategorie per questa categoria
                const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                const snapshot = await getDocs(categorieRef);
                
                const sottocategorie = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.parentId === categoriaId) {
                        sottocategorie.push({ id: doc.id, ...data });
                    }
                });
                
                // Ordina per ordine o nome
                sottocategorie.sort((a, b) => {
                    if (a.ordine !== undefined && b.ordine !== undefined) {
                        return a.ordine - b.ordine;
                    }
                    return (a.nome || '').localeCompare(b.nome || '');
                });
                
                sottocategorie.forEach(sub => {
                    const option = document.createElement('option');
                    option.value = sub.id;
                    option.textContent = sub.nome || sub.codice || sub.id;
                    sottocategoriaSelect.appendChild(option);
                });
                
                await updateTipiLavoroPredefinitiDropdown();
            } catch (error) {
                console.error('Errore caricamento sottocategorie:', error);
            }
        }
        
        // Aggiorna dropdown tipi lavoro predefiniti (ora usa servizio centralizzato)
        async function updateTipiLavoroPredefinitiDropdown() {
            const categoriaSelect = document.getElementById('tipo-lavoro-categoria-select');
            const sottocategoriaSelect = document.getElementById('tipo-lavoro-sottocategoria-select');
            const predeterminatoSelect = document.getElementById('new-tipo-lavoro-predeterminato');
            
            if (!categoriaSelect || !predeterminatoSelect) return;
            
            const categoriaId = categoriaSelect.value;
            const sottocategoriaId = sottocategoriaSelect ? sottocategoriaSelect.value : null;
            
            predeterminatoSelect.innerHTML = '<option value="">-- Seleziona un tipo lavoro (opzionale) --</option>';
            
            if (!categoriaId) return;
            
            if (!currentTenantId) return;
            
            try {
                // Assicura che Firebase sia inizializzato nel servizio
                try {
                    const { setFirebaseInstances } = await import('../services/firebase-service.js');
                    setFirebaseInstances({ app, db, auth });
                } catch (error) {
                    console.warn('Impossibile impostare Firebase instances nel servizio:', error);
                }
                
                // Assicura che il tenantId sia impostato nel servizio
                try {
                    const { setCurrentTenantId } = await import('../services/tenant-service.js');
                    if (currentTenantId) {
                        setCurrentTenantId(currentTenantId);
                    }
                } catch (error) {
                    console.warn('Impossibile impostare tenantId nel servizio:', error);
                }
                
                // Carica tutti i tipi lavoro usando il servizio centralizzato
                const { getAllTipiLavoro } = await import('../services/tipi-lavoro-service.js');
                const allTipiLavoro = await getAllTipiLavoro({
                    orderBy: 'nome',
                    orderDirection: 'asc'
                });
                
                // Carica sottocategorie per filtraggio corretto
                const sottocategorieMap = new Map();
                if (categoriaId) {
                    const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                    const snapshot = await getDocs(categorieRef);
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.parentId === categoriaId) {
                            sottocategorieMap.set(doc.id, { id: doc.id, ...data });
                        }
                    });
                }
                
                // Filtra tipi lavoro per categoria e sottocategoria
                let tipiFiltrati = allTipiLavoro.filter(tipo => {
                    // Se c'√® una sottocategoria selezionata, mostra SOLO i tipi di quella sottocategoria
                    if (sottocategoriaId) {
                        return tipo.sottocategoriaId === sottocategoriaId;
                    }
                    // Se non c'√® sottocategoria selezionata, mostra i tipi della categoria principale
                    // o delle sue sottocategorie
                    if (tipo.categoriaId === categoriaId) {
                        return true;
                    }
                    // Verifica se il tipo appartiene a una sottocategoria della categoria selezionata
                    if (tipo.sottocategoriaId && sottocategorieMap.has(tipo.sottocategoriaId)) {
                        return true;
                    }
                    return false;
                });
                
                // Ordina per nome
                tipiFiltrati.sort((a, b) => {
                    const nomeA = (a.nome || '').toLowerCase();
                    const nomeB = (b.nome || '').toLowerCase();
                    return nomeA.localeCompare(nomeB);
                });
                
                // Popola dropdown con i tipi filtrati
                tipiFiltrati.forEach(tipo => {
                    const option = document.createElement('option');
                    option.value = tipo.nome;
                    option.textContent = tipo.nome;
                    predeterminatoSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Errore caricamento tipi lavoro:', error);
                showAlert('Errore caricamento tipi lavoro', 'error');
            }
        }
        
        // Quando viene selezionato un tipo predefinito, popola il campo nome
        function onTipoLavoroPredeterminatoChange() {
            const predeterminatoSelect = document.getElementById('new-tipo-lavoro-predeterminato');
            const nomeInput = document.getElementById('new-tipo-lavoro');
            
            if (predeterminatoSelect && nomeInput && predeterminatoSelect.value) {
                nomeInput.value = predeterminatoSelect.value;
            }
        }
        
        // Render tipi lavoro (solo custom, organizzati per categoria/sottocategoria)
        function renderTipiLavoro(tipiLavoroDocs) {
            const container = document.getElementById('tipi-lavoro-list');
            
            // Filtra solo tipi custom (non predefiniti)
            const tipiCustom = tipiLavoroDocs.filter(tipo => {
                if (typeof tipo === 'string') return false; // Skip stringhe legacy
                return tipo.predefinito !== true;
            });
            
            if (tipiCustom.length === 0) {
                container.innerHTML = '<div class="empty-state">Nessun tipo lavoro personalizzato aggiunto. Usa i dropdown sopra per aggiungere tipi lavoro predefiniti o personalizzati.</div>';
                return;
            }
            
            // Organizza per categoria e sottocategoria
            const tipiPerCategoria = {};
            tipiCustom.forEach(tipo => {
                const categoriaId = tipo.categoriaId || 'senza_categoria';
                const sottocategoriaId = tipo.sottocategoriaId || 'senza_sottocategoria';
                
                if (!tipiPerCategoria[categoriaId]) {
                    tipiPerCategoria[categoriaId] = {};
                }
                if (!tipiPerCategoria[categoriaId][sottocategoriaId]) {
                    tipiPerCategoria[categoriaId][sottocategoriaId] = [];
                }
                tipiPerCategoria[categoriaId][sottocategoriaId].push(tipo);
            });
            
            let html = '';
            let hasTipiCustom = false;
            
            // Renderizza per categoria
            Object.keys(tipiPerCategoria).sort().forEach(categoriaId => {
                const categoria = categorieTipiLavoroMap[categoriaId];
                const sottocategorie = tipiPerCategoria[categoriaId];
                
                // Conta se ci sono tipi custom in questa categoria
                let hasTipiInCategoria = false;
                Object.values(sottocategorie).forEach(tipi => {
                    if (tipi.length > 0) hasTipiInCategoria = true;
                });
                
                if (!hasTipiInCategoria) return;
                
                hasTipiCustom = true;
                html += `<div style="margin-bottom: 25px;">`;
                html += `<h4 style="color: #666; font-size: 16px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #e9ecef;">${escapeHtml(categoria?.nome || 'Senza Categoria')}</h4>`;
                
                // Renderizza per sottocategoria
                Object.keys(sottocategorie).sort().forEach(sottocategoriaId => {
                    const tipi = sottocategorie[sottocategoriaId];
                    if (tipi.length === 0) return;
                    
                    // Carica nome sottocategoria se disponibile
                    let sottocategoriaNome = 'Senza Sottocategoria';
                    if (sottocategoriaId !== 'senza_sottocategoria') {
                        // Cerca nella mappa sottocategorie
                        const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                        getDocs(categorieRef).then(snapshot => {
                            snapshot.forEach(doc => {
                                if (doc.id === sottocategoriaId) {
                                    sottocategoriaNome = doc.data().nome || sottocategoriaNome;
                                }
                            });
                        }).catch(() => {});
                    }
                    
                    if (sottocategoriaId !== 'senza_sottocategoria') {
                        html += `<h5 style="color: #888; font-size: 14px; margin: 10px 0 5px 15px;">${escapeHtml(sottocategoriaNome)}</h5>`;
                    }
                    
                    tipi.forEach(tipo => {
                        html += `
                            <div class="list-item" style="margin-left: ${sottocategoriaId !== 'senza_sottocategoria' ? '30px' : '15px'};">
                                <div class="list-item-name">
                                    <span>${escapeHtml(tipo.nome)}</span>
                                    <span class="badge badge-custom">Custom</span>
                                </div>
                                <button class="btn btn-danger btn-small" onclick="removeTipoLavoro('${escapeHtml(tipo.nome)}', '${tipo.id || ''}')" title="Elimina">
                                    üóëÔ∏è Elimina
                                </button>
                            </div>
                        `;
                    });
                });
                
                html += `</div>`;
            });
            
            if (!hasTipiCustom) {
                container.innerHTML = '<div class="empty-state">Nessun tipo lavoro personalizzato aggiunto. Usa i dropdown sopra per aggiungere tipi lavoro predefiniti o personalizzati.</div>';
            } else {
                container.innerHTML = html;
            }
        }
        
        // Variabili globali per categorie e colture
        let categorieColture = [];
        let colturePerCategoria = {};
        let isMigratingColture = false; // Flag per prevenire loop infiniti
        let migrazioneTentata = false; // Flag per evitare tentativi multipli di migrazione

        // Carica categorie per colture usando categorie-service.js
        async function loadCategorieColture() {
            try {
                if (!currentTenantId) return;
                
                // Verifica se siamo in ambiente file:// (non supportato per moduli ES6)
                const isFileProtocol = window.location.protocol === 'file:';
                
                if (isFileProtocol) {
                    // Fallback: carica direttamente da Firestore
                    const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                    const categorieSnapshot = await getDocs(categorieRef);
                    
                    categorieColture = [];
                    categorieSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.applicabileA === 'colture') {
                            categorieColture.push({ id: doc.id, ...data });
                        }
                    });
                    
                    categorieColture.sort((a, b) => {
                        const ordineA = a.ordine || 999;
                        const ordineB = b.ordine || 999;
                        return ordineA - ordineB;
                    });
                } else {
                    // Usa categorie-service.js invece di caricamento diretto
                    // Assicura che Firebase sia inizializzato nel servizio
                    const { setFirebaseInstances } = await import('../services/firebase-service.js');
                    setFirebaseInstances({ app, db, auth });
                    
                    // Assicura che il tenantId sia impostato nel servizio
                    const { setCurrentTenantId } = await import('../services/tenant-service.js');
                    if (currentTenantId) {
                        setCurrentTenantId(currentTenantId);
                    }
                    
                    const { getAllCategorie } = await import('../services/categorie-service.js');
                    const categorie = await getAllCategorie({
                        applicabileA: 'colture',
                        orderBy: 'ordine',
                        orderDirection: 'asc'
                    });

                    categorieColture = categorie;
                }
                
                // Popola dropdown categoria
                const categoriaSelect = document.getElementById('coltura-categoria-select');
                if (categoriaSelect) {
                    categoriaSelect.innerHTML = '<option value="">-- Seleziona categoria --</option>';
                    categorieColture.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.id;
                        option.textContent = cat.nome;
                        categoriaSelect.appendChild(option);
                    });
                    
                    // Aggiungi listener per aggiornare dropdown colture predefinite
                    categoriaSelect.addEventListener('change', updateColturePredefiniteDropdown);
                }
                
                // Aggiorna dropdown colture predefinite solo se c'√® una categoria selezionata
                // (viene chiamata anche quando cambia la categoria)
                if (categoriaSelect && categoriaSelect.value) {
                    await updateColturePredefiniteDropdown();
                }
            } catch (error) {
                console.error('Errore caricamento categorie colture:', error);
            }
        }

        // Carica colture organizzate per categoria usando colture-service.js
        async function loadColturePerCategoria() {
            try {
                if (!currentTenantId) return;
                
                // Prevenire chiamate multiple durante la migrazione
                if (isMigratingColture) {

                    return;
                }
                
                // Verifica se siamo in ambiente file:// (non supportato per moduli ES6)
                const isFileProtocol = window.location.protocol === 'file:';
                
                if (isFileProtocol) {
                    // Fallback: carica direttamente da Firestore
                    const coltureRef = collection(db, `tenants/${currentTenantId}/colture`);
                    let coltureSnapshot = await getDocs(coltureRef);
                    
                    // Se ci sono poche colture (meno di 20), inizializza quelle predefinite
                    if (coltureSnapshot.size < 20) {
                        await initializeColturePredefiniteImpostazioni();
                        coltureSnapshot = await getDocs(coltureRef);
                    }
                    
                    colturePerCategoria = {};
                    const coltureArray = [];
                    coltureSnapshot.forEach(doc => {
                        coltureArray.push({ id: doc.id, ...doc.data() });
                    });
                    
                    coltureArray.sort((a, b) => {
                        const nomeA = (a.nome || '').toLowerCase();
                        const nomeB = (b.nome || '').toLowerCase();
                        return nomeA.localeCompare(nomeB);
                    });
                    
                    // Carica categorie valide per filtrare
                    const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                    const categorieSnapshot = await getDocs(categorieRef);
                    const categorieValideSet = new Set();
                    categorieSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.applicabileA === 'colture') {
                            categorieValideSet.add(doc.id);
                        }
                    });
                    
                    // Organizza per categoria
                    coltureArray.forEach(coltura => {
                        const categoriaId = coltura.categoriaId || 'senza_categoria';
                        
                        if (categoriaId !== 'senza_categoria' && !categorieValideSet.has(categoriaId)) {
                            const categoriaIdCorretto = 'senza_categoria';
                            if (!colturePerCategoria[categoriaIdCorretto]) {
                                colturePerCategoria[categoriaIdCorretto] = [];
                            }
                            colturePerCategoria[categoriaIdCorretto].push(coltura);
                            return;
                        }
                        
                        if (!colturePerCategoria[categoriaId]) {
                            colturePerCategoria[categoriaId] = [];
                        }
                        colturePerCategoria[categoriaId].push(coltura);
                    });
                } else {
                    // Assicura che Firebase sia inizializzato nel servizio
                    const { setFirebaseInstances } = await import('../services/firebase-service.js');
                    setFirebaseInstances({ app, db, auth });
                    
                    // Assicura che il tenantId sia impostato nel servizio
                    const { setCurrentTenantId } = await import('../services/tenant-service.js');
                    if (currentTenantId) {
                        setCurrentTenantId(currentTenantId);
                    }
                    
                    // Assicura che le colture predefinite siano inizializzate
                    const { initializeColturePredefinite, getColturePerCategoria, getAllColture } = await import('../services/colture-service.js');
                    
                    // Verifica se ci sono poche colture e inizializza se necessario
                    const coltureEsistenti = await getAllColture();
                    if (coltureEsistenti.length < 20) {
                        await initializeColturePredefinite();
                    }

                    // Usa colture-service.js invece di caricamento diretto
                    colturePerCategoria = await getColturePerCategoria();

                }
                
                // Se colture √® vuoto, prova migrazione automatica (solo se non gi√† tentata)
                if (Object.keys(colturePerCategoria).length === 0 && !migrazioneTentata) {

                    await migraColtureAutomatica();
                    
                    // Ricarica dopo migrazione (solo se non siamo gi√† in un loop)
                    if (!isMigratingColture) {
                        colturePerCategoria = await getColturePerCategoria();
                    }
                }
                
                renderColture();
            } catch (error) {
                console.warn('Impossibile caricare da colture, uso ListePersonalizzate:', error.message);
                // Fallback: usa ListePersonalizzate
                try {
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    if (listeSnap.exists()) {
                        const data = listeSnap.data();
                        const colture = data.colture || [];
                        // Converti in formato gerarchico per retrocompatibilit√†
                        colturePerCategoria = { 'senza_categoria': colture.map(nome => ({ nome, categoriaId: null })) };
                        renderColture();
                    }
                } catch (e) {
                    console.error('Errore fallback ListePersonalizzate:', e);
                }
            }
        }

        // Render colture organizzate per categoria (SOLO colture custom aggiunte dall'utente, non predefinite)
        function renderColture() {
            const container = document.getElementById('colture-list');
            if (!container) return;
            
            if (Object.keys(colturePerCategoria).length === 0) {
                container.innerHTML = '<div class="empty-state">Nessuna coltura disponibile. Usa i dropdown sopra per aggiungere colture predefinite o personalizzate.</div>';
                return;
            }
            
            let html = '';
            let hasColture = false;
            
            // Crea mappa delle categorie valide (solo quelle con applicabileA === 'colture')
            const categorieValideMap = new Map();
            categorieColture.forEach(cat => {
                if (cat.applicabileA === 'colture') {
                    categorieValideMap.set(cat.id, cat);
                }
            });
            
            // Renderizza SOLO le colture custom (non predefinite) per ogni categoria
            categorieColture.forEach(categoria => {
                if (categoria.applicabileA !== 'colture') return;
                if (!categorieValideMap.has(categoria.id)) return;
                
                const colture = colturePerCategoria[categoria.id] || [];
                
                // Filtra solo le colture custom (non predefinite)
                const coltureCustom = colture.filter(c => c.predefinito !== true);
                
                if (coltureCustom.length === 0) return;
                
                hasColture = true;
                
                html += `<div style="margin-bottom: 25px;">`;
                html += `<h4 style="color: #2E8B57; font-size: 16px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #e9ecef;">${escapeHtml(categoria.nome)}</h4>`;
                
                // Ordina per nome
                coltureCustom.sort((a, b) => {
                    const nomeA = (a.nome || '').toLowerCase();
                    const nomeB = (b.nome || '').toLowerCase();
                    return nomeA.localeCompare(nomeB);
                });
                
                coltureCustom.forEach(coltura => {
                    html += `
                        <div class="list-item" style="margin-left: 15px;">
                            <div class="list-item-name">
                                <span>${escapeHtml(coltura.nome)}</span>
                                <span class="badge badge-custom">Custom</span>
                            </div>
                            <button class="btn btn-danger btn-small" onclick="removeColtura('${escapeHtml(coltura.nome)}', '${coltura.id}')" title="Elimina">üóëÔ∏è Elimina</button>
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            // Colture senza categoria (retrocompatibilit√†) - solo custom
            if (colturePerCategoria['senza_categoria'] && colturePerCategoria['senza_categoria'].length > 0) {
                const coltureSenzaCategoria = colturePerCategoria['senza_categoria'];
                
                // Filtra solo le colture custom (non predefinite)
                const coltureCustomSenzaCategoria = coltureSenzaCategoria.filter(coltura => {
                    if (typeof coltura === 'object') {
                        return coltura.predefinito !== true;
                    }
                    // Se √® una stringa, √® probabilmente custom (vecchio formato)
                    return true;
                });
                
                if (coltureCustomSenzaCategoria.length > 0) {
                    hasColture = true;
                    html += `<div style="margin-bottom: 25px;">`;
                    html += `<h4 style="color: #666; font-size: 16px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #e9ecef;">Senza Categoria</h4>`;
                    coltureCustomSenzaCategoria.forEach(coltura => {
                        const nomeColtura = typeof coltura === 'object' ? coltura.nome : coltura;
                        const colturaId = typeof coltura === 'object' ? coltura.id : '';
                        
                        html += `
                            <div class="list-item" style="margin-left: 15px;">
                                <div class="list-item-name">
                                    <span>${escapeHtml(nomeColtura)}</span>
                                    <span class="badge badge-custom">Custom</span>
                                </div>
                                <button class="btn btn-danger btn-small" onclick="removeColtura('${escapeHtml(nomeColtura)}', '${colturaId}')" title="Elimina">üóëÔ∏è Elimina</button>
                            </div>
                        `;
                    });
                    html += `</div>`;
                }
            }
            
            if (!hasColture) {
                container.innerHTML = '<div class="empty-state">Nessuna coltura disponibile. Usa i dropdown sopra per aggiungere colture predefinite o personalizzate.</div>';
            } else {
                container.innerHTML = html;
            }
        }
        
        // Aggiungi tipo lavoro
        async function addTipoLavoro() {
            const input = document.getElementById('new-tipo-lavoro');
            const categoriaSelect = document.getElementById('tipo-lavoro-categoria-select');
            const sottocategoriaSelect = document.getElementById('tipo-lavoro-sottocategoria-select');
            
            const nome = input.value.trim();
            const categoriaId = categoriaSelect ? categoriaSelect.value : null;
            const sottocategoriaId = sottocategoriaSelect && sottocategoriaSelect.value ? sottocategoriaSelect.value : null;
            
            if (!nome) {
                showAlert('Inserisci un nome per il tipo lavoro', 'error');
                return;
            }
            
            if (!categoriaId) {
                showAlert('Seleziona una categoria', 'error');
                return;
            }
            
            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            try {
                // Verifica se esiste gi√† in tipiLavoro nella stessa categoria/sottocategoria (case-insensitive)
                const tipiRef = collection(db, `tenants/${currentTenantId}/tipiLavoro`);
                const tipiEsistenti = await getDocs(tipiRef);
                const nomeLower = nome.toLowerCase();
                
                const duplicato = Array.from(tipiEsistenti.docs).find(doc => {
                    const data = doc.data();
                    return data.nome.toLowerCase() === nomeLower &&
                           data.categoriaId === categoriaId &&
                           (data.sottocategoriaId || null) === (sottocategoriaId || null);
                });
                
                if (duplicato) {
                    showAlert('Questo tipo lavoro √® gi√† presente in questa categoria/sottocategoria', 'error');
                    return;
                }
                
                // Crea tipo lavoro in tipiLavoro
                await addDoc(tipiRef, {
                    nome: nome,
                    categoriaId: categoriaId,
                    sottocategoriaId: sottocategoriaId || null,
                    descrizione: null,
                    predefinito: false,
                    creatoDa: currentUser?.uid || 'system',
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });
                
                // Sincronizza ListePersonalizzate (per retrocompatibilit√†)
                try {
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    let tipiLavoroList = [];
                    
                    if (listeSnap.exists()) {
                        tipiLavoroList = listeSnap.data().tipiLavoro || [];
                    }
                    
                    if (!tipiLavoroList.includes(nome)) {
                        tipiLavoroList.push(nome);
                        tipiLavoroList.sort();
                        
                        const listeData = {
                            tipiLavoro: tipiLavoroList,
                            colture: listeSnap.exists() ? (listeSnap.data().colture || COLTURE_PREDEFINITE) : COLTURE_PREDEFINITE,
                            updatedAt: serverTimestamp()
                        };
                        
                        if (!listeSnap.exists()) {
                            listeData.createdAt = serverTimestamp();
                        }
                        
                        await setDoc(listeRef, listeData);
                    }
                } catch (error) {
                    console.warn('Impossibile sincronizzare ListePersonalizzate:', error);
                }
                
                input.value = '';
                showAlert('Tipo lavoro aggiunto con successo', 'success');
                await loadListe();
            } catch (error) {
                console.error('Errore aggiunta tipo lavoro:', error);
                showAlert('Errore durante l\'aggiunta: ' + error.message, 'error');
            }
        }
        
        // Rimuovi tipo lavoro (ora elimina da tipiLavoro)
        async function removeTipoLavoro(tipoLavoro, tipoLavoroId) {
            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            try {
                const tipiRef = collection(db, `tenants/${currentTenantId}/tipiLavoro`);
                let tipoDoc = null;
                
                // Se abbiamo l'ID, usa quello (pi√π preciso)
                if (tipoLavoroId) {
                    const tipoRef = doc(tipiRef, tipoLavoroId);
                    const tipoSnap = await getDoc(tipoRef);
                    if (tipoSnap.exists()) {
                        tipoDoc = { id: tipoSnap.id, data: tipoSnap.data() };
                    }
                }
                
                // Altrimenti cerca per nome
                if (!tipoDoc) {
                    const tipiSnapshot = await getDocs(query(tipiRef, where('nome', '==', tipoLavoro)));
                    if (!tipiSnapshot.empty) {
                        // Prendi il primo non predefinito, o il primo se tutti sono predefiniti
                        const tipoNonPredefinito = tipiSnapshot.docs.find(doc => doc.data().predefinito !== true);
                        if (tipoNonPredefinito) {
                            tipoDoc = { id: tipoNonPredefinito.id, data: tipoNonPredefinito.data() };
                        } else {
                            // Tutti sono predefiniti, prendi il primo
                            tipoDoc = { id: tipiSnapshot.docs[0].id, data: tipiSnapshot.docs[0].data() };
                        }
                    }
                }
                
                if (!tipoDoc) {
                    showAlert('Tipo lavoro non trovato', 'error');
                    return;
                }
                
                // IMPORTANTE: Verifica SOLO il campo predefinito nel documento
                if (tipoDoc.data.predefinito === true) {
                    showAlert('Non √® possibile eliminare un tipo lavoro predefinito', 'error');
                    return;
                }
                
                // Verifica se √® usato
                const attivitaCollection = collection(db, `tenants/${currentTenantId}/attivita`);
                const attivitaQuery = query(attivitaCollection, where('tipoLavoro', '==', tipoLavoro));
                const attivitaSnapshot = await getDocs(attivitaQuery);
                
                const lavoriCollection = collection(db, `tenants/${currentTenantId}/lavori`);
                const lavoriQuery = query(lavoriCollection, where('tipoLavoro', '==', tipoLavoro));
                const lavoriSnapshot = await getDocs(lavoriQuery);
                
                const numAttivita = attivitaSnapshot.size;
                const numLavori = lavoriSnapshot.size;
                
                if (numAttivita > 0 || numLavori > 0) {
                    if (!confirm(`Questo tipo lavoro √® usato in ${numAttivita} attivit√† e ${numLavori} lavori. Eliminare comunque?`)) {
                        return;
                    }
                }
                
                // Elimina il documento specifico
                await deleteDoc(doc(tipiRef, tipoDoc.id));

                // Sincronizza ListePersonalizzate (per retrocompatibilit√†)
                try {
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    
                    if (listeSnap.exists()) {
                        const data = listeSnap.data();
                        const tipiLavoroList = (data.tipiLavoro || []).filter(t => t !== tipoLavoro);
                        
                        await updateDoc(listeRef, {
                            tipiLavoro: tipiLavoroList,
                            updatedAt: serverTimestamp()
                        });
                    }
                } catch (error) {
                    console.warn('Impossibile sincronizzare ListePersonalizzate:', error);
                }
                
                // Ricarica liste
                await loadTipiLavoroPerCategoria();
                await loadListe();
                
                showAlert('Tipo lavoro eliminato con successo', 'success');
            } catch (error) {
                console.error('Errore eliminazione tipo lavoro:', error);
                showAlert('Errore eliminazione tipo lavoro: ' + error.message, 'error');
            }
        }
        
        // Aggiorna dropdown colture predefinite in base alla categoria selezionata
        async function updateColturePredefiniteDropdown() {
            const categoriaSelect = document.getElementById('coltura-categoria-select');
            const colturaPredeterminataSelect = document.getElementById('new-coltura-predeterminata');
            
            if (!colturaPredeterminataSelect) {
                console.warn('‚ö†Ô∏è Dropdown colture predefinite non trovato');
                return;
            }
            
            // Reset dropdown
            colturaPredeterminataSelect.innerHTML = '<option value="">-- Seleziona una coltura predefinita (opzionale) --</option>';
            
            const categoriaId = categoriaSelect?.value;
            if (!categoriaId) {

                return;
            }
            
            // Trova il codice della categoria
            const categoria = categorieColture.find(c => c.id === categoriaId);
            if (!categoria) {
                return;
            }
            if (!categoria.codice) {
                return;
            }
            
            // Carica colture predefinite (definite direttamente per evitare problemi di import)
            try {
                // Colture predefinite organizzate per categoria
                const COLTURE_PREDEFINITE = [
                    // Frutteto
                    { nome: 'Pesco', categoriaCodice: 'frutteto' }, { nome: 'Melo', categoriaCodice: 'frutteto' },
                    { nome: 'Pero', categoriaCodice: 'frutteto' }, { nome: 'Albicocche', categoriaCodice: 'frutteto' },
                    { nome: 'Prugne', categoriaCodice: 'frutteto' }, { nome: 'Ciliegio', categoriaCodice: 'frutteto' },
                    { nome: 'Susino', categoriaCodice: 'frutteto' }, { nome: 'Fico', categoriaCodice: 'frutteto' },
                    { nome: 'Nocciolo', categoriaCodice: 'frutteto' }, { nome: 'Mandorlo', categoriaCodice: 'frutteto' },
                    { nome: 'Castagno', categoriaCodice: 'frutteto' }, { nome: 'Cotogno', categoriaCodice: 'frutteto' },
                    { nome: 'Sorbo', categoriaCodice: 'frutteto' }, { nome: 'Nespolo', categoriaCodice: 'frutteto' },
                    { nome: 'Giuggiolo', categoriaCodice: 'frutteto' }, { nome: 'Corbezzolo', categoriaCodice: 'frutteto' },
                    { nome: 'Gelso', categoriaCodice: 'frutteto' }, { nome: 'Mora', categoriaCodice: 'frutteto' },
                    { nome: 'Lampone', categoriaCodice: 'frutteto' }, { nome: 'Mirtillo', categoriaCodice: 'frutteto' },
                    { nome: 'Ribes', categoriaCodice: 'frutteto' }, { nome: 'Uva Spina', categoriaCodice: 'frutteto' },
                    { nome: 'Kiwi', categoriaCodice: 'frutteto' }, { nome: 'Melograno', categoriaCodice: 'frutteto' },
                    { nome: 'Fico d\'India', categoriaCodice: 'frutteto' }, { nome: 'Kaki', categoriaCodice: 'frutteto' },
                    { nome: 'Noce', categoriaCodice: 'frutteto' }, { nome: 'Pistacchio', categoriaCodice: 'frutteto' },
                    // Seminativo
                    { nome: 'Grano', categoriaCodice: 'seminativo' }, { nome: 'Mais', categoriaCodice: 'seminativo' },
                    { nome: 'Orzo', categoriaCodice: 'seminativo' }, { nome: 'Favino', categoriaCodice: 'seminativo' },
                    { nome: 'Girasole', categoriaCodice: 'seminativo' }, { nome: 'Soia', categoriaCodice: 'seminativo' },
                    { nome: 'Colza', categoriaCodice: 'seminativo' }, { nome: 'Avena', categoriaCodice: 'seminativo' },
                    { nome: 'Segale', categoriaCodice: 'seminativo' }, { nome: 'Fava', categoriaCodice: 'seminativo' },
                    { nome: 'Lenticchia', categoriaCodice: 'seminativo' }, { nome: 'Cece', categoriaCodice: 'seminativo' },
                    { nome: 'Lupino', categoriaCodice: 'seminativo' }, { nome: 'Cicerchia', categoriaCodice: 'seminativo' },
                    { nome: 'Riso', categoriaCodice: 'seminativo' }, { nome: 'Grano Saraceno', categoriaCodice: 'seminativo' },
                    { nome: 'Amaranto', categoriaCodice: 'seminativo' }, { nome: 'Quinoa', categoriaCodice: 'seminativo' },
                    { nome: 'Canapa', categoriaCodice: 'seminativo' }, { nome: 'Lino', categoriaCodice: 'seminativo' },
                    { nome: 'Carthamo', categoriaCodice: 'seminativo' }, { nome: 'Erba Medica', categoriaCodice: 'seminativo' },
                    { nome: 'Trifoglio', categoriaCodice: 'seminativo' }, { nome: 'Veccia', categoriaCodice: 'seminativo' },
                    { nome: 'Lupinella', categoriaCodice: 'seminativo' }, { nome: 'Sulla', categoriaCodice: 'seminativo' },
                    { nome: 'Sorgo', categoriaCodice: 'seminativo' }, { nome: 'Miglio', categoriaCodice: 'seminativo' },
                    { nome: 'Panico', categoriaCodice: 'seminativo' },
                    // Vite
                    { nome: 'Vite', categoriaCodice: 'vite' },
                    { nome: 'Vite da Tavola', categoriaCodice: 'vite' },
                    { nome: 'Vite da Vino', categoriaCodice: 'vite' },
                    // Ortive
                    { nome: 'Pomodoro', categoriaCodice: 'ortive' }, { nome: 'Zucchine', categoriaCodice: 'ortive' },
                    { nome: 'Melanzane', categoriaCodice: 'ortive' }, { nome: 'Peperoni', categoriaCodice: 'ortive' },
                    { nome: 'Insalata', categoriaCodice: 'ortive' }, { nome: 'Carote', categoriaCodice: 'ortive' },
                    { nome: 'Patate', categoriaCodice: 'ortive' }, { nome: 'Bietole', categoriaCodice: 'ortive' },
                    { nome: 'Fragole', categoriaCodice: 'ortive' }, { nome: 'Cipolle', categoriaCodice: 'ortive' },
                    { nome: 'Aglio', categoriaCodice: 'ortive' }, { nome: 'Fagioli', categoriaCodice: 'ortive' },
                    { nome: 'Fagiolini', categoriaCodice: 'ortive' }, { nome: 'Piselli', categoriaCodice: 'ortive' },
                    { nome: 'Cavolo', categoriaCodice: 'ortive' }, { nome: 'Broccoli', categoriaCodice: 'ortive' },
                    { nome: 'Cavolfiore', categoriaCodice: 'ortive' }, { nome: 'Spinaci', categoriaCodice: 'ortive' },
                    { nome: 'Lattuga', categoriaCodice: 'ortive' }, { nome: 'Radicchio', categoriaCodice: 'ortive' },
                    { nome: 'Finocchi', categoriaCodice: 'ortive' }, { nome: 'Sedano', categoriaCodice: 'ortive' },
                    { nome: 'Cetrioli', categoriaCodice: 'ortive' }, { nome: 'Angurie', categoriaCodice: 'ortive' },
                    { nome: 'Meloni', categoriaCodice: 'ortive' },
                    // Prato
                    { nome: 'Prato', categoriaCodice: 'prato' }, { nome: 'Prato Stabile', categoriaCodice: 'prato' },
                    { nome: 'Pascolo', categoriaCodice: 'prato' },
                    // Olivo
                    { nome: 'Olivo', categoriaCodice: 'olivo' },
                    // Agrumeto
                    { nome: 'Arancio', categoriaCodice: 'agrumeto' }, { nome: 'Limone', categoriaCodice: 'agrumeto' },
                    { nome: 'Mandarino', categoriaCodice: 'agrumeto' }, { nome: 'Clementine', categoriaCodice: 'agrumeto' },
                    { nome: 'Pompelmo', categoriaCodice: 'agrumeto' }, { nome: 'Bergamotto', categoriaCodice: 'agrumeto' },
                    { nome: 'Cedro', categoriaCodice: 'agrumeto' }, { nome: 'Lime', categoriaCodice: 'agrumeto' },
                    { nome: 'Kumquat', categoriaCodice: 'agrumeto' }
                ];
                
                // Filtra colture predefinite per questa categoria
                const coltureCategoria = COLTURE_PREDEFINITE.filter(c => 
                    c.categoriaCodice === categoria.codice.toLowerCase()
                );

// Carica colture gi√† esistenti per questa categoria
                const coltureEsistenti = colturePerCategoria[categoriaId] || [];
                const nomiEsistenti = new Set(coltureEsistenti.map(c => c.nome.toLowerCase()));
                
                // Se non ci sono colture esistenti e colturePerCategoria √® vuoto, potrebbe non essere ancora caricato
                if (Object.keys(colturePerCategoria).length === 0) {
                    console.warn('‚ö†Ô∏è colturePerCategoria √® vuoto, potrebbe non essere ancora caricato. Ricarica le colture.');
                    // Prova a ricaricare le colture
                    try {
                        await loadColturePerCategoria();
                        // Riprova dopo il caricamento
                        const coltureEsistentiRicaricate = colturePerCategoria[categoriaId] || [];
                        const nomiEsistentiRicaricate = new Set(coltureEsistentiRicaricate.map(c => c.nome.toLowerCase()));
                        
                        // Mostra tutte le colture predefinite, con indicazione per quelle gi√† aggiunte
                        coltureCategoria.forEach(coltura => {
                            const option = document.createElement('option');
                            option.value = coltura.nome;
                            const isAggiunta = nomiEsistentiRicaricate.has(coltura.nome.toLowerCase());
                            option.textContent = isAggiunta ? `${coltura.nome} (gi√† aggiunta)` : coltura.nome;
                            if (isAggiunta) {
                                option.disabled = true;
                                option.style.color = '#999';
                            }
                            colturaPredeterminataSelect.appendChild(option);
                        });
                        return;
                    } catch (e) {
                        console.error('Errore ricaricamento colture:', e);
                    }
                }
                
                // Mostra tutte le colture predefinite, con indicazione per quelle gi√† aggiunte
                coltureCategoria.forEach(coltura => {
                    const option = document.createElement('option');
                    option.value = coltura.nome;
                    const isAggiunta = nomiEsistenti.has(coltura.nome.toLowerCase());
                    option.textContent = isAggiunta ? `${coltura.nome} (gi√† aggiunta)` : coltura.nome;
                    if (isAggiunta) {
                        option.disabled = true;
                        option.style.color = '#999';
                    }
                    colturaPredeterminataSelect.appendChild(option);
                });
            } catch (error) {
                console.warn('Impossibile caricare colture predefinite:', error);
            }
        }
        
        // Gestisce cambio coltura predefinita
        function onColturaPredeterminataChange() {
            const colturaPredeterminataSelect = document.getElementById('new-coltura-predeterminata');
            const input = document.getElementById('new-coltura');
            
            if (colturaPredeterminataSelect && colturaPredeterminataSelect.value) {
                input.value = colturaPredeterminataSelect.value;
            }
        }
        
        // Aggiungi coltura
        async function addColtura() {
            const input = document.getElementById('new-coltura');
            const categoriaSelect = document.getElementById('coltura-categoria-select');
            const nome = input.value.trim();
            const categoriaId = categoriaSelect?.value;
            
            if (!nome) {
                showAlert('Inserisci un nome per la coltura', 'error');
                return;
            }
            
            if (!categoriaId) {
                showAlert('Seleziona una categoria', 'error');
                return;
            }
            
            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            try {
                // Prova a creare in collection colture (fonte unica di verit√†)
                try {
                    const coltureRef = collection(db, `tenants/${currentTenantId}/colture`);
                    
                    // Verifica se esiste gi√† nella stessa categoria
                    const q = query(
                        coltureRef, 
                        where('nome', '==', nome),
                        where('categoriaId', '==', categoriaId)
                    );
                    const existingSnapshot = await getDocs(q);
                    if (!existingSnapshot.empty) {
                        showAlert('Questa coltura √® gi√† presente in questa categoria', 'error');
                        return;
                    }
                    
                    // Crea nuova coltura
                    const nuovaColtura = {
                        nome: nome,
                        categoriaId: categoriaId,
                        descrizione: null,
                        predefinito: false,
                        creatoDa: auth.currentUser?.uid || 'system',
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    };
                    
                    await addDoc(coltureRef, nuovaColtura);
                    
                    input.value = '';
                    categoriaSelect.value = '';
                    const colturaPredeterminataSelect = document.getElementById('new-coltura-predeterminata');
                    if (colturaPredeterminataSelect) {
                        colturaPredeterminataSelect.value = '';
                    }
                    showAlert('Coltura aggiunta con successo', 'success');
                    await loadColturePerCategoria();
                    await updateColturePredefiniteDropdown(); // Aggiorna dropdown predefinite
                } catch (error) {
                    // Fallback: se colture non disponibile, usa metodo vecchio
                    console.warn('Impossibile creare in colture, uso ListePersonalizzate:', error.message);
                    
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    
                    let colture = [...COLTURE_PREDEFINITE];
                    if (listeSnap.exists()) {
                        const data = listeSnap.data();
                        colture = data.colture || colture;
                    }
                    
                    // Verifica duplicati (case-insensitive)
                    if (colture.some(c => c.toLowerCase() === nome.toLowerCase())) {
                        showAlert('Questa coltura √® gi√† presente', 'error');
                        return;
                    }
                    
                    // Aggiungi nuova coltura
                    colture.push(nome);
                    
                    // Ordina: prima predefinite, poi custom
                    colture.sort((a, b) => {
                        const aIsPredefinita = COLTURE_PREDEFINITE.some(p => p.toLowerCase() === a.toLowerCase());
                        const bIsPredefinita = COLTURE_PREDEFINITE.some(p => p.toLowerCase() === b.toLowerCase());
                        if (aIsPredefinita && !bIsPredefinita) return -1;
                        if (!aIsPredefinita && bIsPredefinita) return 1;
                        return a.localeCompare(b);
                    });
                    
                    // Salva
                    const listeData = {
                        tipiLavoro: listeSnap.exists() ? (listeSnap.data().tipiLavoro || TIPI_LAVORO_PREDEFINITI) : TIPI_LAVORO_PREDEFINITI,
                        colture: colture,
                        updatedAt: serverTimestamp()
                    };
                    
                    if (!listeSnap.exists()) {
                        listeData.createdAt = serverTimestamp();
                    }
                    
                    await setDoc(listeRef, listeData);
                    
                    input.value = '';
                    categoriaSelect.value = '';
                    const colturaPredeterminataSelect = document.getElementById('new-coltura-predeterminata');
                    if (colturaPredeterminataSelect) {
                        colturaPredeterminataSelect.value = '';
                    }
                    showAlert('Coltura aggiunta con successo', 'success');
                    await loadColturePerCategoria();
                    await updateColturePredefiniteDropdown(); // Aggiorna dropdown predefinite
                }
            } catch (error) {
                console.error('Errore aggiunta coltura:', error);
                showAlert('Errore durante l\'aggiunta: ' + error.message, 'error');
            }
        }
        
        // Rimuovi coltura
        async function removeColtura(colturaNome, colturaId) {
            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            try {
                // Prova a rimuovere da collection colture (fonte unica di verit√†)
                try {
                    const coltureRef = collection(db, `tenants/${currentTenantId}/colture`);
                    let colturaDoc = null;
                    
                    // Se abbiamo l'ID, usalo direttamente
                    if (colturaId) {
                        try {
                            const colturaDocRef = doc(db, `tenants/${currentTenantId}/colture`, colturaId);
                            const colturaSnap = await getDoc(colturaDocRef);
                            if (colturaSnap.exists()) {
                                colturaDoc = { id: colturaSnap.id, data: () => colturaSnap.data() };
                            }
                        } catch (e) {
                            console.warn('Errore recupero coltura per ID:', e);
                        }
                    }
                    
                    // Se non trovata per ID, cerca per nome
                    if (!colturaDoc) {
                        const q = query(coltureRef, where('nome', '==', colturaNome));
                        const snapshot = await getDocs(q);
                        if (!snapshot.empty) {
                            const doc = snapshot.docs[0];
                            colturaDoc = { id: doc.id, data: () => doc.data() };
                        }
                    }
                    
                    if (!colturaDoc) {
                        showAlert('Coltura non trovata', 'error');
                        return;
                    }
                    
                    const colturaData = colturaDoc.data();
                    
                    // Verifica se √® predefinita
                    if (colturaData.predefinito) {
                        showAlert('Non √® possibile eliminare una coltura predefinita', 'error');
                        return;
                    }
                    
                    // Verifica se usata in attivit√†
                    try {
                        const attivitaCollection = collection(db, `tenants/${currentTenantId}/attivita`);
                        const qAttivita = query(attivitaCollection, where('coltura', '==', colturaNome));
                        const querySnapshot = await getDocs(qAttivita);
                        const numAttivita = querySnapshot.size;
                        
                        // Verifica anche in terreni
                        const terreniCollection = collection(db, `tenants/${currentTenantId}/terreni`);
                        const qTerreni = query(terreniCollection, where('coltura', '==', colturaNome));
                        const terreniSnapshot = await getDocs(qTerreni);
                        const numTerreni = terreniSnapshot.size;
                        
                        if (numAttivita > 0 || numTerreni > 0) {
                            if (!confirm(`Questa coltura √® usata in ${numAttivita} attivit√† e ${numTerreni} terreni. Eliminare comunque?`)) {
                                return;
                            }
                        }
                    } catch (e) {
                        console.warn('Errore verifica uso coltura:', e);
                    }
                    
                    // Elimina da collection colture
                    await deleteDoc(doc(db, `tenants/${currentTenantId}/colture`, colturaDoc.id));
                    
                    showAlert('Coltura eliminata con successo', 'success');
                    await loadColturePerCategoria();
                } catch (error) {
                    // Fallback: se colture non disponibile, usa metodo vecchio
                    console.warn('Impossibile rimuovere da colture, uso ListePersonalizzate:', error.message);
                    
                    // Verifica se √® predefinita
                    if (COLTURE_PREDEFINITE.some(p => p.toLowerCase() === coltura.toLowerCase())) {
                        showAlert('Non √® possibile eliminare una coltura predefinita', 'error');
                        return;
                    }
                    
                    // Verifica se usata in attivit√†
                    try {
                        const attivitaCollection = collection(db, `tenants/${currentTenantId}/attivita`);
                        const q = query(attivitaCollection, where('coltura', '==', coltura));
                        const querySnapshot = await getDocs(q);
                        const numAttivita = querySnapshot.size;
                        
                        if (numAttivita > 0) {
                            if (!confirm(`Questa coltura √® usata in ${numAttivita} attivit√†. Eliminare comunque?`)) {
                                return;
                            }
                        }
                    } catch (e) {
                        console.warn('Errore verifica attivit√†:', e);
                    }
                    
                    const listeRef = doc(db, `tenants/${currentTenantId}/liste`, 'personalizzate');
                    const listeSnap = await getDoc(listeRef);
                    
                    if (!listeSnap.exists()) {
                        showAlert('Liste non trovate', 'error');
                        return;
                    }
                    
                    const data = listeSnap.data();
                    const colture = (data.colture || []).filter(c => c !== coltura);
                    
                    await updateDoc(listeRef, {
                        colture: colture,
                        updatedAt: serverTimestamp()
                    });
                    
                    showAlert('Coltura eliminata con successo', 'success');
                    await loadColturePerCategoria();
                }
            } catch (error) {
                console.error('Errore rimozione coltura:', error);
                showAlert('Errore durante l\'eliminazione: ' + error.message, 'error');
            }
        }
        
        // Escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }
        
        // ========== Gestione Tariffe Operai ==========
        
        const TIPI_OPERAI = [
            { value: 'semplice', label: 'Operaio Semplice' },
            { value: 'specializzato', label: 'Operaio Specializzato' },
            { value: 'trattorista', label: 'Trattorista' },
            { value: 'meccanico', label: 'Meccanico' },
            { value: 'elettricista', label: 'Elettricista' },
            { value: 'altro', label: 'Altro' }
        ];
        
        // Tariffe default (se non configurate)
        const TARIFFE_DEFAULT = {
            semplice: 10.0,
            specializzato: 12.0,
            trattorista: 15.0,
            meccanico: 14.0,
            elettricista: 14.0,
            altro: 10.0
        };
        
        // Carica tariffe
        async function loadTariffe() {
            if (!currentTenantId) return;
            
            try {
                const tariffeRef = doc(db, `tenants/${currentTenantId}/tariffe`, 'operai');
                const tariffeSnap = await getDoc(tariffeRef);
                
                let tariffe = { ...TARIFFE_DEFAULT };
                if (tariffeSnap.exists()) {
                    const data = tariffeSnap.data();
                    // Unisci con default per assicurarsi che tutti i tipi siano presenti
                    tariffe = { ...TARIFFE_DEFAULT, ...data };
                }
                
                renderTariffe(tariffe);
                
                // Carica anche tariffa proprietario
                await loadTariffaProprietario();
            } catch (error) {
                console.error('Errore caricamento tariffe:', error);
                showAlert('Errore caricamento tariffe', 'error');
            }
        }
        
        // Carica tariffa proprietario
        async function loadTariffaProprietario() {
            if (!currentTenantId) return;
            
            try {
                const tariffeRef = doc(db, `tenants/${currentTenantId}/tariffe`, 'proprietario');
                const tariffeSnap = await getDoc(tariffeRef);
                
                let tariffa = 15.0; // Default
                if (tariffeSnap.exists()) {
                    const data = tariffeSnap.data();
                    tariffa = data.tariffaOraria || data.tariffa || 15.0;
                }
                
                document.getElementById('tariffa-proprietario').value = tariffa;
            } catch (error) {
                console.error('Errore caricamento tariffa proprietario:', error);
            }
        }
        
        // Salva tariffa proprietario
        async function saveTariffaProprietario() {
            if (!currentTenantId) {
                showAlert('Errore: tenant non disponibile', 'error');
                return;
            }
            
            const input = document.getElementById('tariffa-proprietario');
            const valore = parseFloat(input.value);
            
            if (isNaN(valore) || valore < 0) {
                showAlert('Inserisci un valore valido per la tariffa', 'error');
                return;
            }
            
            try {
                const tariffeRef = doc(db, `tenants/${currentTenantId}/tariffe`, 'proprietario');
                const tariffeSnap = await getDoc(tariffeRef);
                
                const tariffeData = {
                    tariffaOraria: valore,
                    updatedAt: serverTimestamp()
                };
                
                if (!tariffeSnap.exists()) {
                    tariffeData.createdAt = serverTimestamp();
                }
                
                await setDoc(tariffeRef, tariffeData);
                showAlert('Tariffa proprietario salvata con successo', 'success');
            } catch (error) {
                console.error('Errore salvataggio tariffa proprietario:', error);
                showAlert('Errore durante il salvataggio: ' + error.message, 'error');
            }
        }
        
        // Render tariffe
        function renderTariffe(tariffe) {
            const container = document.getElementById('tariffe-list');
            
            container.innerHTML = TIPI_OPERAI.map(tipo => {
                const tariffa = tariffe[tipo.value] || TARIFFE_DEFAULT[tipo.value] || 0;
                const escapedLabel = escapeHtml(tipo.label);
                
                return `
                    <div class="list-item" style="align-items: center;">
                        <div class="list-item-name" style="flex: 1;">
                            <div style="font-weight: 600; color: #2E8B57;">${escapedLabel}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px; flex: 1;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input 
                                    type="number" 
                                    step="0.01" 
                                    min="0" 
                                    id="tariffa-${tipo.value}" 
                                    value="${tariffa.toFixed(2)}" 
                                    style="width: 100px; padding: 8px; border: 1px solid #ced4da; border-radius: 6px;"
                                    onchange="saveTariffa('${tipo.value}')"
                                >
                                <span style="color: #666;">‚Ç¨/ora</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Carica coefficienti morfologia
        async function loadCoefficientiMorfologia() {
            if (!currentTenantId) return;
            
            try {
                const coeffRef = doc(db, `tenants/${currentTenantId}/impostazioni`, 'coefficientiMorfologia');
                const coeffSnap = await getDoc(coeffRef);
                
                // Valori default
                let coefficienti = {
                    pianura: 1.0,
                    collina: 1.2,
                    montagna: 1.5
                };
                
                if (coeffSnap.exists()) {
                    const data = coeffSnap.data();
                    console.log('Coefficienti caricati da Firestore:', data);
                    coefficienti = {
                        pianura: data.pianura || 1.0,
                        collina: data.collina || 1.2,
                        montagna: data.montagna || 1.5
                    };
                } else {
                    console.log('Nessun documento trovato, uso valori default');
                }
                
                console.log('Impostazione coefficienti nei campi:', coefficienti);
                
                // Converti decimali in percentuali (incremento rispetto a pianura)
                // Pianura √® sempre 0% (base)
                // Collina: (1.2 - 1.0) * 100 = 20%
                // Montagna: (1.5 - 1.0) * 100 = 50%
                const pianuraBase = coefficienti.pianura || 1.0;
                const percentualeCollina = Math.round(((coefficienti.collina || 1.2) - pianuraBase) * 100);
                const percentualeMontagna = Math.round(((coefficienti.montagna || 1.5) - pianuraBase) * 100);
                
                document.getElementById('coeff-pianura').value = 0; // Sempre 0% (base)
                document.getElementById('coeff-collina').value = percentualeCollina;
                document.getElementById('coeff-montagna').value = percentualeMontagna;
            } catch (error) {
                console.error('Errore caricamento coefficienti morfologia:', error);
                showAlert('Errore caricamento coefficienti', 'error');
            }
        }
        
        // Salva coefficienti morfologia
        window.handleSaveCoefficientiMorfologia = async function(event) {
            console.log('handleSaveCoefficientiMorfologia chiamata');
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            if (!currentTenantId) {
                console.error('Tenant ID non disponibile');
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            // Verifica che il modulo Conto Terzi sia attivo
            try {
                const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                if (tenantDoc.exists()) {
                    const tenantData = tenantDoc.data();
                    const hasContoTerziModule = tenantData.modules && tenantData.modules.includes('contoTerzi');
                    if (!hasContoTerziModule) {
                        showAlert('Il modulo Conto Terzi non √® attivo. Attiva il modulo per gestire i coefficienti morfologia.', 'error');
                        return;
                    }
                }
            } catch (error) {
                console.error('Errore verifica modulo conto terzi:', error);
            }
            
            console.log('Tenant ID:', currentTenantId);
            
            // Leggi percentuali dall'input
            const percentualeCollina = parseFloat(document.getElementById('coeff-collina').value);
            const percentualeMontagna = parseFloat(document.getElementById('coeff-montagna').value);
            
            // Validazione percentuali
            if (isNaN(percentualeCollina) || percentualeCollina < 0 ||
                isNaN(percentualeMontagna) || percentualeMontagna < 0) {
                showAlert('Inserisci valori percentuali validi (>= 0) per collina e montagna', 'error');
                return;
            }
            
            // Converti percentuali in decimali per salvare nel database
            // Pianura √® sempre 1.0 (base)
            // Collina: 1.0 + (20% / 100) = 1.2
            // Montagna: 1.0 + (50% / 100) = 1.5
            const coefficienti = {
                pianura: 1.0, // Sempre base
                collina: 1.0 + (percentualeCollina / 100),
                montagna: 1.0 + (percentualeMontagna / 100)
            };
            
            try {
                console.log('Salvataggio coefficienti:', coefficienti);
                const coeffRef = doc(db, `tenants/${currentTenantId}/impostazioni`, 'coefficientiMorfologia');
                await setDoc(coeffRef, {
                    pianura: coefficienti.pianura,
                    collina: coefficienti.collina,
                    montagna: coefficienti.montagna,
                    updatedAt: serverTimestamp()
                }, { merge: true });
                
                console.log('Coefficienti salvati con successo');
                showAlert('Coefficienti salvati con successo!', 'success');
                
                // Ricarica i coefficienti per verificare che siano stati salvati
                await loadCoefficientiMorfologia();
            } catch (error) {
                console.error('Errore salvataggio coefficienti:', error);
                console.error('Dettagli errore:', {
                    code: error.code,
                    message: error.message,
                    tenantId: currentTenantId
                });
                showAlert('Errore salvataggio coefficienti: ' + error.message, 'error');
            }
        }
        
        // Salva tariffa
        async function saveTariffa(tipoOperaio) {
            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            // Verifica che il modulo Manodopera sia attivo
            try {
                const tenantDoc = await getDoc(doc(db, 'tenants', currentTenantId));
                if (tenantDoc.exists()) {
                    const tenantData = tenantDoc.data();
                    const hasManodoperaModule = tenantData.modules && tenantData.modules.includes('manodopera');
                    if (!hasManodoperaModule) {
                        showAlert('Il modulo Manodopera non √® attivo. Attiva il modulo per gestire le tariffe operai.', 'error');
                        return;
                    }
                }
            } catch (error) {
                console.error('Errore verifica modulo manodopera:', error);
            }
            
            const input = document.getElementById(`tariffa-${tipoOperaio}`);
            if (!input) {
                showAlert('Campo tariffa non trovato', 'error');
                return;
            }
            
            const valore = parseFloat(input.value);
            
            if (isNaN(valore) || valore < 0) {
                showAlert('Inserisci un valore valido (>= 0)', 'error');
                // Ripristina valore precedente
                await loadTariffe();
                return;
            }
            
            try {
                const tariffeRef = doc(db, `tenants/${currentTenantId}/tariffe`, 'operai');
                const tariffeSnap = await getDoc(tariffeRef);
                
                let tariffe = { ...TARIFFE_DEFAULT };
                if (tariffeSnap.exists()) {
                    tariffe = { ...TARIFFE_DEFAULT, ...tariffeSnap.data() };
                }
                
                tariffe[tipoOperaio] = valore;
                tariffe.updatedAt = serverTimestamp();
                
                if (!tariffeSnap.exists()) {
                    tariffe.createdAt = serverTimestamp();
                }
                
                await setDoc(tariffeRef, tariffe);
                showAlert('Tariffa salvata con successo', 'success');
            } catch (error) {
                console.error('Errore salvataggio tariffa:', error);
                showAlert('Errore durante il salvataggio: ' + error.message, 'error');
                // Ripristina valore precedente
                await loadTariffe();
            }
        }
        
        // ========== Gestione Poderi ==========
        
        // Carica poderi
        async function loadPoderi() {
            if (!currentTenantId) return;
            
            try {
                const poderiCollection = collection(db, `tenants/${currentTenantId}/poderi`);
                const q = query(poderiCollection, orderBy('nome', 'asc'));
                const querySnapshot = await getDocs(q);
                
                poderiList = [];
                querySnapshot.forEach((docSnap) => {
                    poderiList.push({
                        id: docSnap.id,
                        ...docSnap.data()
                    });
                });
                
                renderPoderi();
            } catch (error) {
                console.error('Errore caricamento poderi:', error);
                showAlert('Errore caricamento poderi', 'error');
            }
        }
        
        // Render poderi
        function renderPoderi() {
            const container = document.getElementById('poderi-list');
            
            if (poderiList.length === 0) {
                container.innerHTML = '<p class="info-text">Nessun podere aggiunto. Clicca su "Aggiungi Podere" per iniziare.</p>';
                return;
            }
            
            container.innerHTML = poderiList.map(podere => {
                const escapedNome = escapeHtml(podere.nome || 'Senza nome');
                const escapedIndirizzo = escapeHtml(podere.indirizzo || '');
                const escapedNote = escapeHtml(podere.note || '');
                
                return `
                    <div class="list-item">
                        <div class="list-item-name" style="flex-direction: column; align-items: flex-start; gap: 5px;">
                            <div style="font-weight: 600; color: #2E8B57;">${escapedNome}</div>
                            ${escapedIndirizzo ? `<div style="font-size: 12px; color: #666;">üìç ${escapedIndirizzo}</div>` : ''}
                            ${escapedNote ? `<div style="font-size: 12px; color: #999;">${escapedNote}</div>` : ''}
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-info btn-small" onclick="editPodere('${podere.id}')" title="Modifica">‚úèÔ∏è Modifica</button>
                            <button class="btn btn-danger btn-small" onclick="confirmDeletePodere('${podere.id}')" title="Elimina">üóëÔ∏è Elimina</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Apri modal podere
        function openPodereModal(podereId = null) {
            currentPodereId = podereId;
            const modal = document.getElementById('podere-modal');
            const form = document.getElementById('podere-form');
            const title = document.getElementById('podere-modal-title');
            
            if (podereId) {
                title.textContent = 'Modifica Podere';
                const podere = poderiList.find(p => p.id === podereId);
                if (podere) {
                    document.getElementById('podere-nome').value = podere.nome || '';
                    document.getElementById('podere-indirizzo').value = podere.indirizzo || '';
                    document.getElementById('podere-note').value = podere.note || '';
                    
                    // Inizializza mappa se ci sono coordinate o indirizzo
                    if (window.googleMapsReadyPodere) {
                        setTimeout(() => {
                            if (podere.coordinate) {
                                // Se ci sono coordinate salvate, usa quelle
                                initPodereMap(podere.coordinate);
                            } else if (podere.indirizzo) {
                                // Se c'√® indirizzo ma non coordinate, inizializza mappa e cerca indirizzo
                                initPodereMap();
                                setTimeout(() => {
                                    searchPodereAddress(true);
                                }, 500);
                            } else {
                                // Nessuna coordinata n√© indirizzo, inizializza mappa vuota
                                initPodereMap();
                            }
                        }, 300);
                    }
                }
            } else {
                title.textContent = 'Aggiungi Podere';
                form.reset();
                // Mostra sempre la mappa quando si apre il modal
                setTimeout(() => {
                    initPodereMap();
                }, 300);
            }
            
            modal.classList.add('active');
        }
        
        // Chiudi modal podere
        function closePodereModal() {
            const modal = document.getElementById('podere-modal');
            modal.classList.remove('active');
            document.getElementById('podere-form').reset();
            currentPodereId = null;
            
            // Pulisci mappa
            if (podereMarker) {
                podereMarker.setMap(null);
                podereMarker = null;
            }
            if (podereMap) {
                podereMap = null;
            }
            document.getElementById('podere-map-container').style.display = 'none';
            const mapActions = document.getElementById('podere-map-actions');
            if (mapActions) {
                mapActions.style.display = 'none';
            }
        }
        
        // Inizializza mappa podere
        function initPodereMap(center = null) {
            const mapContainer = document.getElementById('podere-map-container');
            const mapDiv = document.getElementById('podere-map');
            
            if (!mapDiv) return;
            
            // Mostra sempre il container della mappa
            mapContainer.style.display = 'block';
            
            // Se Google Maps non √® ancora caricato, mostra messaggio e riprova dopo
            if (!window.google || !window.google.maps || !window.googleMapsReadyPodere) {
                mapDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-size: 14px;">Caricamento mappa...</div>';
                
                // Riprova dopo un po'
                setTimeout(() => {
                    if (window.google && window.google.maps && window.googleMapsReadyPodere) {
                        initPodereMap(center);
                    } else {
                        mapDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999; font-size: 14px; flex-direction: column; gap: 10px;"><div>‚ö†Ô∏è Google Maps non disponibile</div><div style="font-size: 12px;">La mappa verr√† caricata quando disponibile</div></div>';
                    }
                }, 1000);
                return;
            }
            
            // Se la mappa √® gi√† inizializzata, aggiorna solo il centro
            if (podereMap) {
                if (center) {
                    podereMap.setCenter(center);
                    podereMap.setZoom(17);
                    if (!podereMarker) {
                        setPodereMarker(center);
                    }
                }
                return;
            }
            
            try {
                const defaultCenter = center || { lat: 44.4949, lng: 11.3426 }; // Bologna area
                
                podereMap = new google.maps.Map(mapDiv, {
                    zoom: center ? 17 : 10,
                    center: defaultCenter,
                    mapTypeId: google.maps.MapTypeId.SATELLITE
                });
                
                // Aggiungi controlli per cambiare tipo mappa
                podereMap.setOptions({
                    mapTypeControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        mapTypeIds: [
                            google.maps.MapTypeId.SATELLITE,
                            google.maps.MapTypeId.HYBRID,
                            google.maps.MapTypeId.ROADMAP
                        ]
                    }
                });
                
                // Click sulla mappa per posizionare marker
                podereMap.addListener('click', function(event) {
                    setPodereMarker(event.latLng);
                });
                
                // Se c'√® un centro, posiziona marker
                if (center) {
                    setPodereMarker(center);
                }
            } catch (error) {
                console.error('Errore inizializzazione mappa podere:', error);
                mapDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #dc3545; font-size: 14px;">Errore caricamento mappa</div>';
            }
        }
        
        // Posiziona marker sulla mappa
        function setPodereMarker(position) {
            if (!podereMap || !window.google || !window.google.maps) return;
            
            // Rimuovi marker esistente
            if (podereMarker) {
                podereMarker.setMap(null);
            }
            
            // Crea nuovo marker
            podereMarker = new google.maps.Marker({
                map: podereMap,
                position: position,
                draggable: true,
                title: 'Posizione podere'
            });
            
            // Centra mappa sul marker
            podereMap.setCenter(position);
            podereMap.setZoom(17);
            
            // Mostra pulsante indicazioni
            const mapActions = document.getElementById('podere-map-actions');
            if (mapActions) {
                mapActions.style.display = 'block';
            }
            
            // Listener per drag marker
            podereMarker.addListener('dragend', function(event) {
                // Aggiorna indirizzo quando si sposta il marker
                reverseGeocodePodere(event.latLng);
            });
        }
        
        // Apri indicazioni stradali
        function openDirections() {
            if (!podereMarker) {
                showAlert('Posiziona prima un marker sulla mappa', 'error');
                return;
            }
            
            const position = podereMarker.getPosition();
            const lat = position.lat();
            const lng = position.lng();
            
            // Apri Google Maps con indicazioni verso questa posizione
            const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
            window.open(url, '_blank');
        }
        
        // Cerca indirizzo podere
        async function searchPodereAddress(useExistingValue = false) {
            if (!window.google || !window.google.maps || !window.googleMapsReadyPodere) {
                showAlert('Mappa non ancora caricata. Attendi qualche secondo.', 'error');
                return;
            }
            
            const indirizzoInput = document.getElementById('podere-indirizzo');
            const address = useExistingValue ? indirizzoInput.value.trim() : indirizzoInput.value.trim();
            
            if (!address) {
                showAlert('Inserisci un indirizzo da cercare', 'error');
                return;
            }
            
            // Inizializza mappa se non gi√† fatto
            if (!podereMap) {
                initPodereMap();
            }
            
            const geocoder = new google.maps.Geocoder();
            
            geocoder.geocode({ address: address }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    setPodereMarker(location);
                    
                    // Aggiorna indirizzo con quello completo trovato
                    indirizzoInput.value = results[0].formatted_address;
                    
                    showAlert('Indirizzo trovato! Marker posizionato sulla mappa.', 'success');
                } else {
                    showAlert('Indirizzo non trovato. Verifica di aver inserito un indirizzo valido.', 'error');
                }
            });
        }
        
        // Reverse geocoding (da coordinate a indirizzo)
        function reverseGeocodePodere(latLng) {
            if (!window.google || !window.google.maps) return;
            
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ location: latLng }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    const indirizzoInput = document.getElementById('podere-indirizzo');
                    indirizzoInput.value = results[0].formatted_address;
                }
            });
        }
        
        // Salva podere
        async function handleSavePodere(e) {
            e.preventDefault();
            
            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }
            
            const nome = document.getElementById('podere-nome').value.trim();
            if (!nome) {
                showAlert('Il nome podere √® obbligatorio', 'error');
                return;
            }
            
            const indirizzo = document.getElementById('podere-indirizzo').value.trim() || null;
            const note = document.getElementById('podere-note').value.trim() || null;
            
            // Ottieni coordinate dal marker se presente
            let coordinate = null;
            if (podereMarker) {
                const position = podereMarker.getPosition();
                coordinate = {
                    lat: position.lat(),
                    lng: position.lng()
                };
            }
            
            try {
                const poderiCollection = collection(db, `tenants/${currentTenantId}/poderi`);
                const podereData = {
                    nome,
                    indirizzo,
                    note,
                    coordinate: coordinate,
                    aggiornatoIl: serverTimestamp()
                };
                
                if (currentPodereId) {
                    // Modifica
                    const podereRef = doc(poderiCollection, currentPodereId);
                    await updateDoc(podereRef, podereData);
                    showAlert('Podere modificato con successo', 'success');
                } else {
                    // Crea
                    podereData.creatoIl = serverTimestamp();
                    await addDoc(poderiCollection, podereData);
                    showAlert('Podere aggiunto con successo', 'success');
                }
                
                closePodereModal();
                await loadPoderi();
            } catch (error) {
                console.error('Errore salvataggio podere:', error);
                showAlert('Errore durante il salvataggio: ' + error.message, 'error');
            }
        }
        
        // Modifica podere
        function editPodere(podereId) {
            openPodereModal(podereId);
        }
        
        // Conferma eliminazione podere
        async function confirmDeletePodere(podereId) {
            const podere = poderiList.find(p => p.id === podereId);
            if (!podere) return;
            
            // Verifica se il podere √® usato in terreni
            try {
                const terreniCollection = collection(db, `tenants/${currentTenantId}/terreni`);
                const q = query(terreniCollection, where('podere', '==', podere.nome));
                const querySnapshot = await getDocs(q);
                const numTerreni = querySnapshot.size;
                
                if (numTerreni > 0) {
                    if (!confirm(`Questo podere √® assegnato a ${numTerreni} terreno/i. Eliminare comunque?\n\nNota: I terreni perderanno l'assegnazione al podere.`)) {
                        return;
                    }
                }
            } catch (e) {
                console.warn('Errore verifica terreni:', e);
            }
            
            if (!confirm(`Sei sicuro di voler eliminare il podere "${podere.nome}"?`)) {
                return;
            }
            
            try {
                const podereRef = doc(db, `tenants/${currentTenantId}/poderi`, podereId);
                await deleteDoc(podereRef);
                showAlert('Podere eliminato con successo', 'success');
                await loadPoderi();
            } catch (error) {
                console.error('Errore eliminazione podere:', error);
                showAlert('Errore durante l\'eliminazione: ' + error.message, 'error');
            }
        }
        
        // Esponi funzioni globalmente
        window.handleSaveAzienda = handleSaveAzienda;
        window.handleSaveAccount = handleSaveAccount;
        window.handleChangePassword = handleChangePassword;
        window.addTipoLavoro = addTipoLavoro;
        window.removeTipoLavoro = removeTipoLavoro;
        window.updateSottocategorieDropdown = updateSottocategorieDropdown;
        window.updateTipiLavoroPredefinitiDropdown = updateTipiLavoroPredefinitiDropdown;
        window.onTipoLavoroPredeterminatoChange = onTipoLavoroPredeterminatoChange;
        window.saveTariffa = saveTariffa;
        window.saveTariffaProprietario = saveTariffaProprietario;
        window.openAddCategoriaTipoLavoroModal = function() {
            // TODO: Implementare modal per aggiungere categoria tipi lavoro
            showAlert('Funzionalit√† in sviluppo', 'info');
        };
        window.openAddSottocategoriaTipoLavoroModal = function() {
            // TODO: Implementare modal per aggiungere sottocategoria tipi lavoro
            showAlert('Funzionalit√† in sviluppo', 'info');
        };
        // Modal per aggiungere nuova categoria coltura
        function openAddCategoriaColturaModal() {
            const modal = document.getElementById('categoria-coltura-modal');
            if (modal) {
                modal.classList.add('active');
                document.getElementById('new-categoria-coltura-nome').value = '';
                document.getElementById('new-categoria-coltura-descrizione').value = '';
                document.getElementById('new-categoria-coltura-nome').focus();
            }
        }

        function closeAddCategoriaColturaModal() {
            const modal = document.getElementById('categoria-coltura-modal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        // Aggiungi nuova categoria coltura
        async function addCategoriaColtura() {
            const nomeInput = document.getElementById('new-categoria-coltura-nome');
            const descrizioneInput = document.getElementById('new-categoria-coltura-descrizione');
            const nome = nomeInput.value.trim();
            const descrizione = descrizioneInput.value.trim();

            if (!nome) {
                showAlert('Inserisci un nome per la categoria', 'error');
                return;
            }

            if (!currentTenantId) {
                showAlert('Tenant ID non disponibile', 'error');
                return;
            }

            try {
                // Verifica se categoria esiste gi√† (solo per colture)
                const categorieRef = collection(db, `tenants/${currentTenantId}/categorie`);
                const q = query(
                    categorieRef,
                    where('nome', '==', nome),
                    where('applicabileA', '==', 'colture')
                );
                const existingSnapshot = await getDocs(q);
                
                if (!existingSnapshot.empty) {
                    showAlert('Una categoria con questo nome esiste gi√†', 'error');
                    return;
                }

                // Genera codice dalla categoria
                const codice = nome
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '')
                    .replace(/[^a-z0-9]+/g, '_')
                    .replace(/^_+|_+$/g, '');

                // Verifica se codice esiste gi√†
                const qCodice = query(categorieRef, where('codice', '==', codice));
                const codiceSnapshot = await getDocs(qCodice);
                if (!codiceSnapshot.empty) {
                    showAlert('Una categoria con codice simile esiste gi√†. Prova con un nome diverso.', 'error');
                    return;
                }

                // Crea nuova categoria
                const nuovaCategoria = {
                    nome: nome,
                    codice: codice,
                    descrizione: descrizione || null,
                    applicabileA: 'colture',
                    predefinita: false,
                    ordine: 999, // Ultima posizione
                    creatoDa: auth.currentUser?.uid || 'system',
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp()
                };

                await addDoc(categorieRef, nuovaCategoria);

                nomeInput.value = '';
                descrizioneInput.value = '';
                closeAddCategoriaColturaModal();
                showAlert('Categoria aggiunta con successo', 'success');
                
                // Ricarica categorie e colture
                await loadCategorieColture();
                await loadColturePerCategoria();
            } catch (error) {
                console.error('Errore aggiunta categoria coltura:', error);
                showAlert('Errore durante l\'aggiunta: ' + error.message, 'error');
            }
        }

        window.addColtura = addColtura;
        window.removeColtura = removeColtura;
        window.openAddCategoriaColturaModal = openAddCategoriaColturaModal;
        window.closeAddCategoriaColturaModal = closeAddCategoriaColturaModal;
        window.addCategoriaColtura = addCategoriaColtura;
        window.updateColturePredefiniteDropdown = updateColturePredefiniteDropdown;
        window.onColturaPredeterminataChange = onColturaPredeterminataChange;
        window.openPodereModal = openPodereModal;
        window.closePodereModal = closePodereModal;
        window.handleSavePodere = handleSavePodere;
        window.editPodere = editPodere;
        window.confirmDeletePodere = confirmDeletePodere;
        window.searchPodereAddress = searchPodereAddress;
        window.openDirections = openDirections;
        
        // ========== Gestione Comunicazioni Squadra (Caposquadra) ==========
        
        let terreniList = [];
        let lavoriAttiviList = [];
        
        // Carica poderi per dropdown comunicazioni
        async function loadPoderiForComunicazioni() {
            if (!currentTenantId) return;
            
            try {
                const poderiCollection = collection(db, `tenants/${currentTenantId}/poderi`);
                const q = query(poderiCollection, orderBy('nome', 'asc'));
                const querySnapshot = await getDocs(q);
                
                const podereSelect = document.getElementById('comunicazione-podere');
                podereSelect.innerHTML = '<option value="">-- Seleziona podere --</option>';
                
                querySnapshot.forEach((docSnap) => {
                    const podere = docSnap.data();
                    const option = document.createElement('option');
                    option.value = podere.nome;
                    option.textContent = podere.nome;
                    option.dataset.podereId = docSnap.id;
                    option.dataset.coordinate = podere.coordinate ? JSON.stringify(podere.coordinate) : '';
                    podereSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Errore caricamento poderi per comunicazioni:', error);
            }
        }
        
        // Carica terreni per dropdown comunicazioni
        async function loadTerreniForComunicazioni() {
            if (!currentTenantId) return;
            
            try {
                const terreniCollection = collection(db, `tenants/${currentTenantId}/terreni`);
                const q = query(terreniCollection, orderBy('nome', 'asc'));
                const querySnapshot = await getDocs(q);
                
                terreniList = [];
                const terrenoSelect = document.getElementById('comunicazione-terreno');
                terrenoSelect.innerHTML = '<option value="">-- Seleziona terreno --</option>';
                
                querySnapshot.forEach((docSnap) => {
                    const terreno = docSnap.data();
                    terreniList.push({
                        id: docSnap.id,
                        ...terreno
                    });
                    
                    const option = document.createElement('option');
                    option.value = terreno.nome || '';
                    option.textContent = terreno.nome || 'Senza nome';
                    option.dataset.terrenoId = docSnap.id;
                    option.dataset.podere = terreno.podere || '';
                    terrenoSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Errore caricamento terreni per comunicazioni:', error);
            }
        }
        
        // Carica lavori attivi del caposquadra
        async function loadLavoriAttiviForComunicazioni() {
            if (!currentTenantId || !currentUserData) return;
            
            try {
                const lavoriCollection = collection(db, `tenants/${currentTenantId}/lavori`);
                const caposquadraId = currentUserData.id || auth.currentUser.uid;
                const q = query(
                    lavoriCollection,
                    where('caposquadraId', '==', caposquadraId)
                );
                const querySnapshot = await getDocs(q);
                
                lavoriAttiviList = [];
                const lavoroSelect = document.getElementById('comunicazione-lavoro');
                lavoroSelect.innerHTML = '<option value="">-- Seleziona lavoro per pre-compilare --</option>';
                
                querySnapshot.forEach((docSnap) => {
                    const lavoro = docSnap.data();
                    const stato = lavoro.stato || 'assegnato';
                    
                    // Solo lavori attivi (non completati e non annullati)
                    if (stato !== 'completato' && stato !== 'annullato' && stato !== 'completato_da_approvare') {
                        lavoriAttiviList.push({
                            id: docSnap.id,
                            ...lavoro
                        });
                        
                        const option = document.createElement('option');
                        option.value = docSnap.id;
                        option.textContent = lavoro.nome || 'Lavoro senza nome';
                        option.dataset.terrenoId = lavoro.terrenoId || '';
                        lavoroSelect.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Errore caricamento lavori per comunicazioni:', error);
            }
        }
        
        // Gestisce cambio selezione lavoro
        async function handleLavoroChange() {
            const lavoroSelect = document.getElementById('comunicazione-lavoro');
            const lavoroId = lavoroSelect.value;
            
            if (!lavoroId) return;
            
            const lavoro = lavoriAttiviList.find(l => l.id === lavoroId);
            if (!lavoro || !lavoro.terrenoId) return;
            
            try {
                // Carica terreno per ottenere podere
                const terrenoRef = doc(db, `tenants/${currentTenantId}/terreni`, lavoro.terrenoId);
                const terrenoDoc = await getDoc(terrenoRef);
                
                if (terrenoDoc.exists()) {
                    const terreno = terrenoDoc.data();
                    const podereNome = terreno.podere || '';
                    const terrenoNome = terreno.nome || '';
                    
                    // Pre-compila podere
                    const podereSelect = document.getElementById('comunicazione-podere');
                    if (podereNome) {
                        // Cerca l'opzione corrispondente
                        for (let i = 0; i < podereSelect.options.length; i++) {
                            if (podereSelect.options[i].value === podereNome) {
                                podereSelect.value = podereNome;
                                break;
                            }
                        }
                    }
                    
                    // Pre-compila terreno
                    const terrenoSelect = document.getElementById('comunicazione-terreno');
                    if (terrenoNome) {
                        terrenoSelect.value = terrenoNome;
                    }
                }
            } catch (error) {
                console.error('Errore caricamento terreno:', error);
            }
        }
        
        // Pre-compila form con il primo lavoro attivo
        async function precompilaDaPrimoLavoro() {
            if (lavoriAttiviList.length === 0) return;
            
            // Seleziona automaticamente il primo lavoro
            const lavoroSelect = document.getElementById('comunicazione-lavoro');
            if (lavoroSelect.options.length > 1) {
                lavoroSelect.value = lavoriAttiviList[0].id;
                await handleLavoroChange();
            }
        }
        
        window.handleLavoroChange = handleLavoroChange;
        
        // Ottieni squadra del caposquadra
        async function getSquadraCaposquadra() {
            if (!currentTenantId || !currentUserData) {
                console.warn('getSquadraCaposquadra: tenantId o userData mancanti');
                return [];
            }
            
            try {
                const caposquadraId = currentUserData.id || auth.currentUser.uid;

                const squadreCollection = collection(db, `tenants/${currentTenantId}/squadre`);
                const q = query(squadreCollection, where('caposquadraId', '==', caposquadraId));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    console.warn('Nessuna squadra trovata per caposquadraId:', caposquadraId);
                    return [];
                }
                
                // Prendi la prima squadra trovata
                const squadraDoc = querySnapshot.docs[0];
                const squadraData = squadraDoc.data();

                // Il campo corretto √® "operai", non "membri"
                return squadraData.operai || [];
            } catch (error) {
                console.error('Errore recupero squadra:', error);
                return [];
            }
        }
        
        // Invia comunicazione alla squadra
        async function handleSendComunicazione(e) {
            e.preventDefault();
            
            if (!currentUserData || !currentTenantId) {
                showAlert('Errore: dati utente non disponibili', 'error');
                return;
            }
            
            const podereSelect = document.getElementById('comunicazione-podere');
            const terrenoSelect = document.getElementById('comunicazione-terreno');
            const dataInput = document.getElementById('comunicazione-data');
            const orarioInput = document.getElementById('comunicazione-orario');
            const noteInput = document.getElementById('comunicazione-note');
            
            const podere = podereSelect.value.trim();
            const terreno = terrenoSelect.value.trim();
            const data = dataInput.value;
            const orario = orarioInput.value;
            const note = noteInput.value.trim();
            
            if (!podere || !terreno || !data || !orario) {
                showAlert('Compila tutti i campi obbligatori', 'error');
                return;
            }
            
            // Ottieni coordinate podere
            const podereOption = podereSelect.options[podereSelect.selectedIndex];
            const coordinatePodere = podereOption.dataset.coordinate ? JSON.parse(podereOption.dataset.coordinate) : null;
            
            try {
                // Ottieni membri squadra
                const membriSquadra = await getSquadraCaposquadra();
                
                if (membriSquadra.length === 0) {
                    showAlert('Nessun membro nella tua squadra', 'error');
                    return;
                }
                
                // Crea comunicazione
                const comunicazioneData = {
                    caposquadraId: currentUserData.id || auth.currentUser.uid,
                    caposquadraNome: `${currentUserData.nome || ''} ${currentUserData.cognome || ''}`.trim(),
                    podere: podere,
                    terreno: terreno,
                    data: new Date(data + 'T' + orario),
                    orario: orario,
                    note: note || null,
                    coordinatePodere: coordinatePodere,
                    destinatari: membriSquadra,
                    conferme: [],
                    stato: 'attiva',
                    createdAt: serverTimestamp()
                };
                
                const comunicazioniCollection = collection(db, `tenants/${currentTenantId}/comunicazioni`);
                await addDoc(comunicazioniCollection, comunicazioneData);
                
                showAlert('Comunicazione inviata alla squadra con successo!', 'success');
                
                // Reset form
                document.getElementById('comunicazione-form').reset();
                document.getElementById('comunicazione-orario').value = '07:00';
                
                // Ricarica lista comunicazioni
                await loadComunicazioniInviate();
            } catch (error) {
                console.error('Errore invio comunicazione:', error);
                showAlert('Errore durante l\'invio: ' + error.message, 'error');
            }
        }
        
        // Carica comunicazioni inviate
        async function loadComunicazioniInviate() {
            if (!currentTenantId || !currentUserData) return;
            
            try {
                const comunicazioniCollection = collection(db, `tenants/${currentTenantId}/comunicazioni`);
                // Usa solo where senza orderBy per evitare bisogno di indice composito
                // Ordineremo in memoria
                const q = query(
                    comunicazioniCollection,
                    where('caposquadraId', '==', currentUserData.id || auth.currentUser.uid)
                );
                const querySnapshot = await getDocs(q);
                
                // Converti in array e ordina per createdAt in memoria
                const comunicazioniArray = [];
                querySnapshot.forEach((docSnap) => {
                    const comm = docSnap.data();
                    comunicazioniArray.push({
                        id: docSnap.id,
                        ...comm,
                        createdAtValue: comm.createdAt?.toDate ? comm.createdAt.toDate() : new Date(comm.createdAt || 0)
                    });
                });
                
                // Ordina per data creazione (pi√π recenti prima)
                comunicazioniArray.sort((a, b) => {
                    const dateA = a.createdAtValue || new Date(0);
                    const dateB = b.createdAtValue || new Date(0);
                    return dateB - dateA; // Ordine decrescente
                });
                
                const container = document.getElementById('comunicazioni-list');
                
                if (comunicazioniArray.length === 0) {
                    container.innerHTML = '<p class="info-text">Nessuna comunicazione inviata.</p>';
                    return;
                }
                
                container.innerHTML = comunicazioniArray.map(comm => {
                    const dataCom = comm.data?.toDate ? comm.data.toDate() : new Date(comm.data);
                    const dataFormatted = dataCom.toLocaleDateString('it-IT', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    const oraFormatted = comm.orario || '07:00';
                    
                    const numDestinatari = comm.destinatari?.length || 0;
                    const numConferme = comm.conferme?.length || 0;
                    const percentualeConferme = numDestinatari > 0 ? Math.round((numConferme / numDestinatari) * 100) : 0;
                    
                    const statoBadge = comm.stato === 'attiva' ? 
                        '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">Attiva</span>' :
                        '<span style="background: #6c757d; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">Completata</span>';
                    
                    return `
                        <div class="list-item" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e9ecef; border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 600; color: #2E8B57; margin-bottom: 5px;">${escapeHtml(comm.podere)} - ${escapeHtml(comm.terreno)}</div>
                                    <div style="font-size: 14px; color: #666;">üìÖ ${dataFormatted} alle ${oraFormatted}</div>
                                    ${comm.note ? `<div style="font-size: 13px; color: #999; margin-top: 5px;">${escapeHtml(comm.note)}</div>` : ''}
                                </div>
                                ${statoBadge}
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e9ecef;">
                                <div style="font-size: 12px; color: #666;">
                                    Conferme: ${numConferme}/${numDestinatari} (${percentualeConferme}%)
                                </div>
                                ${comm.coordinatePodere ? `<a href="https://www.google.com/maps/dir/?api=1&destination=${comm.coordinatePodere.lat},${comm.coordinatePodere.lng}" target="_blank" style="color: #2E8B57; text-decoration: none; font-size: 14px;">üìç Indicazioni</a>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Errore caricamento comunicazioni:', error);
                const container = document.getElementById('comunicazioni-list');
                container.innerHTML = '<p class="info-text">Errore caricamento comunicazioni.</p>';
            }
        }
        
        // Imposta data di default a domani
        function setDefaultDate() {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const dateString = tomorrow.toISOString().split('T')[0];
            const dataInput = document.getElementById('comunicazione-data');
            if (dataInput) {
                dataInput.value = dateString;
                dataInput.min = dateString; // Non permettere date passate
            }
        }
        
        // Chiama setDefaultDate quando la pagina √® caricata
        if (document.getElementById('comunicazione-data')) {
            setDefaultDate();
        }
        
        window.handleSendComunicazione = handleSendComunicazione;
    </script>
    <!-- Tony widget (assistente su tutte le pagine) -->
    <!-- Tony widget (assistente su tutte le pagine) -->
    <script>
    (function() {
      var path = (window.location.pathname || '').replace(/\\/g, '/');
      var isGH = path.indexOf('/gfv-platform/') >= 0;
      var base = isGH ? (window.location.origin + '/gfv-platform/core') : (path.indexOf('/core/admin/') >= 0 ? '../' : (path.indexOf('/modules/') >= 0 ? '../../../core/' : ''));
      var sep = (base && !base.endsWith('/')) ? '/' : '';
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = (base ? base + sep : '') + 'styles/tony-widget.css';
      document.head.appendChild(link);
      var s = document.createElement('script');
      s.type = 'module';
      s.src = (base ? base + sep : '') + 'js/tony-widget-standalone.js';
      document.body.appendChild(s);
    })();
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - GFV Platform</title>
    <link rel="manifest" href="/gfv-platform/manifest.json">
    <meta name="theme-color" content="#2E8B57">
    <link rel="stylesheet" href="styles/dashboard.css">
    <link rel="stylesheet" href="https://unpkg.com/intro.js/minified/introjs.min.css">
</head>
<body>
    <div class="dashboard-container">
        <div class="dashboard-header">
            <div>
                <h1>üåæ GFV Platform</h1>
                <div class="user-info" id="user-info">Caricamento...</div>
                <div class="user-roles" id="user-roles"></div>
            </div>
            <div class="header-actions">
                <a href="admin/impostazioni-standalone.html" class="btn btn-primary" style="text-decoration: none; display: inline-flex; align-items: center; gap: 8px;">
                    <span>‚öôÔ∏è</span>
                    <span>Impostazioni</span>
                </a>
                <a href="../documentazione-utente/index.html" target="_blank" rel="noopener" class="btn btn-primary" data-tour="guide-link" style="text-decoration: none; display: inline-flex; align-items: center; gap: 8px;">
                    <span>üìò</span>
                    <span>Guide</span>
                </a>
                <button class="btn btn-primary" id="dashboard-tour-button" type="button" style="display: inline-flex; align-items: center; gap: 8px;">
                    <span>üß≠</span>
                    <span>Tour</span>
                </button>
                <a href="admin/gestisci-utenti-standalone.html" id="invita-collaboratore-link" class="btn btn-primary" style="text-decoration: none; display: none; align-items: center; gap: 8px; font-size: 13px; padding: 8px 16px;">
                    <span>‚ûï</span>
                    <span>Invita Collaboratore</span>
                </a>
                <button class="logout-button" id="logout-button">Logout</button>
            </div>
        </div>

        <div id="dashboard-content" class="dashboard-content">
            <div class="loading">Caricamento dashboard...</div>
        </div>
    </div>

    <script src="https://unpkg.com/intro.js/minified/intro.min.js"></script>
    <!-- Load JavaScript modules -->
    <script src="js/config-loader.js"></script>
    <script src="js/dashboard-utils.js"></script>
    <script src="js/dashboard-sections.js"></script>
    
    <!-- Load Firebase and Google Maps config from external files -->
    <!-- Fallback: usa raw GitHub se il file locale non √® disponibile (per GitHub Pages) -->
    <script>
        // Carica il config prima di continuare
        window.GFVConfigLoader.loadConfig().then(() => {
            // Carica anche Google Maps config e poi carica l'API
            return window.GFVConfigLoader.loadGoogleMapsConfig();
        }).then(() => {
            // Config caricato, ora possiamo inizializzare tutto
            console.log('‚úÖ Config caricato correttamente');
            console.log('üîë Google Maps API Key disponibile?', typeof window.GOOGLE_MAPS_API_KEY !== 'undefined' ? 'S√¨: ' + window.GOOGLE_MAPS_API_KEY.substring(0, 20) + '...' : 'No');
            // NON chiamare loadGoogleMapsAPI() qui - viene chiamata nello script module dopo che Firebase √® inizializzato
        }).catch(error => {
            console.error('Errore caricamento config:', error);
            document.getElementById('dashboard-content').innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <h3 style="color: #dc3545;">‚ö†Ô∏è Errore Configurazione</h3>
                    <p>File di configurazione Firebase non trovato.</p>
                    <p>Errore: ${error.message}</p>
                </div>
            `;
        });
    </script>
    
    <!-- Firebase SDK da CDN -->
    <script type="module">
        // Usa funzioni dai moduli caricati
        const { waitForConfig, waitForGoogleMapsConfig, loadGoogleMapsAPI } = window.GFVConfigLoader;
        const { 
            roleNames, 
            normalizeRole, 
            normalizeRoles, 
            escapeHtml, 
            hasRole, 
            hasAnyRole, 
            hasOnlyCoreModules, 
            hasManodoperaModule 
        } = window.GFVDashboardUtils;
        const {
            createCoreBaseSection,
            createAdminSection,
            createManagerSection,
            createAmministrazioneCard,
            createStatisticheCard,
            createTerreniCard,
            createManagerManodoperaSection,
            createManagerLavoriSection,
            createDiarioDaLavoriSection,
            createCaposquadraSection,
            createOperaioSection
        } = window.GFVDashboardSections;
        const TOUR_STORAGE_KEY = 'gfv_dashboard_tour_v1';

        // Carica configurazione
        const firebaseConfig = await waitForConfig();

        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, getDoc, doc, updateDoc, setDoc, serverTimestamp, collection, getDocs, query, where, orderBy, limit, addDoc, Timestamp, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Inizializza Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Carica Google Maps API se disponibile (dopo che Firebase √® inizializzato)
        // Aspetta che anche il config Google Maps sia caricato
        let googleMapsReady = false;
        
        // Aspetta che il config Google Maps sia caricato, poi carica l'API
        await waitForGoogleMapsConfig();
        console.log('‚úÖ Config Google Maps disponibile, carico API...');
        
        // Carica Google Maps API dopo che il config √® stato caricato
        loadGoogleMapsAPI().then(() => {
            googleMapsReady = true;
        });

        // Conta utenti del tenant
        let tenantUserCount = 1; // Default a 1 (solo utente corrente)

        // Renderizza dashboard in base ai ruoli e moduli
        async function renderDashboard(userData, availableModules = []) {
            const container = document.getElementById('dashboard-content');
            container.innerHTML = '';

            const ruoli = userData.ruoli || [];
            const isCoreOnly = hasOnlyCoreModules(availableModules);
            const hasAdvancedModules = !isCoreOnly;
            const hasManodopera = hasManodoperaModule(availableModules);

            // Sezione Amministrazione: mostra SOLO quando Manodopera √® attivo
            // Quando Manodopera √® disattivato, NON mostrare alcuna sezione Amministrazione
            // (le funzionalit√† amministrative avanzate sono parte del modulo Manodopera)
            
            // Gestisci visibilit√† link "Invita Collaboratore" nell'header
            const invitaLink = document.getElementById('invita-collaboratore-link');
            if (invitaLink) {
                // Mostra solo se Manodopera √® attivo E utente √® Manager/Amministratore
                if (hasManodopera && (hasRole(userData, 'manager') || hasRole(userData, 'amministratore'))) {
                    invitaLink.style.display = 'inline-flex';
                } else {
                    invitaLink.style.display = 'none';
                }
            }

            // CORE BASE: Mostra solo se l'utente NON √® solo Operaio o solo Caposquadra
            // ECCEZIONE: Se Manager o Amministratore ha modulo Manodopera attivo, nascondi Core Base (diario manuale e statistiche)
            const isOnlyOperaio = ruoli.length === 1 && hasRole(userData, 'operaio');
            const isOnlyCaposquadra = ruoli.length === 1 && hasRole(userData, 'caposquadra');
            const isManagerOrAdminWithManodopera = hasManodopera && (hasRole(userData, 'manager') || hasRole(userData, 'amministratore'));
            const shouldShowCoreBase = !isOnlyOperaio && !isOnlyCaposquadra && !isManagerOrAdminWithManodopera;
            
            if (shouldShowCoreBase) {
                const coreSection = createCoreBaseSection(userData, isCoreOnly, availableModules);
                if (coreSection) {
                    coreSection.setAttribute('data-tour-section', 'core-base');
                    container.appendChild(coreSection);
                }
                
                // Mappa Aziendale per Manager anche senza moduli avanzati
                // Versione semplificata quando Manodopera NON √® attivo
                if (hasRole(userData, 'manager') || hasRole(userData, 'amministratore')) {
                    const mapSection = createMappaAziendaleSection(userData, hasManodopera);
                    if (mapSection) {
                        mapSection.setAttribute('data-tour-section', 'mappa');
                        container.appendChild(mapSection);
                    }
                }
            }

            // Card Amministrazione (per Manager e Amministratore con Manodopera attivo)
            // Mostra SOLO quando Manodopera √® attivo
                if (hasManodopera && (hasRole(userData, 'manager') || hasRole(userData, 'amministratore'))) {
                // Layout superiore: 3 card a sinistra, mappa a destra
                const topRow = document.createElement('div');
                topRow.className = 'dashboard-top-row';
                topRow.setAttribute('data-tour-section', 'panoramica');
                
                const topLeft = document.createElement('div');
                topLeft.className = 'dashboard-top-left';
                
                // Card Amministrazione
                topLeft.appendChild(createAmministrazioneCard());
                
                // Card Statistiche
                topLeft.appendChild(createStatisticheCard());
                
                // Card Terreni
                const terreniCard = createTerreniCard();
                topLeft.appendChild(terreniCard);
                
                // Mappa a destra (versione completa con Manodopera)
                const topRight = document.createElement('div');
                topRight.className = 'dashboard-top-right';
                const mappaSection = createMappaAziendaleSection(userData, hasManodopera);
                if (mappaSection) {
                    mappaSection.setAttribute('data-tour-section', 'mappa');
                    topRight.appendChild(mappaSection);
                }
                
                topRow.appendChild(topLeft);
                topRow.appendChild(topRight);
                container.appendChild(topRow);
            }

            // Ruoli avanzati: solo se ci sono moduli avanzati attivi
            if (hasAdvancedModules) {
                // Sezione Manager: layout diverso se ha Manodopera attivo
                if (hasRole(userData, 'manager')) {
                    if (hasManodopera) {
                        // Gestione Manodopera (dopo la riga superiore)
                        const managerManodoperaSection = createManagerManodoperaSection(userData, availableModules, loadManagerManodoperaStats, loadRecentLavoriManagerManodopera);
                        if (managerManodoperaSection) {
                            managerManodoperaSection.setAttribute('data-tour-section', 'gestione-manodopera');
                            container.appendChild(managerManodoperaSection);
                        }
                        
                        // Diario da Lavori (sezione principale per Manager con Manodopera)
                        const diarioSection = createDiarioDaLavoriSection(userData, availableModules);
                        if (diarioSection) {
                            diarioSection.setAttribute('data-tour-section', 'diario');
                            container.appendChild(diarioSection);
                        }
                        setTimeout(() => {
                            loadDiarioDaLavori(userData);
                        }, 50);
                    } else {
                        // Layout normale per Manager senza Manodopera
                        // NOTA: La mappa √® gi√† stata aggiunta nella sezione Core Base (riga 875)
                        // quindi non la aggiungiamo qui per evitare duplicazioni
                        const managerSection = createManagerSection(userData, isCoreOnly, availableModules, loadCoreStatsForManager);
                        if (managerSection) {
                            managerSection.setAttribute('data-tour-section', 'gestione-core');
                            container.appendChild(managerSection);
                        }
                    }
                }
                
                // Sezione per Amministratore che non √® Manager (solo se modulo Manodopera attivo)
                if (hasManodopera && hasRole(userData, 'amministratore') && !hasRole(userData, 'manager')) {
                    // Gestione Manodopera (dopo la riga superiore)
                    const adminManodoperaSection = createManagerManodoperaSection(userData, availableModules, loadManagerManodoperaStats, loadRecentLavoriManagerManodopera);
                    if (adminManodoperaSection) {
                        adminManodoperaSection.setAttribute('data-tour-section', 'gestione-manodopera');
                        container.appendChild(adminManodoperaSection);
                    }
                    
                    // Sezione Diario da Lavori per Amministratore (non Manager)
                    const diarioSection = createDiarioDaLavoriSection(userData, availableModules);
                    if (diarioSection) {
                        diarioSection.setAttribute('data-tour-section', 'diario');
                        container.appendChild(diarioSection);
                    }
                    setTimeout(() => {
                        loadDiarioDaLavori(userData);
                    }, 50);
                }

                // Sezione Caposquadra (solo con modulo Manodopera attivo)
                if (hasRole(userData, 'caposquadra')) {
                    if (hasManodopera) {
                        const caposquadraSection = createCaposquadraSection(userData, isCoreOnly, availableModules, loadCaposquadraStats, loadRecentLavoriCaposquadra, loadComunicazioneRapida);
                        if (caposquadraSection) {
                            caposquadraSection.setAttribute('data-tour-section', 'caposquadra');
                            container.appendChild(caposquadraSection);
                        }
                    } else {
                        // Messaggio se caposquadra ma modulo Manodopera non attivo
                        const noModuleSection = document.createElement('div');
                        noModuleSection.className = 'dashboard-section';
                        noModuleSection.innerHTML = `
                            <h2><span class="section-icon">üë∑</span> Gestione Squadra</h2>
                            <div class="empty-state" style="padding: 40px;">
                                <div class="empty-state-icon">‚ö†Ô∏è</div>
                                <h3>Modulo Manodopera non attivo</h3>
                                <p>Per accedere alle funzionalit√† di gestione squadra e lavori, √® necessario attivare il modulo Manodopera.</p>
                                <p style="margin-top: 10px; font-size: 14px; color: #666;">Contatta l'amministratore per attivare il modulo.</p>
                            </div>
                        `;
                        container.appendChild(noModuleSection);
                    }
                }

                // Sezione Operaio (solo con modulo Manodopera attivo)
                if (hasRole(userData, 'operaio')) {
                    if (hasManodopera) {
                        const operaioSection = createOperaioSection(userData, isCoreOnly, availableModules, loadComunicazioniOperaio, loadLavoriOggiOperaio, loadStatisticheOreOperaio);
                        if (operaioSection) {
                            operaioSection.setAttribute('data-tour-section', 'operaio');
                            container.appendChild(operaioSection);
                        }
                    } else {
                        // Messaggio se operaio ma modulo Manodopera non attivo
                        const noModuleSection = document.createElement('div');
                        noModuleSection.className = 'dashboard-section';
                        noModuleSection.innerHTML = `
                            <h2><span class="section-icon">üîß</span> I Miei Lavori</h2>
                            <div class="empty-state" style="padding: 40px;">
                                <div class="empty-state-icon">‚ö†Ô∏è</div>
                                <h3>Modulo Manodopera non attivo</h3>
                                <p>Per accedere alle funzionalit√† di gestione lavori e segnatura ore, √® necessario attivare il modulo Manodopera.</p>
                                <p style="margin-top: 10px; font-size: 14px; color: #666;">Contatta l'amministratore per attivare il modulo.</p>
                            </div>
                        `;
                        container.appendChild(noModuleSection);
                    }
                }
            }

            // Se non ha ruoli, mostra messaggio
            if (ruoli.length === 0) {
                container.innerHTML = `
                    <div class="dashboard-section" style="grid-column: 1 / -1;">
                        <div class="empty-state">
                            <div class="empty-state-icon">‚ö†Ô∏è</div>
                            <h2>Nessun ruolo assegnato</h2>
                            <p>Contatta l'amministratore per ottenere i permessi necessari.</p>
                        </div>
                    </div>
                `;
            }

            setupDashboardTour(userData);
        }
        
        // Le funzioni create* sono state estratte nel modulo dashboard-sections.js
        // Rimangono solo le funzioni di caricamento dati e createMappaAziendaleSection
        
        // Carica statistiche amministrazione (per Manager e Amministratore con Manodopera)
        async function loadAmministrazioneStats(availableModules) {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                // Carica utenti del tenant
                const usersCollection = collection(db, 'users');
                const usersQuery = query(usersCollection, where('tenantId', '==', tenantId));
                const usersSnapshot = await getDocs(usersQuery);
                const totaleUtenti = usersSnapshot.size;
                const statUtentiEl = document.getElementById('stat-utenti-amministrazione');
                if (statUtentiEl) statUtentiEl.textContent = totaleUtenti;
                
                // Carica dati tenant per moduli e piano
                const tenantDoc = await getDoc(doc(db, 'tenants', tenantId));
                if (tenantDoc.exists()) {
                    const tenantData = tenantDoc.data();
                    const moduli = tenantData.modules || [];
                    const piano = tenantData.piano || 'starter';
                    
                    const statModuliEl = document.getElementById('stat-moduli-amministrazione');
                    if (statModuliEl) {
                        // Filtra 'core' se presente (√® sempre incluso)
                        const moduliAvanzati = moduli.filter(m => m !== 'core');
                        const moduliCount = moduliAvanzati.length;
                        if (moduliCount > 0) {
                            statModuliEl.textContent = `${moduliCount} moduli`;
                        } else {
                            statModuliEl.textContent = 'Solo Core';
                        }
                    }
                    
                    const statPianoEl = document.getElementById('stat-piano-amministrazione');
                    if (statPianoEl) {
                        const pianoNames = {
                            'starter': 'Starter',
                            'professional': 'Professional',
                            'enterprise': 'Enterprise'
                        };
                        statPianoEl.textContent = pianoNames[piano] || piano;
                    }
                }
            } catch (error) {
                console.error('Errore caricamento statistiche amministrazione:', error);
            }
        }
        
        // Carica statistiche amministratore (legacy, mantenuta per compatibilit√†)
        async function loadAdminStats(availableModules) {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                // Carica utenti del tenant
                const usersCollection = collection(db, 'users');
                const usersQuery = query(usersCollection, where('tenantId', '==', tenantId));
                const usersSnapshot = await getDocs(usersQuery);
                const totaleUtenti = usersSnapshot.size;
                const statUtentiEl = document.getElementById('stat-utenti-admin');
                if (statUtentiEl) statUtentiEl.textContent = totaleUtenti;
                
                // Carica dati tenant per moduli e piano
                const tenantDoc = await getDoc(doc(db, 'tenants', tenantId));
                if (tenantDoc.exists()) {
                    const tenantData = tenantDoc.data();
                    const moduli = tenantData.modules || [];
                    const piano = tenantData.piano || 'starter';
                    
                    const statModuliEl = document.getElementById('stat-moduli-admin');
                    if (statModuliEl) {
                        const moduliCount = moduli.length;
                        statModuliEl.textContent = moduliCount > 0 ? `${moduliCount} moduli` : 'Solo Core';
                    }
                    
                    const statPianoEl = document.getElementById('stat-piano-admin');
                    if (statPianoEl) {
                        const pianoNames = {
                            'starter': 'Starter',
                            'professional': 'Professional',
                            'enterprise': 'Enterprise'
                        };
                        statPianoEl.textContent = pianoNames[piano] || piano;
                    }
                }
            } catch (error) {
                console.error('Errore caricamento statistiche admin:', error);
            }
        }

        // Le funzioni create* duplicate sono state rimosse - ora sono nel modulo dashboard-sections.js
        // Rimangono solo le funzioni di caricamento dati e createMappaAziendaleSection

        // Sezione Mappa Aziendale (Manager)
        function setupDashboardTour(userData) {
            try {
                const tourButton = document.getElementById('dashboard-tour-button');
                if (tourButton) {
                    tourButton.onclick = () => startDashboardTour(userData, true);
                }

                const hasRoles = Array.isArray(userData.ruoli) && userData.ruoli.length > 0;
                const hasSeenTour = localStorage.getItem(TOUR_STORAGE_KEY);

                if (!hasSeenTour && hasRoles) {
                    setTimeout(() => startDashboardTour(userData, false), 2200);
                }
            } catch (error) {
                console.warn('Tour onboarding non disponibile:', error);
            }
        }

        function startDashboardTour(userData, triggeredManually) {
            if (typeof introJs === 'undefined') {
                if (triggeredManually) {
                    alert('Tour non disponibile al momento. Riprova pi√π tardi.');
                }
                return;
            }

            const steps = buildDashboardTourSteps(userData);
            if (!steps.length) {
                if (triggeredManually) {
                    alert('Tour non disponibile per questa vista.');
                }
                return;
            }

            const tour = introJs();
            tour.setOptions({
                steps,
                showProgress: true,
                showBullets: false,
                exitOnOverlayClick: true,
                nextLabel: 'Avanti',
                prevLabel: 'Indietro',
                skipLabel: '√ó',
                doneLabel: 'Fatto'
            }).oncomplete(() => {
                try { localStorage.setItem(TOUR_STORAGE_KEY, 'done'); } catch (error) {}
            }).onexit(() => {
                try { localStorage.setItem(TOUR_STORAGE_KEY, 'done'); } catch (error) {}
            }).start();
        }

        function buildDashboardTourSteps(userData) {
            const steps = [];

            const header = document.querySelector('.dashboard-header');
            if (header) {
                steps.push({
                    element: header,
                    title: 'Benvenuto!',
                    intro: 'Qui trovi i tuoi dati, i ruoli assegnati e tutte le scorciatoie principali: Impostazioni, Guide, Tour e Logout.'
                });
            }

            const guideLink = document.querySelector('[data-tour="guide-link"]');
            if (guideLink) {
                steps.push({
                    element: guideLink,
                    title: 'Guide sempre disponibili',
                    intro: 'Il portale documentazione ospita Primi Passi, FAQ e guide per ruolo/funzionalit√† (incluso il modulo Parco Macchine).'
                });
            }

            const tourButton = document.getElementById('dashboard-tour-button');
            if (tourButton) {
                steps.push({
                    element: tourButton,
                    title: 'Tour interattivo',
                    intro: 'Puoi riaprire questo tour guidato in qualunque momento cliccando qui.'
                });
            }

            const coreBase = document.querySelector('[data-tour-section="core-base"]');
            if (coreBase) {
                steps.push({
                    element: coreBase,
                    title: 'Sezione Core Base',
                    intro: 'Da qui accedi a Terreni, Diario attivit√† e statistiche rapide quando il modulo Manodopera non √® attivo.'
                });
            }

            const panoramica = document.querySelector('[data-tour-section="panoramica"]');
            if (panoramica) {
                steps.push({
                    element: panoramica,
                    title: 'Panoramica aziendale',
                    intro: 'Card rapide per Amministrazione, Statistiche e Terreni con la mappa aziendale sempre visibile sulla destra.'
                });
            }

            const mappaSection = document.querySelector('[data-tour-section="mappa"]');
            if (mappaSection) {
                steps.push({
                    element: mappaSection,
                    title: 'Mappa Aziendale',
                    intro: 'Visualizza terreni, zone lavorate e indicatori stato lavori. I filtri in alto ti permettono di concentrarti su un podere o una coltura.'
                });
            }

            const manodoperaSection = document.querySelector('[data-tour-section="gestione-manodopera"]');
            if (manodoperaSection) {
                steps.push({
                    element: manodoperaSection,
                    title: 'Gestione Manodopera',
                    intro: 'Sezione dedicata a Manager/Amministratori per creare lavori, monitorare squadre, validare ore e vedere statistiche operative.'
                });
            }

            const diarioSection = document.querySelector('[data-tour-section="diario"]');
            if (diarioSection) {
                steps.push({
                    element: diarioSection,
                    title: 'Diario da Lavori',
                    intro: 'Riepilogo automatico delle attivit√† generate dalle ore validate: utile per controllare l‚Äôavanzamento reale.'
                });
            }

            const caposquadraSection = document.querySelector('[data-tour-section="caposquadra"]');
            if (caposquadraSection) {
                steps.push({
                    element: caposquadraSection,
                    title: 'Dashboard Caposquadra',
                    intro: 'Qui il caposquadra gestisce comunicazioni rapide, validazione ore e pu√≤ controllare i lavori assegnati.'
                });
            }

            const operaioSection = document.querySelector('[data-tour-section="operaio"]');
            if (operaioSection) {
                steps.push({
                    element: operaioSection,
                    title: 'Dashboard Operaio',
                    intro: 'Qui gli operai trovano lavori del giorno, comunicazioni e un riepilogo delle loro ore.'
                });
            }

            const manutenzioniSection = document.getElementById('manutenzioni-scadenza-section');
            if (manutenzioniSection && window.getComputedStyle(manutenzioniSection).display !== 'none') {
                steps.push({
                    element: manutenzioniSection,
                    title: 'Modulo Parco Macchine',
                    intro: 'Con il modulo Parco Macchine attivo controlli qui manutenzioni imminenti e guasti. Ogni segnalazione aggiorna anche i lavori collegati.'
                });
            }

            steps.push({
                title: 'Serve altro?',
                intro: 'Per workflow completi (Parco Macchine, Bilancio, Tenant) approfondisci sempre nella sezione ‚Äúüìò Guide‚Äù. Buon lavoro!'
            });

            return steps;
        }
        // hasManodopera: se true, mostra versione completa con overlay lavori, filtri avanzati, indicatori
        // se false, mostra versione semplificata solo con terreni
        function createMappaAziendaleSection(userData, hasManodopera = false) {
            const section = document.createElement('div');
            section.className = 'dashboard-section';
            // Non occupa tutta la larghezza quando √® nella riga superiore
            section.style.height = '100%';
            section.style.display = 'flex';
            section.style.flexDirection = 'column';
            
            // Versione completa con Manodopera: include filtri avanzati, overlay lavori, indicatori
            if (hasManodopera) {
                section.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px; gap: 20px;">
                        <div style="flex: 1;">
                            <h2 style="margin: 0;"><span class="section-icon">üó∫Ô∏è</span> Vista Mappa Aziendale</h2>
                            <p style="color: #666; margin-top: 5px; margin-bottom: 0; font-size: 14px;">
                                Visualizza tutti i terreni dell'azienda con i loro confini geolocalizzati sulla mappa satellitare
                            </p>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                <label for="filtro-podere" style="font-size: 12px; color: #666; font-weight: 500;">Podere</label>
                                <select id="filtro-podere" class="mappa-filtro-select" title="Filtra per podere">
                                    <option value="">Tutti i poderi</option>
                                </select>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                <label for="filtro-coltura" style="font-size: 12px; color: #666; font-weight: 500;">Coltura</label>
                                <select id="filtro-coltura" class="mappa-filtro-select" title="Filtra per coltura">
                                    <option value="">Tutte le colture</option>
                                </select>
                            </div>
                            <button id="toggle-overlay-lavori" class="mappa-control-btn" title="Mostra/Nascondi zone lavorate" style="margin-top: 20px;">
                                <span>üë∑</span> Zone Lavorate
                            </button>
                            <button id="toggle-indicatori-lavori" class="mappa-control-btn" title="Mostra/Nascondi indicatori stato lavori" style="margin-top: 20px;">
                                <span>üìç</span> Indicatori Lavori
                            </button>
                        </div>
                    </div>
                    <div id="mappa-aziendale-container" class="mappa-container" style="flex: 1; min-height: 500px; width: 100%;">
                        <div class="mappa-loading">
                            <div>Caricamento mappa...</div>
                        </div>
                    </div>
                `;
                
                // Carica versione completa con Manodopera
                setTimeout(() => {
                    loadMappaAziendale(userData, true);
                }, 500);
            } else {
                // Versione semplificata senza Manodopera: solo terreni, nessun filtro avanzato, nessun overlay
                section.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h2 style="margin: 0;"><span class="section-icon">üó∫Ô∏è</span> Vista Mappa Aziendale</h2>
                        <p style="color: #666; margin-top: 5px; margin-bottom: 0; font-size: 14px;">
                            Visualizza tutti i terreni dell'azienda con i loro confini geolocalizzati sulla mappa satellitare
                        </p>
                    </div>
                    <div id="mappa-aziendale-container" class="mappa-container" style="flex: 1; min-height: 500px; width: 100%;">
                        <div class="mappa-loading">
                            <div>Caricamento mappa...</div>
                        </div>
                    </div>
                `;
                
                // Carica versione semplificata senza Manodopera
                setTimeout(() => {
                    loadMappaAziendale(userData, false);
                }, 500);
            }
            
            return section;
        }

        // Carica e visualizza terreni sulla mappa
        // hasManodopera: se true, carica versione completa con overlay lavori, filtri avanzati, indicatori
        // se false, carica versione semplificata solo con terreni
        async function loadMappaAziendale(userData, hasManodopera = false) {
            const container = document.getElementById('mappa-aziendale-container');
            if (!container) {
                console.warn('Container mappa non trovato');
                return;
            }

            try {
                console.log('üó∫Ô∏è Inizio caricamento mappa aziendale...');
                
                // Verifica che Google Maps sia caricato
                if (!googleMapsReady) {
                    console.log('‚è≥ Google Maps non pronto, attendo caricamento...');
                    await window.GFVConfigLoader.loadGoogleMapsAPI();
                }

                // Aspetta che Google Maps sia completamente disponibile
                let attempts = 0;
                const maxAttempts = 50; // 5 secondi
                while ((typeof google === 'undefined' || !google.maps) && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }

                if (typeof google === 'undefined' || !google.maps) {
                    console.error('‚ùå Google Maps non disponibile dopo attesa');
                    container.innerHTML = `
                        <div class="mappa-loading">
                            <h3 style="color: #dc3545; margin-bottom: 15px;">‚ö†Ô∏è Google Maps non disponibile</h3>
                            <p>Per visualizzare la mappa √® necessario configurare una chiave API di Google Maps valida.</p>
                            <p style="margin-top: 10px; font-size: 12px; color: #666;">
                                Verifica che la chiave API sia configurata correttamente nel file di configurazione.
                            </p>
                        </div>
                    `;
                    return;
                }

                console.log('‚úÖ Google Maps pronto, procedo con caricamento terreni...');

                const user = auth.currentUser;
                if (!user || !userData || !userData.tenantId) {
                    container.innerHTML = `
                        <div class="mappa-loading">
                            <p>Errore: dati utente non disponibili</p>
                        </div>
                    `;
                    return;
                }

                // Carica terreni
                const terreniCollection = collection(db, `tenants/${userData.tenantId}/terreni`);
                const terreniSnapshot = await getDocs(terreniCollection);
                
                const terreni = [];
                terreniSnapshot.forEach((docSnap) => {
                    const data = docSnap.data();
                    if (data.polygonCoords && Array.isArray(data.polygonCoords) && data.polygonCoords.length >= 3) {
                        terreni.push({
                            id: docSnap.id,
                            nome: data.nome || 'Terreno senza nome',
                            superficie: data.superficie || null,
                            coltura: data.coltura || null,
                            podere: data.podere || null,
                            polygonCoords: data.polygonCoords,
                            coordinate: data.coordinate || null,
                            note: data.note || ''
                        });
                    }
                });

                console.log(`üìä Trovati ${terreni.length} terreni con mappa tracciata`);

                if (terreni.length === 0) {
                    container.innerHTML = `
                        <div class="mappa-loading">
                            <h3 style="color: #666; margin-bottom: 15px;">üìã Nessun terreno con mappa</h3>
                            <p>Non ci sono terreni con confini tracciati sulla mappa.</p>
                            <p style="margin-top: 10px;">
                                <a href="terreni-standalone.html" style="color: #2E8B57; text-decoration: underline;">
                                    Vai alla gestione terreni per tracciare i confini
                                </a>
                            </p>
                        </div>
                    `;
                    return;
                }

                // Inizializza mappa
                console.log('üó∫Ô∏è Creazione elemento mappa...');
                console.log('üìê Dimensioni container:', container.offsetWidth, 'x', container.offsetHeight);
                
                // Assicurati che il container abbia dimensioni corrette
                if (container.offsetWidth === 0 || container.offsetHeight === 0) {
                    console.warn('‚ö†Ô∏è Container senza dimensioni, aspetto...');
                    // Aspetta che il container abbia dimensioni
                    await new Promise(resolve => setTimeout(resolve, 200));
                    console.log('üìê Dimensioni container dopo attesa:', container.offsetWidth, 'x', container.offsetHeight);
                }
                
                const mapDiv = document.createElement('div');
                mapDiv.style.width = '100%';
                mapDiv.style.height = '100%';
                mapDiv.style.minHeight = '500px'; // Altezza minima per assicurare che la mappa sia visibile
                mapDiv.style.display = 'block'; // Assicura che sia un block element
                container.innerHTML = '';
                container.appendChild(mapDiv);
                
                // Aspetta che il DOM sia aggiornato prima di creare la mappa
                await new Promise(resolve => setTimeout(resolve, 50));
                console.log('üìê Dimensioni mapDiv dopo inserimento:', mapDiv.offsetWidth, 'x', mapDiv.offsetHeight);
                
                console.log('üó∫Ô∏è Inizializzazione Google Maps...');

                // Calcola bounds per zoom automatico
                const bounds = new google.maps.LatLngBounds();
                terreni.forEach(terreno => {
                    terreno.polygonCoords.forEach(coord => {
                        const latLng = new google.maps.LatLng(coord.lat, coord.lng);
                        bounds.extend(latLng);
                    });
                });

                // Crea mappa
                console.log('üó∫Ô∏è Creazione istanza Google Maps...');
                const map = new google.maps.Map(mapDiv, {
                    center: bounds.getCenter(),
                    zoom: 12,
                    mapTypeId: google.maps.MapTypeId.SATELLITE,
                    mapTypeControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.TOP_RIGHT
                    },
                    zoomControl: true,
                    streetViewControl: false,
                    fullscreenControl: true
                });
                console.log('‚úÖ Mappa Google Maps creata con successo!');
                
                // Forza resize della mappa per assicurarsi che venga renderizzata correttamente
                setTimeout(() => {
                    google.maps.event.trigger(map, 'resize');
                    console.log('üîÑ Resize mappa triggerato');
                }, 100);

                // Funzione per zoom intelligente con padding
                function fitBoundsWithPadding(boundsToFit, paddingPixels = 50) {
                    if (!boundsToFit) {
                        return;
                    }
                    
                    // Verifica che bounds sia valido
                    try {
                        const ne = boundsToFit.getNorthEast();
                        const sw = boundsToFit.getSouthWest();
                        
                        if (!ne || !sw) {
                            return;
                        }
                        
                        const latDiff = ne.lat() - sw.lat();
                        const lngDiff = ne.lng() - sw.lng();
                        
                        // Verifica che bounds non sia vuoto
                        if (latDiff === 0 && lngDiff === 0) {
                            // Bounds vuoto, usa centro con zoom di default
                            const center = boundsToFit.getCenter();
                            if (center) {
                                map.setCenter(center);
                                map.setZoom(15);
                            }
                            return;
                        }
                        
                        // Espandi bounds per aggiungere padding
                        const latPadding = latDiff * (paddingPixels / 1000); // Converti pixel in gradi approssimativi
                        const lngPadding = lngDiff * (paddingPixels / 1000);
                        
                        const expandedBounds = new google.maps.LatLngBounds(
                            new google.maps.LatLng(sw.lat() - latPadding, sw.lng() - lngPadding),
                            new google.maps.LatLng(ne.lat() + latPadding, ne.lng() + lngPadding)
                        );
                        
                        // Se bounds √® troppo piccolo (terreno singolo o molto piccolo), usa zoom pi√π ravvicinato
                        if (latDiff < 0.0005 || lngDiff < 0.0005) {
                            // Terreno molto piccolo: zoom pi√π ravvicinato
                            const center = expandedBounds.getCenter();
                            map.setCenter(center);
                            map.setZoom(18);
                            return;
                        }
                        
                        // Se bounds √® molto grande (molti terreni sparsi), usa zoom pi√π lontano
                        if (latDiff > 0.1 || lngDiff > 0.1) {
                            // Area molto grande: usa padding maggiore
                            const largeLatPadding = latDiff * 0.1;
                            const largeLngPadding = lngDiff * 0.1;
                            expandedBounds.extend(new google.maps.LatLng(sw.lat() - largeLatPadding, sw.lng() - largeLngPadding));
                            expandedBounds.extend(new google.maps.LatLng(ne.lat() + largeLatPadding, ne.lng() + largeLngPadding));
                        }
                        
                        // Applica fitBounds con bounds espansi
                        map.fitBounds(expandedBounds);
                    } catch (error) {
                        console.warn('Errore fitBounds:', error);
                        // Fallback: usa centro e zoom di default
                        try {
                            const center = boundsToFit.getCenter();
                            if (center) {
                                map.setCenter(center);
                                map.setZoom(15);
                            }
                        } catch (e) {
                            console.error('Errore fallback zoom:', e);
                        }
                    }
                }

                // Fit bounds iniziale con padding - aspetta che la mappa sia pronta
                google.maps.event.addListenerOnce(map, 'idle', function() {
                    console.log('üó∫Ô∏è Mappa idle, applico fitBounds...');
                    fitBoundsWithPadding(bounds, 50);
                    console.log('‚úÖ FitBounds applicato');
                });
                
                // Gestisci ridimensionamento finestra per mantenere mappa responsive
                let resizeTimeout;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(function() {
                        if (map && bounds) {
                            google.maps.event.trigger(map, 'resize');
                            // Aspetta che il resize sia completato prima di applicare fitBounds
                            setTimeout(() => {
                                fitBoundsWithPadding(bounds, 50);
                            }, 100);
                        }
                    }, 250);
                });

                // Colori per colture (palette colori)
                const colturaColors = {
                    'Vite': '#8B4513', // Marrone
                    'Frutteto': '#FFD700', // Oro
                    'Seminativo': '#90EE90', // Verde chiaro
                    'Orto': '#32CD32', // Verde lime
                    'Prato': '#228B22', // Verde foresta
                    'Olivo': '#556B2F', // Oliva scuro
                    'Agrumeto': '#FFA500', // Arancione
                    'Bosco': '#2F4F2F', // Verde scuro
                    'Default': '#2E8B57' // Verde GFV
                };

                // Estrai poderi e colture uniche per i filtri - SOLO se Manodopera √® attivo
                const poderiUnici = [...new Set(terreni.map(t => t.podere).filter(p => p))].sort();
                const coltureUniche = [...new Set(terreni.map(t => t.coltura).filter(c => c))].sort();

                // Popola dropdown filtri - SOLO se Manodopera √® attivo
                const filtroPodereSelect = hasManodopera ? document.getElementById('filtro-podere') : null;
                const filtroColturaSelect = hasManodopera ? document.getElementById('filtro-coltura') : null;
                
                if (hasManodopera && filtroPodereSelect) {
                    poderiUnici.forEach(podere => {
                        const option = document.createElement('option');
                        option.value = podere;
                        option.textContent = podere;
                        filtroPodereSelect.appendChild(option);
                    });
                }

                if (hasManodopera && filtroColturaSelect) {
                    coltureUniche.forEach(coltura => {
                        const option = document.createElement('option');
                        option.value = coltura;
                        option.textContent = coltura;
                        filtroColturaSelect.appendChild(option);
                    });
                }

                // Crea poligoni per ogni terreno
                const polygons = [];
                const infoWindows = [];
                let terrenoPolygonsMap = new Map(); // Mappa terreno.id -> polygon per filtraggio

                terreni.forEach((terreno, index) => {
                    const coords = terreno.polygonCoords.map(c => 
                        new google.maps.LatLng(c.lat, c.lng)
                    );

                    const coltura = terreno.coltura || 'Default';
                    const color = colturaColors[coltura] || colturaColors['Default'];
                    const fillColor = color + '80'; // Aggiungi trasparenza
                    const strokeColor = color;

                    // Crea poligono
                    const polygon = new google.maps.Polygon({
                        paths: coords,
                        strokeColor: strokeColor,
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: fillColor,
                        fillOpacity: 0.35,
                        map: map,
                        terrain: {
                            id: terreno.id,
                            nome: terreno.nome,
                            superficie: terreno.superficie,
                            coltura: terreno.coltura,
                            podere: terreno.podere,
                            note: terreno.note
                        }
                    });

                    polygons.push(polygon);
                    terrenoPolygonsMap.set(terreno.id, polygon);

                    // Crea info window
                    const infoContent = `
                        <div class="mappa-info-window">
                            <h3>${escapeHtml(terreno.nome)}</h3>
                            ${terreno.podere ? `<p><strong>Podere:</strong> ${escapeHtml(terreno.podere)}</p>` : ''}
                            ${terreno.coltura ? `<p><strong>Coltura:</strong> ${escapeHtml(terreno.coltura)}</p>` : ''}
                            ${terreno.superficie ? `<p><strong>Superficie:</strong> ${terreno.superficie.toFixed(2)} ha</p>` : ''}
                            ${terreno.note ? `<p><strong>Note:</strong> ${escapeHtml(terreno.note)}</p>` : ''}
                            <p style="margin-top: 10px;">
                                <a href="terreni-standalone.html" style="color: #2E8B57; text-decoration: underline; font-size: 12px;">
                                    Vedi dettagli ‚Üí
                                </a>
                            </p>
                        </div>
                    `;

                    const infoWindow = new google.maps.InfoWindow({
                        content: infoContent
                    });

                    infoWindows.push(infoWindow);

                    // Click sul poligono per aprire info window
                    polygon.addListener('click', function(event) {
                        // Chiudi tutte le altre info windows
                        infoWindows.forEach(iw => iw.close());
                        infoWindow.setPosition(event.latLng);
                        infoWindow.open(map);
                    });
                });

                // Carica e disegna zone lavorate (overlay lavori attivi) - SOLO se Manodopera √® attivo
                let overlayLavoriVisible = false;
                const zoneLavoratePolygons = [];
                const zoneLavorateInfoWindows = [];
                
                // Indicatori stato lavori - SOLO se Manodopera √® attivo
                let indicatoriLavoriVisible = false;
                const lavoroMarkers = [];
                const lavoroMarkersInfoWindows = [];
                
                async function loadAndDrawZoneLavorate() {
                    // Se Manodopera non √® attivo, non caricare zone lavorate
                    if (!hasManodopera) return;
                    try {
                        // Carica lavori attivi
                        const lavoriCollection = collection(db, `tenants/${userData.tenantId}/lavori`);
                        const lavoriSnapshot = await getDocs(lavoriCollection);
                        
                        const lavoriAttivi = [];
                        lavoriSnapshot.forEach(doc => {
                            const data = doc.data();
                            const stato = data.stato || 'assegnato';
                            // Lavori attivi: non completati e non annullati
                            if (stato !== 'completato' && stato !== 'annullato') {
                                lavoriAttivi.push({
                                    id: doc.id,
                                    nome: data.nome || 'Lavoro senza nome',
                                    terrenoId: data.terrenoId,
                                    tipoLavoro: data.tipoLavoro || '',
                                    caposquadraId: data.caposquadraId,
                                    dataInizio: data.dataInizio?.toDate ? data.dataInizio.toDate() : (data.dataInizio ? new Date(data.dataInizio) : null),
                                    stato: stato,
                                    percentualeCompletamento: data.percentualeCompletamento || 0
                                });
                            }
                        });

                        // Per ogni lavoro attivo, carica le zone lavorate
                        for (const lavoro of lavoriAttivi) {
                            try {
                                const zoneRef = collection(db, `tenants/${userData.tenantId}/lavori/${lavoro.id}/zoneLavorate`);
                                const zoneSnapshot = await getDocs(zoneRef);
                                
                                zoneSnapshot.forEach(zonaDoc => {
                                    const zonaData = zonaDoc.data();
                                    if (zonaData.coordinate && Array.isArray(zonaData.coordinate) && zonaData.coordinate.length >= 3) {
                                        // Converti coordinate in LatLng
                                        const coords = zonaData.coordinate.map(c => 
                                            new google.maps.LatLng(c.lat, c.lng)
                                        );

                                        // Crea poligono verde semi-trasparente per zona lavorata
                                        const zonaPolygon = new google.maps.Polygon({
                                            paths: coords,
                                            strokeColor: '#00FF00', // Verde brillante
                                            strokeOpacity: 0.9,
                                            strokeWeight: 3,
                                            fillColor: '#00FF00',
                                            fillOpacity: 0.4,
                                            map: overlayLavoriVisible ? map : null, // Visibile solo se toggle attivo
                                            zIndex: 100, // Sopra i terreni
                                            zona: {
                                                id: zonaDoc.id,
                                                lavoroId: lavoro.id,
                                                lavoroNome: lavoro.nome,
                                                tipoLavoro: lavoro.tipoLavoro,
                                                data: zonaData.data?.toDate ? zonaData.data.toDate() : (zonaData.data ? new Date(zonaData.data) : null),
                                                superficieHa: zonaData.superficieHa || 0,
                                                note: zonaData.note || ''
                                            }
                                        });

                                        zoneLavoratePolygons.push(zonaPolygon);

                                        // Crea info window per zona lavorata
                                        const zonaInfoContent = `
                                            <div class="mappa-info-window">
                                                <h3>${escapeHtml(lavoro.nome)}</h3>
                                                ${lavoro.tipoLavoro ? `<p><strong>Tipo Lavoro:</strong> ${escapeHtml(lavoro.tipoLavoro)}</p>` : ''}
                                                ${zonaData.data ? `<p><strong>Data:</strong> ${zonaData.data.toDate ? zonaData.data.toDate().toLocaleDateString('it-IT') : new Date(zonaData.data).toLocaleDateString('it-IT')}</p>` : ''}
                                                ${zonaData.superficieHa ? `<p><strong>Superficie:</strong> ${zonaData.superficieHa.toFixed(2)} ha</p>` : ''}
                                                ${lavoro.percentualeCompletamento ? `<p><strong>Completamento:</strong> ${lavoro.percentualeCompletamento.toFixed(1)}%</p>` : ''}
                                                ${zonaData.note ? `<p><strong>Note:</strong> ${escapeHtml(zonaData.note)}</p>` : ''}
                                                <p style="margin-top: 10px;">
                                                    <a href="admin/gestione-lavori-standalone.html" style="color: #2E8B57; text-decoration: underline; font-size: 12px;">
                                                        Vedi dettagli lavoro ‚Üí
                                                    </a>
                                                </p>
                                            </div>
                                        `;

                                        const zonaInfoWindow = new google.maps.InfoWindow({
                                            content: zonaInfoContent
                                        });

                                        zoneLavorateInfoWindows.push(zonaInfoWindow);

                                        // Click sul poligono zona lavorata
                                        zonaPolygon.addListener('click', function(event) {
                                            // Chiudi tutte le altre info windows
                                            infoWindows.forEach(iw => iw.close());
                                            zoneLavorateInfoWindows.forEach(iw => iw.close());
                                            zonaInfoWindow.setPosition(event.latLng);
                                            zonaInfoWindow.open(map);
                                        });
                                    }
                                });
                            } catch (error) {
                                console.warn(`Errore caricamento zone lavorate per lavoro ${lavoro.id}:`, error);
                            }
                        }
                    } catch (error) {
                        console.error('Errore caricamento lavori attivi:', error);
                    }
                }

                // Carica zone lavorate - SOLO se Manodopera √® attivo
                if (hasManodopera) {
                    await loadAndDrawZoneLavorate();
                }

                // Funzione per calcolare centroide di un poligono
                function getPolygonCenter(coords) {
                    let latSum = 0;
                    let lngSum = 0;
                    coords.forEach(coord => {
                        latSum += coord.lat;
                        lngSum += coord.lng;
                    });
                    return {
                        lat: latSum / coords.length,
                        lng: lngSum / coords.length
                    };
                }

                // Funzione per caricare e disegnare indicatori stato lavori - SOLO se Manodopera √® attivo
                async function loadAndDrawIndicatoriLavori() {
                    // Se Manodopera non √® attivo, non caricare indicatori lavori
                    if (!hasManodopera) return;
                    try {
                        // Carica lavori attivi
                        const lavoriCollection = collection(db, `tenants/${userData.tenantId}/lavori`);
                        const lavoriSnapshot = await getDocs(lavoriCollection);
                        
                        const lavoriConProgressi = [];
                        const oggi = new Date();
                        oggi.setHours(0, 0, 0, 0);
                        
                        lavoriSnapshot.forEach(doc => {
                            const data = doc.data();
                            const stato = data.stato || 'assegnato';
                            // Solo lavori attivi (non completati e non annullati)
                            if (stato !== 'completato' && stato !== 'annullato') {
                                // Calcola giorni effettivi se non presente
                                let giorniEffettivi = data.giorniEffettivi || 0;
                                if (data.dataInizio && data.durataPrevista) {
                                    const dataInizio = data.dataInizio?.toDate 
                                        ? data.dataInizio.toDate() 
                                        : (data.dataInizio ? new Date(data.dataInizio) : null);
                                    if (dataInizio) {
                                        const dataInizioSenzaOra = new Date(dataInizio);
                                        dataInizioSenzaOra.setHours(0, 0, 0, 0);
                                        giorniEffettivi = Math.max(0, Math.floor((oggi - dataInizioSenzaOra) / (1000 * 60 * 60 * 24)) + 1);
                                    }
                                }
                                
                                lavoriConProgressi.push({
                                    id: doc.id,
                                    nome: data.nome || 'Lavoro senza nome',
                                    terrenoId: data.terrenoId,
                                    tipoLavoro: data.tipoLavoro || '',
                                    caposquadraId: data.caposquadraId,
                                    dataInizio: data.dataInizio?.toDate ? data.dataInizio.toDate() : (data.dataInizio ? new Date(data.dataInizio) : null),
                                    durataPrevista: data.durataPrevista || 0,
                                    stato: stato,
                                    percentualeCompletamento: data.percentualeCompletamento || 0,
                                    statoProgresso: data.statoProgresso || null, // "in_anticipo" | "in_tempo" | "in_ritardo"
                                    superficieTotaleLavorata: data.superficieTotaleLavorata || 0,
                                    giorniEffettivi: giorniEffettivi
                                });
                            }
                        });

                        // Per ogni lavoro, calcola stato progresso se mancante e crea marker
                        for (const lavoro of lavoriConProgressi) {
                            try {
                                // Trova terreno associato
                                const terreno = terreni.find(t => t.id === lavoro.terrenoId);
                                if (!terreno || !terreno.polygonCoords || terreno.polygonCoords.length < 3) {
                                    continue; // Salta se terreno non trovato o senza coordinate
                                }
                                
                                // Calcola stato progresso se non presente e abbiamo i dati necessari
                                if (!lavoro.statoProgresso && lavoro.dataInizio && lavoro.durataPrevista && lavoro.giorniEffettivi > 0) {
                                    const superficieTotale = terreno.superficie || 0;
                                    const superficieLavorata = lavoro.superficieTotaleLavorata || 0;
                                    
                                    // Calcola percentuale completamento se non presente
                                    let percentualeCompletamento = lavoro.percentualeCompletamento;
                                    if (!percentualeCompletamento && superficieTotale > 0) {
                                        percentualeCompletamento = (superficieLavorata / superficieTotale) * 100;
                                    }
                                    
                                    // Calcola percentuale tempo
                                    const percentualeTempo = (lavoro.giorniEffettivi / lavoro.durataPrevista) * 100;
                                    const tolleranza = 10; // Tolleranza del 10%
                                    
                                    // Determina stato progresso
                                    if (percentualeCompletamento > percentualeTempo + tolleranza) {
                                        lavoro.statoProgresso = 'in_anticipo';
                                    } else if (percentualeCompletamento < percentualeTempo - tolleranza) {
                                        lavoro.statoProgresso = 'in_ritardo';
                                    } else {
                                        lavoro.statoProgresso = 'in_tempo';
                                    }
                                    
                                    // Aggiorna anche percentuale completamento se calcolata
                                    if (!lavoro.percentualeCompletamento && superficieTotale > 0) {
                                        lavoro.percentualeCompletamento = percentualeCompletamento;
                                    }
                                }

                                // Calcola centro del terreno
                                const centro = getPolygonCenter(terreno.polygonCoords);
                                const position = new google.maps.LatLng(centro.lat, centro.lng);

                                // Determina colore marker in base allo stato progresso
                                let markerColor = '#2E8B57'; // Default verde GFV
                                let markerIcon = 'üü¢';
                                let markerLabel = '';

                                if (lavoro.statoProgresso === 'in_ritardo') {
                                    markerColor = '#DC3545'; // Rosso
                                    markerIcon = 'üî¥';
                                    markerLabel = 'R';
                                } else if (lavoro.statoProgresso === 'in_anticipo') {
                                    markerColor = '#28A745'; // Verde brillante
                                    markerIcon = 'üü¢';
                                    markerLabel = 'A';
                                } else if (lavoro.statoProgresso === 'in_tempo') {
                                    markerColor = '#FFC107'; // Giallo/Ambra
                                    markerIcon = 'üü°';
                                    markerLabel = 'T';
                                } else {
                                    // Se non c'√® stato progresso, usa colore in base allo stato lavoro
                                    if (lavoro.stato === 'in_corso') {
                                        markerColor = '#17A2B8'; // Blu
                                        markerIcon = 'üîµ';
                                        markerLabel = 'C';
                                    } else {
                                        markerColor = '#6C757D'; // Grigio
                                        markerIcon = '‚ö™';
                                        markerLabel = 'A';
                                    }
                                }

                                // Crea marker personalizzato con icona SVG
                                const markerIconUrl = `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
                                        <circle cx="16" cy="16" r="14" fill="${markerColor}" stroke="white" stroke-width="2"/>
                                        <text x="16" y="22" font-size="16" font-weight="bold" fill="white" text-anchor="middle">${markerLabel}</text>
                                    </svg>
                                `)}`;

                                const marker = new google.maps.Marker({
                                    position: position,
                                    map: indicatoriLavoriVisible ? map : null,
                                    icon: {
                                        url: markerIconUrl,
                                        scaledSize: new google.maps.Size(32, 32),
                                        anchor: new google.maps.Point(16, 16)
                                    },
                                    title: `${lavoro.nome} - ${lavoro.statoProgresso || lavoro.stato}`,
                                    zIndex: 200, // Sopra zone lavorate e terreni
                                    lavoro: {
                                        id: lavoro.id,
                                        nome: lavoro.nome,
                                        tipoLavoro: lavoro.tipoLavoro,
                                        terrenoNome: terreno.nome,
                                        stato: lavoro.stato,
                                        statoProgresso: lavoro.statoProgresso,
                                        percentualeCompletamento: lavoro.percentualeCompletamento,
                                        superficieTotaleLavorata: lavoro.superficieTotaleLavorata,
                                        giorniEffettivi: lavoro.giorniEffettivi,
                                        durataPrevista: lavoro.durataPrevista,
                                        dataInizio: lavoro.dataInizio
                                    }
                                });

                                lavoroMarkers.push(marker);

                                // Crea info window per marker lavoro
                                const statoProgressoFormattato = lavoro.statoProgresso 
                                    ? (lavoro.statoProgresso === 'in_anticipo' ? 'üü¢ In anticipo' : 
                                       lavoro.statoProgresso === 'in_tempo' ? 'üü° In tempo' : 
                                       'üî¥ In ritardo')
                                    : '‚è≥ Non disponibile';

                                const statoLavoroFormattato = lavoro.stato === 'in_corso' ? 'üîÑ In corso' :
                                                              lavoro.stato === 'assegnato' ? 'üìã Assegnato' :
                                                              lavoro.stato;

                                const lavoroInfoContent = `
                                    <div class="mappa-info-window">
                                        <h3>${escapeHtml(lavoro.nome)}</h3>
                                        <p><strong>Terreno:</strong> ${escapeHtml(terreno.nome)}</p>
                                        ${lavoro.tipoLavoro ? `<p><strong>Tipo Lavoro:</strong> ${escapeHtml(lavoro.tipoLavoro)}</p>` : ''}
                                        <p><strong>Stato:</strong> ${statoLavoroFormattato}</p>
                                        <p><strong>Progresso:</strong> ${statoProgressoFormattato}</p>
                                        ${lavoro.percentualeCompletamento ? `<p><strong>Completamento:</strong> ${lavoro.percentualeCompletamento.toFixed(1)}%</p>` : ''}
                                        ${lavoro.superficieTotaleLavorata ? `<p><strong>Superficie Lavorata:</strong> ${lavoro.superficieTotaleLavorata.toFixed(2)} ha</p>` : ''}
                                        ${lavoro.dataInizio ? `<p><strong>Data Inizio:</strong> ${lavoro.dataInizio.toLocaleDateString('it-IT')}</p>` : ''}
                                        ${lavoro.durataPrevista ? `<p><strong>Durata Prevista:</strong> ${lavoro.durataPrevista} giorni</p>` : ''}
                                        ${lavoro.giorniEffettivi ? `<p><strong>Giorni Trascorsi:</strong> ${lavoro.giorniEffettivi}</p>` : ''}
                                        <p style="margin-top: 10px;">
                                            <a href="admin/gestione-lavori-standalone.html" style="color: #2E8B57; text-decoration: underline; font-size: 12px;">
                                                Vedi dettagli lavoro ‚Üí
                                            </a>
                                        </p>
                                    </div>
                                `;

                                const lavoroInfoWindow = new google.maps.InfoWindow({
                                    content: lavoroInfoContent
                                });

                                lavoroMarkersInfoWindows.push(lavoroInfoWindow);

                                // Click sul marker per aprire info window
                                marker.addListener('click', function() {
                                    // Chiudi tutte le altre info windows
                                    infoWindows.forEach(iw => iw.close());
                                    zoneLavorateInfoWindows.forEach(iw => iw.close());
                                    lavoroMarkersInfoWindows.forEach(iw => iw.close());
                                    lavoroInfoWindow.open(map, marker);
                                });
                            } catch (error) {
                                console.warn(`Errore creazione marker per lavoro ${lavoro.id}:`, error);
                            }
                        }
                    } catch (error) {
                        console.error('Errore caricamento indicatori lavori:', error);
                    }
                }

                // Carica indicatori lavori - SOLO se Manodopera √® attivo
                if (hasManodopera) {
                    await loadAndDrawIndicatoriLavori();
                }

                // Funzione per filtrare terreni visualizzati - SOLO se Manodopera √® attivo (filtri avanzati)
                function applyFilters() {
                    // Se Manodopera non √® attivo, non ci sono filtri avanzati
                    if (!hasManodopera) return;
                    
                    const podereFiltro = filtroPodereSelect ? filtroPodereSelect.value : '';
                    const colturaFiltro = filtroColturaSelect ? filtroColturaSelect.value : '';
                    
                    let terreniVisibili = 0;
                    const boundsFiltro = new google.maps.LatLngBounds();
                    
                    terreni.forEach(terreno => {
                        const polygon = terrenoPolygonsMap.get(terreno.id);
                        if (!polygon) return;
                        
                        // Applica filtri
                        const matchPodere = !podereFiltro || terreno.podere === podereFiltro;
                        const matchColtura = !colturaFiltro || terreno.coltura === colturaFiltro;
                        
                        if (matchPodere && matchColtura) {
                            polygon.setMap(map);
                            terreniVisibili++;
                            // Estendi bounds per zoom automatico sui terreni visibili
                            terreno.polygonCoords.forEach(coord => {
                                boundsFiltro.extend(new google.maps.LatLng(coord.lat, coord.lng));
                            });
                        } else {
                            polygon.setMap(null);
                        }
                    });
                    
                    // Aggiorna zoom se ci sono terreni visibili
                    if (terreniVisibili > 0 && boundsFiltro.getNorthEast()) {
                        fitBoundsWithPadding(boundsFiltro, 50);
                    }
                    
                    // Aggiorna legenda
                    updateLegenda(podereFiltro, colturaFiltro);
                }

                // Funzione per aggiornare legenda in base ai filtri
                function updateLegenda(podereFiltro, colturaFiltro) {
                    // Trova colture visibili dopo filtri (se Manodopera attivo) o tutte le colture (se non attivo)
                    const coltureVisibili = [...new Set(
                        terreni
                            .filter(t => {
                                if (hasManodopera) {
                                    // Con Manodopera: applica filtri
                                    const matchPodere = !podereFiltro || t.podere === podereFiltro;
                                    const matchColtura = !colturaFiltro || t.coltura === colturaFiltro;
                                    return matchPodere && matchColtura;
                                } else {
                                    // Senza Manodopera: mostra tutte le colture
                                    return true;
                                }
                            })
                            .map(t => t.coltura)
                            .filter(c => c)
                    )];
                    
                    // Rimuovi legenda esistente
                    const legendaEsistente = container.querySelector('.mappa-legenda');
                    if (legendaEsistente) {
                        legendaEsistente.remove();
                    }
                    
                    // Crea nuova legenda se ci sono colture visibili o zone lavorate (solo con Manodopera)
                    if (coltureVisibili.length > 0 || (hasManodopera && zoneLavoratePolygons.length > 0)) {
                        const legendaDiv = document.createElement('div');
                        legendaDiv.className = 'mappa-legenda';
                        legendaDiv.innerHTML = `
                            <h4>Legenda</h4>
                            ${coltureVisibili.length > 0 ? `
                                <div style="margin-bottom: 15px;">
                                    <strong style="font-size: 11px; color: #666;">Colture:</strong>
                                    ${coltureVisibili.map(coltura => {
                                        const color = colturaColors[coltura] || colturaColors['Default'];
                                        return `
                                            <div class="mappa-legenda-item">
                                                <div class="mappa-legenda-color" style="background-color: ${color};"></div>
                                                <span>${escapeHtml(coltura)}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                    ${terreni.some(t => {
                                        if (hasManodopera) {
                                            const matchPodere = !podereFiltro || t.podere === podereFiltro;
                                            const matchColtura = !colturaFiltro || t.coltura === colturaFiltro;
                                            return matchPodere && matchColtura && !t.coltura;
                                        } else {
                                            return !t.coltura;
                                        }
                                    }) ? `
                                        <div class="mappa-legenda-item">
                                            <div class="mappa-legenda-color" style="background-color: ${colturaColors['Default']};"></div>
                                            <span>Non specificato</span>
                                        </div>
                                    ` : ''}
                                </div>
                            ` : ''}
                            ${hasManodopera && zoneLavoratePolygons.length > 0 ? `
                                <div style="margin-top: ${coltureVisibili.length > 0 ? '15px' : '0'}; padding-top: ${coltureVisibili.length > 0 ? '15px' : '0'}; ${coltureVisibili.length > 0 ? 'border-top: 1px solid #ddd;' : ''}">
                                    <strong style="font-size: 11px; color: #666;">Zone Lavorate:</strong>
                                    <div class="mappa-legenda-item">
                                        <div class="mappa-legenda-color" style="background-color: #00FF00; border: 2px solid #00FF00;"></div>
                                        <span>Zone lavorate attive</span>
                                    </div>
                                </div>
                            ` : ''}
                            ${hasManodopera && lavoroMarkers.length > 0 ? `
                                <div style="margin-top: ${(coltureVisibili.length > 0 || zoneLavoratePolygons.length > 0) ? '15px' : '0'}; padding-top: ${(coltureVisibili.length > 0 || zoneLavoratePolygons.length > 0) ? '15px' : '0'}; ${(coltureVisibili.length > 0 || zoneLavoratePolygons.length > 0) ? 'border-top: 1px solid #ddd;' : ''}">
                                    <strong style="font-size: 11px; color: #666;">Indicatori Lavori:</strong>
                                    <div class="mappa-legenda-item">
                                        <span style="font-size: 16px; margin-right: 5px;">üî¥</span>
                                        <span>In ritardo</span>
                                    </div>
                                    <div class="mappa-legenda-item">
                                        <span style="font-size: 16px; margin-right: 5px;">üü°</span>
                                        <span>In tempo</span>
                                    </div>
                                    <div class="mappa-legenda-item">
                                        <span style="font-size: 16px; margin-right: 5px;">üü¢</span>
                                        <span>In anticipo</span>
                                    </div>
                                    <div class="mappa-legenda-item">
                                        <span style="font-size: 16px; margin-right: 5px;">üîµ</span>
                                        <span>In corso</span>
                                    </div>
                                </div>
                            ` : ''}
                        `;
                        container.appendChild(legendaDiv);
                    }
                }

                // Event listener per filtri - SOLO se Manodopera √® attivo
                if (hasManodopera) {
                    if (filtroPodereSelect) {
                        filtroPodereSelect.addEventListener('change', applyFilters);
                    }
                    if (filtroColturaSelect) {
                        filtroColturaSelect.addEventListener('change', applyFilters);
                    }
                }

                // Toggle overlay lavori attivi (pulsante gi√† presente nell'header) - SOLO se Manodopera √® attivo
                const toggleOverlayBtn = document.getElementById('toggle-overlay-lavori');
                if (hasManodopera && toggleOverlayBtn) {
                    toggleOverlayBtn.addEventListener('click', function() {
                        overlayLavoriVisible = !overlayLavoriVisible;
                        
                        // Mostra/nascondi poligoni zone lavorate
                        zoneLavoratePolygons.forEach(polygon => {
                            if (overlayLavoriVisible) {
                                polygon.setMap(map);
                            } else {
                                polygon.setMap(null);
                            }
                        });

                        // Aggiorna stato pulsante
                        if (overlayLavoriVisible) {
                            toggleOverlayBtn.classList.add('active');
                            toggleOverlayBtn.innerHTML = '<span>üë∑</span> Zone Lavorate <span style="color: #00FF00;">‚óè</span>';
                        } else {
                            toggleOverlayBtn.classList.remove('active');
                            toggleOverlayBtn.innerHTML = '<span>üë∑</span> Zone Lavorate';
                        }
                    });
                }

                // Toggle indicatori lavori attivi - SOLO se Manodopera √® attivo
                const toggleIndicatoriBtn = document.getElementById('toggle-indicatori-lavori');
                if (hasManodopera && toggleIndicatoriBtn) {
                    toggleIndicatoriBtn.addEventListener('click', function() {
                        indicatoriLavoriVisible = !indicatoriLavoriVisible;
                        
                        // Mostra/nascondi marker lavori
                        lavoroMarkers.forEach(marker => {
                            if (indicatoriLavoriVisible) {
                                marker.setMap(map);
                            } else {
                                marker.setMap(null);
                            }
                        });

                        // Aggiorna stato pulsante
                        if (indicatoriLavoriVisible) {
                            toggleIndicatoriBtn.classList.add('active');
                            toggleIndicatoriBtn.innerHTML = '<span>üìç</span> Indicatori Lavori <span style="color: #2E8B57;">‚óè</span>';
                        } else {
                            toggleIndicatoriBtn.classList.remove('active');
                            toggleIndicatoriBtn.innerHTML = '<span>üìç</span> Indicatori Lavori';
                        }
                    });
                }

                // Crea legenda iniziale (dopo aver caricato le zone lavorate, se Manodopera attivo)
                updateLegenda('', '');

            } catch (error) {
                console.error('‚ùå Errore caricamento mappa aziendale:', error);
                console.error('Stack trace:', error.stack);
                console.error('Google Maps disponibile?', typeof google !== 'undefined' ? 'S√¨' : 'No');
                console.error('google.maps disponibile?', typeof google !== 'undefined' && google.maps ? 'S√¨' : 'No');
                container.innerHTML = `
                    <div class="mappa-loading">
                        <h3 style="color: #dc3545; margin-bottom: 15px;">‚ö†Ô∏è Errore</h3>
                        <p>Errore durante il caricamento della mappa: ${error.message}</p>
                        <p style="margin-top: 10px; font-size: 12px; color: #666;">
                            Controlla la console del browser per maggiori dettagli.
                        </p>
                    </div>
                `;
            }
        }
        
        // Carica statistiche core per manager
        async function loadCoreStatsForManager() {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                // Carica terreni
                const terreniCollection = collection(db, `tenants/${tenantId}/terreni`);
                const terreniSnapshot = await getDocs(terreniCollection);
                const totaleTerreni = terreniSnapshot.size;
                document.getElementById('stat-terreni-manager').textContent = totaleTerreni;
                
                // Carica attivit√† del mese corrente
                const oggi = new Date();
                const primoGiornoMese = new Date(oggi.getFullYear(), oggi.getMonth(), 1);
                const dataInizioMese = primoGiornoMese.toISOString().split('T')[0];
                const dataFineMese = oggi.toISOString().split('T')[0];
                
                const attivitaCollection = collection(db, `tenants/${tenantId}/attivita`);
                const attivitaQuery = query(
                    attivitaCollection,
                    where('data', '>=', dataInizioMese),
                    where('data', '<=', dataFineMese)
                );
                const attivitaSnapshot = await getDocs(attivitaQuery);
                
                let totaleOre = 0;
                attivitaSnapshot.forEach(doc => {
                    const data = doc.data();
                    totaleOre += data.oreNette || 0;
                });
                
                const totaleAttivita = attivitaSnapshot.size;
                document.getElementById('stat-attivita-manager').textContent = totaleAttivita;
                
                // Formatta ore
                const oreInt = Math.floor(totaleOre);
                const minuti = Math.round((totaleOre - oreInt) * 60);
                const oreFormatted = minuti === 0 ? `${oreInt}h` : `${oreInt}h ${minuti}min`;
                document.getElementById('stat-ore-manager').textContent = oreFormatted;
            } catch (error) {
                console.error('Errore caricamento statistiche core:', error);
            }
        }

        // Le funzioni createCaposquadraSection e createManagerLavoriSection sono state estratte nel modulo dashboard-sections.js
        
        // Carica statistiche Manodopera complete per Manager
        async function loadManagerManodoperaStats() {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                // 1. Carica lavori
                const lavoriCollection = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriSnapshot = await getDocs(lavoriCollection);
                
                let totali = 0;
                let attivi = 0;
                let superficieLavorata = 0;
                
                const lavoriIds = [];
                lavoriSnapshot.forEach(doc => {
                    totali++;
                    const lavoro = doc.data();
                    const stato = lavoro.stato || 'pianificato';
                    if (stato === 'attivo') attivi++;
                    lavoriIds.push(doc.id);
                    
                    // Calcola superficie lavorata (dalle zone lavorate)
                    // Usa superficieTotaleLavorata che viene aggiornato quando si tracciano zone lavorate
                    if (lavoro.superficieTotaleLavorata) {
                        superficieLavorata += lavoro.superficieTotaleLavorata;
                    }
                });
                
                // 2. Carica ore validate del mese corrente
                const oggi = new Date();
                const primoGiornoMese = new Date(oggi.getFullYear(), oggi.getMonth(), 1);
                let oreValidateTotali = 0;
                
                for (const lavoroId of lavoriIds) {
                    try {
                        const oreRef = collection(db, `tenants/${tenantId}/lavori/${lavoroId}/oreOperai`);
                        const oreSnapshot = await getDocs(oreRef);
                        
                        oreSnapshot.forEach(oraDoc => {
                            const ora = oraDoc.data();
                            if (ora.stato === 'validate' && ora.data) {
                                try {
                                    const dataOra = ora.data.toDate ? ora.data.toDate() : new Date(ora.data);
                                    if (dataOra >= primoGiornoMese) {
                                        oreValidateTotali += ora.oreNette || 0;
                                    }
                                } catch (e) {
                                    // Ignora errori di conversione data
                                }
                            }
                        });
                    } catch (error) {
                        // Se la sub-collection non esiste, continua
                    }
                }
                
                // 3. Carica squadre attive
                const squadreCollection = collection(db, `tenants/${tenantId}/squadre`);
                const squadreSnapshot = await getDocs(squadreCollection);
                let squadreAttive = 0;
                const operaiIds = new Set();
                
                squadreSnapshot.forEach(doc => {
                    const squadra = doc.data();
                    if (squadra.operai && squadra.operai.length > 0) {
                        squadreAttive++;
                        squadra.operai.forEach(operaioId => operaiIds.add(operaioId));
                    }
                });
                
                // 4. Conta operai online
                let operaiOnline = 0;
                for (const operaioId of operaiIds) {
                    try {
                        const operaioDoc = await getDoc(doc(db, 'users', operaioId));
                        if (operaioDoc.exists()) {
                            const operaioData = operaioDoc.data();
                            if (operaioData.isOnline) {
                                operaiOnline++;
                            }
                        }
                    } catch (e) {
                        // Ignora errori
                    }
                }
                
                // Aggiorna UI
                const statTotali = document.getElementById('stat-lavori-totali-manodopera');
                const statAttivi = document.getElementById('stat-lavori-attivi-manodopera');
                const statOre = document.getElementById('stat-ore-validate-manodopera');
                const statSuperficie = document.getElementById('stat-superficie-lavorata-manodopera');
                const statSquadre = document.getElementById('stat-squadre-attive-manodopera');
                const statOperai = document.getElementById('stat-operai-online-manodopera');
                
                // Carica manutenzioni in scadenza e guasti segnalati con listener real-time (solo se modulo Parco Macchine attivo)
                const tenantDoc = await getDoc(doc(db, 'tenants', tenantId));
                if (tenantDoc.exists()) {
                    const tenantData = tenantDoc.data();
                    const hasParcoMacchine = tenantData.modules && tenantData.modules.includes('parcoMacchine');
                    if (hasParcoMacchine) {
                        setTimeout(() => {
                            setupManutenzioniRealtime(tenantId);
                            setupGuastiRealtime(tenantId);
                        }, 100);
                    }
                }
                
                if (statTotali) statTotali.textContent = totali;
                if (statAttivi) statAttivi.textContent = attivi;
                
                // Formatta ore
                const oreInt = Math.floor(oreValidateTotali);
                const minuti = Math.round((oreValidateTotali - oreInt) * 60);
                const oreFormatted = minuti === 0 ? `${oreInt}h` : `${oreInt}h ${minuti}min`;
                if (statOre) statOre.textContent = oreFormatted;
                
                // Formatta superficie (in ettari, 2 decimali)
                if (statSuperficie) statSuperficie.textContent = superficieLavorata.toFixed(2);
                if (statSquadre) statSquadre.textContent = squadreAttive;
                if (statOperai) statOperai.textContent = operaiOnline;
            } catch (error) {
                console.error('Errore caricamento statistiche Manodopera:', error);
            }
        }

        // Setup listener real-time per manutenzioni in scadenza
        let manutenzioniUnsubscribe = null;
        function setupManutenzioniRealtime(tenantId) {
            try {
                const manutenzioniSection = document.getElementById('manutenzioni-scadenza-section');
                const manutenzioniList = document.getElementById('manutenzioni-scadenza-list');
                if (!manutenzioniSection || !manutenzioniList) return;

                // Rimuovi listener precedente se esiste
                if (manutenzioniUnsubscribe) {
                    manutenzioniUnsubscribe();
                    manutenzioniUnsubscribe = null;
                }

                const macchineRef = collection(db, `tenants/${tenantId}/macchine`);
                
                // Setup listener real-time
                manutenzioniUnsubscribe = onSnapshot(
                    macchineRef,
                    (macchineSnapshot) => {
                        updateManutenzioniUI(macchineSnapshot, manutenzioniSection, manutenzioniList);
                    },
                    (error) => {
                        console.error('Errore listener manutenzioni:', error);
                        if (manutenzioniSection) manutenzioniSection.style.display = 'none';
                    }
                );
            } catch (error) {
                console.error('Errore setup listener manutenzioni:', error);
            }
        }

        // Aggiorna UI manutenzioni (chiamata dal listener real-time)
        function updateManutenzioniUI(macchineSnapshot, manutenzioniSection, manutenzioniList) {
            try {

                if (!manutenzioniSection || !manutenzioniList) return;

                const manutenzioniScadute = [];
                const manutenzioniInScadenza = [];
                const oggi = new Date();
                oggi.setHours(0, 0, 0, 0);

                macchineSnapshot.forEach(macchinaDoc => {
                    const macchina = { id: macchinaDoc.id, ...macchinaDoc.data() };
                    if (macchina.stato === 'dismesso') return; // Ignora macchine dismesse

                    const oreAttuali = macchina.oreAttuali || macchina.oreIniziali || 0;
                    let isScaduta = false;
                    let isInScadenza = false;
                    let messaggio = '';

                    // Verifica per ore
                    if (macchina.oreProssimaManutenzione !== null && macchina.oreProssimaManutenzione !== undefined) {
                        const oreRimanenti = macchina.oreProssimaManutenzione - oreAttuali;
                        if (oreRimanenti <= 0) {
                            isScaduta = true;
                            const oreOltre = Math.abs(oreRimanenti);
                            messaggio = `‚ö†Ô∏è Scaduta: ${oreOltre.toFixed(1)} ore oltre la manutenzione programmata`;
                        } else if (oreRimanenti <= 50) {
                            isInScadenza = true;
                            messaggio = `‚è∞ In scadenza: ${oreRimanenti.toFixed(1)} ore rimanenti`;
                        }
                    }

                    // Verifica per data
                    if (macchina.prossimaManutenzione) {
                        const dataManutenzione = macchina.prossimaManutenzione.toDate ? macchina.prossimaManutenzione.toDate() : new Date(macchina.prossimaManutenzione);
                        dataManutenzione.setHours(0, 0, 0, 0);
                        const giorniRimanenti = Math.ceil((dataManutenzione - oggi) / (1000 * 60 * 60 * 24));
                        
                        if (giorniRimanenti < 0) {
                            isScaduta = true;
                            const giorniOltre = Math.abs(giorniRimanenti);
                            messaggio = messaggio ? `${messaggio} | Scaduta: ${giorniOltre} giorni fa` : `‚ö†Ô∏è Scaduta: ${giorniOltre} giorni fa`;
                        } else if (giorniRimanenti <= 30 && giorniRimanenti >= 0) {
                            isInScadenza = true;
                            messaggio = messaggio ? `${messaggio} | ${giorniRimanenti} giorni rimanenti` : `‚è∞ In scadenza: ${giorniRimanenti} giorni rimanenti`;
                        }
                    }

                    if (isScaduta) {
                        manutenzioniScadute.push({ ...macchina, messaggio });
                    } else if (isInScadenza) {
                        manutenzioniInScadenza.push({ ...macchina, messaggio });
                    }
                });

                // Mostra sezione solo se ci sono manutenzioni
                if (manutenzioniScadute.length === 0 && manutenzioniInScadenza.length === 0) {
                    manutenzioniSection.style.display = 'none';
                    return;
                }

                manutenzioniSection.style.display = 'block';

                let html = '';
                
                // Mostra prima quelle scadute
                if (manutenzioniScadute.length > 0) {
                    html += '<div style="margin-bottom: 15px;"><strong style="color: #dc3545;">üî¥ Scadute:</strong></div>';
                    manutenzioniScadute.forEach(m => {
                        const tipoIcon = (m.tipoMacchina || m.tipo) === 'trattore' ? 'üöú' : '‚öôÔ∏è';
                        html += `
                            <div style="padding: 10px; margin-bottom: 8px; background: #f8d7da; border-left: 3px solid #dc3545; border-radius: 4px;">
                                <div style="font-weight: 600; color: #721c24;">${tipoIcon} ${m.nome || 'Macchina senza nome'}</div>
                                <div style="font-size: 13px; color: #856404; margin-top: 4px;">${m.messaggio}</div>
                                <div style="margin-top: 6px;">
                                    <a href="admin/gestione-macchine-standalone.html" style="font-size: 12px; color: #2E8B57; text-decoration: none;">‚Üí Vai a Gestione Macchine</a>
                                </div>
                            </div>
                        `;
                    });
                }

                // Poi quelle in scadenza
                if (manutenzioniInScadenza.length > 0) {
                    if (manutenzioniScadute.length > 0) html += '<div style="margin-top: 20px; margin-bottom: 15px;"><strong style="color: #856404;">üü° In Scadenza:</strong></div>';
                    else html += '<div style="margin-bottom: 15px;"><strong style="color: #856404;">üü° In Scadenza:</strong></div>';
                    manutenzioniInScadenza.forEach(m => {
                        const tipoIcon = (m.tipoMacchina || m.tipo) === 'trattore' ? 'üöú' : '‚öôÔ∏è';
                        html += `
                            <div style="padding: 10px; margin-bottom: 8px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px;">
                                <div style="font-weight: 600; color: #856404;">${tipoIcon} ${m.nome || 'Macchina senza nome'}</div>
                                <div style="font-size: 13px; color: #856404; margin-top: 4px;">${m.messaggio}</div>
                                <div style="margin-top: 6px;">
                                    <a href="admin/gestione-macchine-standalone.html" style="font-size: 12px; color: #2E8B57; text-decoration: none;">‚Üí Vai a Gestione Macchine</a>
                                </div>
                            </div>
                        `;
                    });
                }

                manutenzioniList.innerHTML = html;
            } catch (error) {
                console.error('Errore caricamento manutenzioni in scadenza:', error);
                const manutenzioniSection = document.getElementById('manutenzioni-scadenza-section');
                if (manutenzioniSection) manutenzioniSection.style.display = 'none';
            }
        }

        // Setup listener real-time per guasti segnalati
        let guastiUnsubscribe = null;
        function setupGuastiRealtime(tenantId) {
            try {
                const guastiSection = document.getElementById('guasti-segnalati-section');
                const guastiList = document.getElementById('guasti-segnalati-list');
                if (!guastiSection || !guastiList) return;

                // Rimuovi listener precedente se esiste
                if (guastiUnsubscribe) {
                    guastiUnsubscribe();
                    guastiUnsubscribe = null;
                }

                const guastiRef = collection(db, `tenants/${tenantId}/guasti`);
                
                // Carica tutti i guasti e filtra/ordina in memoria (evita errori indice)
                guastiUnsubscribe = onSnapshot(
                    guastiRef,
                    (guastiSnapshot) => {
                        updateGuastiUI(guastiSnapshot, guastiSection, guastiList, tenantId);
                    },
                    (error) => {
                        // Solo logga se non √® un errore di indice
                        if (!error.message || !error.message.includes('index')) {
                            console.error('Errore listener guasti:', error);
                        }
                        if (guastiSection) guastiSection.style.display = 'none';
                    }
                );
            } catch (error) {
                console.error('Errore setup listener guasti:', error);
            }
        }

        // Aggiorna UI guasti (chiamata dal listener real-time)
        async function updateGuastiUI(guastiSnapshot, guastiSection, guastiList, tenantId) {
            try {
                if (!guastiSection || !guastiList) return;

                // Carica macchine per ottenere nomi
                const macchineRef = collection(db, `tenants/${tenantId}/macchine`);
                const macchineSnapshot = await getDocs(macchineRef);
                const macchineMap = new Map();
                macchineSnapshot.forEach(doc => {
                    macchineMap.set(doc.id, doc.data());
                });

                // Carica utenti per ottenere nomi operai
                const usersRef = collection(db, 'users');
                const usersSnapshot = await getDocs(usersRef);
                const usersMap = new Map();
                usersSnapshot.forEach(doc => {
                    usersMap.set(doc.id, doc.data());
                });

                // Filtra solo guasti non risolti e ordina per data
                const guastiAperti = [];
                const guastiRisolti = [];

                guastiSnapshot.forEach(doc => {
                    const guasto = { id: doc.id, ...doc.data() };
                    if (guasto.stato === 'risolto') {
                        guastiRisolti.push(guasto);
                    } else {
                        guastiAperti.push(guasto);
                    }
                });

                // Ordina per data segnalazione (pi√π recente prima)
                guastiAperti.sort((a, b) => {
                    const dateA = a.segnalatoIl?.toDate 
                        ? a.segnalatoIl.toDate() 
                        : new Date(a.segnalatoIl || 0);
                    const dateB = b.segnalatoIl?.toDate 
                        ? b.segnalatoIl.toDate() 
                        : new Date(b.segnalatoIl || 0);
                    return dateB - dateA;
                });

                guastiRisolti.sort((a, b) => {
                    const dateA = a.risoltoIl?.toDate 
                        ? a.risoltoIl.toDate() 
                        : new Date(a.risoltoIl || 0);
                    const dateB = b.risoltoIl?.toDate 
                        ? b.risoltoIl.toDate() 
                        : new Date(b.risoltoIl || 0);
                    return dateB - dateA;
                });

                // Mostra sezione solo se ci sono guasti
                if (guastiAperti.length === 0 && guastiRisolti.length === 0) {
                    guastiSection.style.display = 'none';
                    return;
                }

                guastiSection.style.display = 'block';

                let html = '';

                // Guasti aperti (urgenti)
                if (guastiAperti.length > 0) {
                    html += '<div style="margin-bottom: 15px;"><strong style="color: #721c24;">üî¥ Guasti Aperti:</strong></div>';
                    guastiAperti.forEach(g => {
                        const macchinaIdDaMostrare = g.macchinaId || g.attrezzoId;
                        const macchina = macchineMap.get(macchinaIdDaMostrare);
                        let macchinaNome = 'Macchina non trovata';
                        let tipoIcon = '‚ùì';
                        
                        if (macchina) {
                            macchinaNome = macchina.nome;
                            tipoIcon = (macchina.tipoMacchina || macchina.tipo) === 'trattore' ? 'üöú' : '‚öôÔ∏è';
                        }
                        
                        // Se ci sono sia trattore che attrezzo, mostra entrambi
                        if (g.macchinaId && g.attrezzoId) {
                            const attrezzo = macchineMap.get(g.attrezzoId);
                            if (attrezzo) {
                                macchinaNome += ` + ‚öôÔ∏è ${attrezzo.nome}`;
                            }
                        } else if (g.attrezzoId && !g.macchinaId) {
                            const attrezzo = macchineMap.get(g.attrezzoId);
                            if (attrezzo) {
                                macchinaNome = `‚öôÔ∏è ${attrezzo.nome}`;
                                tipoIcon = '‚öôÔ∏è';
                            }
                        }
                        
                        const operaio = usersMap.get(g.segnalatoDa);
                        const operaioNome = operaio ? `${operaio.nome || ''} ${operaio.cognome || ''}`.trim() || operaio.email : 'Operaio sconosciuto';

                        const dataSegnalazione = g.segnalatoIl?.toDate 
                            ? g.segnalatoIl.toDate().toLocaleString('it-IT')
                            : new Date(g.segnalatoIl).toLocaleString('it-IT');

                        const gravitaBadge = g.gravita === 'grave' 
                            ? '<span style="background: #dc3545; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px;">üî¥ Grave</span>'
                            : '<span style="background: #ffc107; color: #856404; padding: 2px 8px; border-radius: 12px; font-size: 11px;">üü° Non grave</span>';

                        const statoBadge = g.stato === 'approvato-continuazione'
                            ? '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px;">‚úÖ Continuazione approvata</span>'
                            : g.stato === 'sospeso'
                            ? '<span style="background: #6c757d; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px;">‚õî Sospeso</span>'
                            : '<span style="background: #ffc107; color: #856404; padding: 2px 8px; border-radius: 12px; font-size: 11px;">‚è≥ In attesa</span>';

                        html += `
                            <div style="padding: 12px; margin-bottom: 10px; background: white; border-left: 3px solid ${g.gravita === 'grave' ? '#dc3545' : '#ffc107'}; border-radius: 4px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>${tipoIcon} ${macchinaNome}</span>
                                    <div style="display: flex; gap: 6px;">
                                        ${gravitaBadge}
                                        ${statoBadge}
                                    </div>
                                </div>
                                <div style="font-size: 13px; color: #666; margin-bottom: 6px;">
                                    <strong>Operaio:</strong> ${operaioNome} | <strong>Segnalato:</strong> ${dataSegnalazione}
                                </div>
                                <div style="font-size: 13px; color: #333; margin-bottom: 10px;">
                                    <strong>Dettagli:</strong> ${g.dettagli || '-'}
                                </div>
                                <div style="margin-top: 8px;">
                                    <a href="admin/gestione-macchine-standalone.html" style="font-size: 12px; color: #2E8B57; text-decoration: none; margin-right: 15px;">‚Üí Vai a Gestione Macchine</a>
                                    <a href="admin/gestione-guasti-standalone.html?guasto=${g.id}" style="font-size: 12px; color: #2E8B57; text-decoration: none;">‚Üí Gestisci Guasto</a>
                                </div>
                            </div>
                        `;
                    });
                }

                // Guasti risolti (ultimi 5)
                if (guastiRisolti.length > 0) {
                    const ultimiRisolti = guastiRisolti.slice(0, 5);
                    if (guastiAperti.length > 0) html += '<div style="margin-top: 20px; margin-bottom: 15px;"><strong style="color: #155724;">‚úÖ Ultimi Risolti:</strong></div>';
                    else html += '<div style="margin-bottom: 15px;"><strong style="color: #155724;">‚úÖ Ultimi Risolti:</strong></div>';
                    
                    ultimiRisolti.forEach(g => {
                        const macchinaIdDaMostrare = g.macchinaId || g.attrezzoId;
                        const macchina = macchineMap.get(macchinaIdDaMostrare);
                        let macchinaNome = 'Macchina non trovata';
                        let tipoIcon = '‚ùì';
                        
                        if (macchina) {
                            macchinaNome = macchina.nome;
                            tipoIcon = (macchina.tipoMacchina || macchina.tipo) === 'trattore' ? 'üöú' : '‚öôÔ∏è';
                        }
                        
                        if (g.macchinaId && g.attrezzoId) {
                            const attrezzo = macchineMap.get(g.attrezzoId);
                            if (attrezzo) {
                                macchinaNome += ` + ‚öôÔ∏è ${attrezzo.nome}`;
                            }
                        } else if (g.attrezzoId && !g.macchinaId) {
                            const attrezzo = macchineMap.get(g.attrezzoId);
                            if (attrezzo) {
                                macchinaNome = `‚öôÔ∏è ${attrezzo.nome}`;
                                tipoIcon = '‚öôÔ∏è';
                            }
                        }
                        
                        const risoltoDa = usersMap.get(g.risoltoDa);
                        const risoltoDaNome = risoltoDa ? `${risoltoDa.nome || ''} ${risoltoDa.cognome || ''}`.trim() || risoltoDa.email : 'Sconosciuto';

                        const dataRisoluzione = g.risoltoIl?.toDate 
                            ? g.risoltoIl.toDate().toLocaleString('it-IT')
                            : new Date(g.risoltoIl).toLocaleString('it-IT');

                        html += `
                            <div style="padding: 10px; margin-bottom: 8px; background: #d4edda; border-left: 3px solid #28a745; border-radius: 4px;">
                                <div style="font-weight: 600; color: #155724; margin-bottom: 4px;">
                                    ${tipoIcon} ${macchinaNome}
                                </div>
                                <div style="font-size: 12px; color: #155724;">
                                    Risolto da ${risoltoDaNome} il ${dataRisoluzione}
                                    ${g.costoRiparazione ? ` | Costo: ‚Ç¨${g.costoRiparazione.toFixed(2)}` : ''}
                                </div>
                            </div>
                        `;
                    });
                }

                guastiList.innerHTML = html;
            } catch (error) {
                console.error('Errore aggiornamento guasti:', error);
                if (guastiSection) guastiSection.style.display = 'none';
            }
        }
        
        // Carica lavori recenti per Manager con Manodopera
        async function loadRecentLavoriManagerManodopera() {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                const lavoriCollection = collection(db, `tenants/${tenantId}/lavori`);
                let lavoriSnapshot;
                
                try {
                    const lavoriQuery = query(lavoriCollection, orderBy('createdAt', 'desc'), limit(5));
                    lavoriSnapshot = await getDocs(lavoriQuery);
                } catch (error) {
                    // Se createdAt non esiste, carica tutti e ordina manualmente
                    const allLavoriSnapshot = await getDocs(lavoriCollection);
                    const lavoriArray = [];
                    allLavoriSnapshot.forEach(doc => {
                        lavoriArray.push({ id: doc.id, ...doc.data() });
                    });
                    lavoriArray.sort((a, b) => {
                        if (a.createdAt && b.createdAt) {
                            return b.createdAt.toMillis() - a.createdAt.toMillis();
                        }
                        return b.id.localeCompare(a.id);
                    });
                    lavoriSnapshot = {
                        empty: lavoriArray.length === 0,
                        forEach: (callback) => {
                            lavoriArray.slice(0, 5).forEach(item => {
                                callback({ id: item.id, data: () => item });
                            });
                        }
                    };
                }
                
                const recentLavoriEl = document.getElementById('recent-lavori-manager-manodopera');
                if (!recentLavoriEl) return;
                
                if (lavoriSnapshot.empty) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Nessun lavoro trovato</div>
                            </div>
                        </li>
                    `;
                    return;
                }
                
                let html = '';
                lavoriSnapshot.forEach(doc => {
                    const lavoro = doc.data();
                    const nome = lavoro.nome || 'Senza nome';
                    const stato = lavoro.stato || 'pianificato';
                    const statoLabels = {
                        'pianificato': 'üìÖ Pianificato',
                        'attivo': 'üü¢ Attivo',
                        'completato': '‚úÖ Completato',
                        'sospeso': '‚è∏Ô∏è Sospeso'
                    };
                    const statoLabel = statoLabels[stato] || stato;
                    
                    html += `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">${escapeHtml(nome)}</div>
                                <div class="recent-item-meta">${statoLabel}</div>
                            </div>
                        </li>
                    `;
                });
                
                recentLavoriEl.innerHTML = html;
            } catch (error) {
                console.error('Errore caricamento lavori recenti Manager Manodopera:', error);
                const recentLavoriEl = document.getElementById('recent-lavori-manager-manodopera');
                if (recentLavoriEl) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Errore caricamento lavori</div>
                            </div>
                        </li>
                    `;
                }
            }
        }
        
        // Carica statistiche lavori per Manager
        async function loadManagerLavoriStats() {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                // Carica tutti i lavori del tenant
                const lavoriCollection = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriSnapshot = await getDocs(lavoriCollection);
                
                let totali = 0;
                let attivi = 0;
                let completati = 0;
                let pianificati = 0;
                
                lavoriSnapshot.forEach(doc => {
                    totali++;
                    const lavoro = doc.data();
                    const stato = lavoro.stato || 'pianificato';
                    
                    if (stato === 'attivo') attivi++;
                    else if (stato === 'completato') completati++;
                    else if (stato === 'pianificato') pianificati++;
                });
                
                const statTotali = document.getElementById('stat-lavori-totali');
                const statAttivi = document.getElementById('stat-lavori-attivi');
                const statCompletati = document.getElementById('stat-lavori-completati');
                const statPianificati = document.getElementById('stat-lavori-pianificati');
                
                if (statTotali) statTotali.textContent = totali;
                if (statAttivi) statAttivi.textContent = attivi;
                if (statCompletati) statCompletati.textContent = completati;
                if (statPianificati) statPianificati.textContent = pianificati;
            } catch (error) {
                console.error('Errore caricamento statistiche lavori:', error);
            }
        }
        
        // Carica lavori recenti per Manager
        async function loadRecentLavori() {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                // Carica lavori recenti (ultimi 5)
                // Nota: se createdAt non esiste, carichiamo tutti e ordiniamo manualmente
                const lavoriCollection = collection(db, `tenants/${tenantId}/lavori`);
                let lavoriSnapshot;
                
                try {
                    // Prova a ordinare per createdAt
                    const lavoriQuery = query(lavoriCollection, orderBy('createdAt', 'desc'), limit(5));
                    lavoriSnapshot = await getDocs(lavoriQuery);
                } catch (error) {
                    // Se createdAt non esiste, carica tutti e ordina manualmente
                    console.warn('Campo createdAt non trovato, carico tutti i lavori:', error);
                    const allLavoriSnapshot = await getDocs(lavoriCollection);
                    const lavoriArray = [];
                    allLavoriSnapshot.forEach(doc => {
                        lavoriArray.push({ id: doc.id, ...doc.data() });
                    });
                    // Ordina per data creazione (se disponibile) o per ID
                    lavoriArray.sort((a, b) => {
                        if (a.createdAt && b.createdAt) {
                            return b.createdAt.toMillis() - a.createdAt.toMillis();
                        }
                        return b.id.localeCompare(a.id);
                    });
                    // Prendi i primi 5
                    lavoriSnapshot = {
                        empty: lavoriArray.length === 0,
                        forEach: (callback) => {
                            lavoriArray.slice(0, 5).forEach(item => {
                                callback({ id: item.id, data: () => item });
                            });
                        }
                    };
                }
                
                const recentLavoriEl = document.getElementById('recent-lavori-manager');
                if (!recentLavoriEl) return;
                
                if (lavoriSnapshot.empty) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Nessun lavoro trovato</div>
                            </div>
                        </li>
                    `;
                    return;
                }
                
                let html = '';
                lavoriSnapshot.forEach(doc => {
                    const lavoro = doc.data();
                    const nome = lavoro.nome || 'Senza nome';
                    const stato = lavoro.stato || 'pianificato';
                    const statoLabels = {
                        'pianificato': 'üìÖ Pianificato',
                        'attivo': 'üü¢ Attivo',
                        'completato': '‚úÖ Completato',
                        'sospeso': '‚è∏Ô∏è Sospeso'
                    };
                    const statoLabel = statoLabels[stato] || stato;
                    
                    html += `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">${escapeHtml(nome)}</div>
                                <div class="recent-item-meta">${statoLabel}</div>
                            </div>
                        </li>
                    `;
                });
                
                recentLavoriEl.innerHTML = html;
            } catch (error) {
                console.error('Errore caricamento lavori recenti:', error);
                const recentLavoriEl = document.getElementById('recent-lavori-manager');
                if (recentLavoriEl) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Errore caricamento lavori</div>
                            </div>
                        </li>
                    `;
                }
            }
        }

        // La funzione createDiarioDaLavoriSection √® stata estratta nel modulo dashboard-sections.js

        // Carica attivit√† generate automaticamente dalle ore validate
        async function loadDiarioDaLavori(userData) {
            const container = document.getElementById('diario-lavori-container');
            if (!container) {
                console.error('Container diario-lavori-container non trovato');
                return;
            }
            
            try {
                const user = auth.currentUser;
                if (!user || !userData || !userData.tenantId) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #dc3545;">
                            <div style="font-size: 18px; margin-bottom: 10px;">Errore: dati utente non disponibili</div>
                        </div>
                    `;
                    return;
                }
                
                const tenantId = userData.tenantId;
                console.log('Caricamento diario da lavori per tenant:', tenantId);
                
                // Carica tutti i lavori del tenant
                const lavoriRef = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriSnapshot = await getDocs(lavoriRef);
                console.log('Lavori trovati:', lavoriSnapshot.size);
                
                // Mappa per raggruppare attivit√† per data e lavoro
                const attivitaMap = new Map(); // key: "data-lavoroId", value: { data, lavoro, ore, operai }
                
                // Carica terreni per ottenere coltura
                const terreniRef = collection(db, `tenants/${tenantId}/terreni`);
                const terreniSnapshot = await getDocs(terreniRef);
                const terreniMap = new Map();
                terreniSnapshot.forEach(doc => {
                    terreniMap.set(doc.id, doc.data());
                });
                
                // Per ogni lavoro, carica le ore validate
                for (const lavoroDoc of lavoriSnapshot.docs) {
                    const lavoro = lavoroDoc.data();
                    const lavoroId = lavoroDoc.id;
                    
                    try {
                        const oreRef = collection(db, `tenants/${tenantId}/lavori/${lavoroId}/oreOperai`);
                        // Carica tutte le ore e filtra in memoria per evitare problemi con indice
                        const oreSnapshot = await getDocs(oreRef);
                        console.log(`Ore trovate per lavoro ${lavoroId}:`, oreSnapshot.size);
                        
                        // Raggruppa ore per data
                        const orePerData = new Map();
                        
                        oreSnapshot.forEach(oraDoc => {
                            const ora = oraDoc.data();
                            
                            // Filtra solo ore validate
                            if (ora.stato !== 'validate') {
                                return;
                            }
                            
                            if (!ora.data) {
                                console.warn('Ora senza data:', oraDoc.id);
                                return;
                            }
                            
                            try {
                                const dataOra = ora.data.toDate ? ora.data.toDate() : new Date(ora.data);
                                if (isNaN(dataOra.getTime())) {
                                    console.warn('Data non valida per ora:', oraDoc.id, ora.data);
                                    return;
                                }
                                
                                const dataKey = dataOra.toISOString().split('T')[0]; // YYYY-MM-DD
                                
                                if (!orePerData.has(dataKey)) {
                                    orePerData.set(dataKey, []);
                                }
                                orePerData.get(dataKey).push(ora);
                            } catch (error) {
                                console.warn('Errore processamento ora:', oraDoc.id, error);
                            }
                        });
                        
                        // Crea attivit√† aggregate per ogni data
                        orePerData.forEach((oreGiorno, dataKey) => {
                            // Calcola orario inizio (prima ora) e fine (ultima ora)
                            let orarioInizio = null;
                            let orarioFine = null;
                            let pauseTotali = 0;
                            let oreNetteTotali = 0;
                            const operaiSet = new Set();
                            
                            oreGiorno.forEach(ora => {
                                // Confronta orari come stringhe HH:MM
                                if (ora.orarioInizio) {
                                    if (!orarioInizio || ora.orarioInizio < orarioInizio) {
                                        orarioInizio = ora.orarioInizio;
                                    }
                                }
                                if (ora.orarioFine) {
                                    if (!orarioFine || ora.orarioFine > orarioFine) {
                                        orarioFine = ora.orarioFine;
                                    }
                                }
                                pauseTotali += ora.pauseMinuti || 0;
                                oreNetteTotali += ora.oreNette || 0;
                                if (ora.operaioId) {
                                    operaiSet.add(ora.operaioId);
                                }
                            });
                            
                            // Se non ci sono orari validi, salta questa attivit√†
                            if (!orarioInizio || !orarioFine) {
                                console.warn('Attivit√† senza orari validi per data:', dataKey);
                                return;
                            }
                            
                            // Recupera dati terreno
                            const terreno = terreniMap.get(lavoro.terrenoId);
                            const terrenoNome = terreno ? terreno.nome : 'Terreno non trovato';
                            const coltura = terreno ? terreno.coltura : '';
                            
                            // Crea chiave univoca per data e lavoro
                            const attivitaKey = `${dataKey}-${lavoroId}`;
                            
                            attivitaMap.set(attivitaKey, {
                                data: new Date(dataKey),
                                dataKey: dataKey,
                                lavoroId: lavoroId,
                                lavoroNome: lavoro.nome || 'Lavoro senza nome',
                                terrenoId: lavoro.terrenoId,
                                terrenoNome: terrenoNome,
                                tipoLavoro: lavoro.tipoLavoro || 'Non specificato',
                                coltura: coltura,
                                orarioInizio: orarioInizio,
                                orarioFine: orarioFine,
                                pauseMinuti: pauseTotali,
                                oreNette: oreNetteTotali,
                                numOperai: operaiSet.size,
                                note: `Lavoro: ${lavoro.nome || 'Senza nome'} - ${operaiSet.size} operaio${operaiSet.size !== 1 ? 'i' : ''}`
                            });
                        });
                    } catch (error) {
                        // Se la sub-collection non esiste, continua
                        console.warn(`Errore caricamento ore per lavoro ${lavoroId}:`, error);
                    }
                }
                
                // Converti mappa in array e ordina per data (pi√π recenti prima)
                const attivitaArray = Array.from(attivitaMap.values());
                attivitaArray.sort((a, b) => {
                    if (!a.data || !b.data) return 0;
                    return b.data.getTime() - a.data.getTime();
                });
                
                console.log('Attivit√† generate:', attivitaArray.length);
                
                // Renderizza tabella
                if (attivitaArray.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <div style="font-size: 48px; margin-bottom: 15px;">üìã</div>
                            <div style="font-size: 18px; margin-bottom: 10px;">Nessuna attivit√† generata</div>
                            <div style="font-size: 14px; color: #999;">
                                Le attivit√† verranno generate automaticamente quando ci saranno ore validate dai caposquadra.
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Limita a ultime 20 attivit√†
                const attivitaMostrate = attivitaArray.slice(0, 20);
                
                let html = `
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Data</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Terreno</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Tipo Lavoro</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Coltura</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Orario</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Ore</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Operai</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057;">Lavoro</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                attivitaMostrate.forEach(att => {
                    const dataFormatted = att.data.toLocaleDateString('it-IT', { 
                        day: '2-digit', 
                        month: 'short', 
                        year: 'numeric' 
                    });
                    
                    const orarioFormatted = att.orarioInizio && att.orarioFine 
                        ? `${att.orarioInizio.substring(0, 5)} - ${att.orarioFine.substring(0, 5)}`
                        : '-';
                    
                    const oreFormatted = Math.floor(att.oreNette) + 'h ' + Math.round((att.oreNette % 1) * 60) + 'min';
                    
                    html += `
                        <tr style="border-bottom: 1px solid #e9ecef;">
                            <td style="padding: 12px;">${dataFormatted}</td>
                            <td style="padding: 12px;">${escapeHtml(att.terrenoNome)}</td>
                            <td style="padding: 12px;">${escapeHtml(att.tipoLavoro)}</td>
                            <td style="padding: 12px;">${escapeHtml(att.coltura || '-')}</td>
                            <td style="padding: 12px;">${orarioFormatted}</td>
                            <td style="padding: 12px; font-weight: 600; color: #2E8B57;">${oreFormatted}</td>
                            <td style="padding: 12px;">${att.numOperai}</td>
                            <td style="padding: 12px;">
                                <span style="font-size: 12px; color: #666;">${escapeHtml(att.lavoroNome)}</span>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    ${attivitaArray.length > 20 ? `
                        <div style="margin-top: 15px; text-align: center; color: #666; font-size: 14px;">
                            Mostrate ${attivitaMostrate.length} di ${attivitaArray.length} attivit√† totali
                        </div>
                    ` : ''}
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Errore caricamento diario da lavori:', error);
                console.error('Stack:', error.stack);
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #dc3545;">
                            <div style="font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
                            <div style="font-size: 18px; margin-bottom: 10px;">Errore caricamento attivit√†</div>
                            <div style="font-size: 14px; color: #999; margin-top: 10px;">
                                ${escapeHtml(error.message || 'Errore sconosciuto')}
                            </div>
                            <div style="font-size: 12px; color: #999; margin-top: 10px; font-family: monospace;">
                                Controlla la console per maggiori dettagli
                            </div>
                        </div>
                    `;
                }
            }
        }

        // Carica statistiche caposquadra
        async function loadCaposquadraStats(userData) {
            try {
                const user = auth.currentUser;
                if (!user || !userData) return;
                
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                const caposquadraId = userData.id || user.uid;
                
                // 1. Conta lavori assegnati (stato in_corso o assegnato)
                const lavoriRef = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriQuery = query(lavoriRef, where('caposquadraId', '==', caposquadraId));
                const lavoriSnapshot = await getDocs(lavoriQuery);
                
                let lavoriAssegnati = 0;
                const lavoriIds = [];
                
                lavoriSnapshot.forEach(doc => {
                    const lavoro = doc.data();
                    const stato = lavoro.stato || 'assegnato';
                    // Conta solo lavori attivi (non completati e non annullati)
                    if (stato !== 'completato' && stato !== 'annullato' && stato !== 'completato_da_approvare') {
                        lavoriAssegnati++;
                    }
                    lavoriIds.push(doc.id);
                });
                
                // 2. Conta ore da validare (nei lavori del caposquadra)
                let oreDaValidare = 0;
                for (const lavoroId of lavoriIds) {
                    try {
                        const oreRef = collection(db, `tenants/${tenantId}/lavori/${lavoroId}/oreOperai`);
                        const oreQuery = query(oreRef, where('stato', '==', 'da_validare'));
                        const oreSnapshot = await getDocs(oreQuery);
                        oreDaValidare += oreSnapshot.size;
                    } catch (error) {
                        // Se la sottocollezione non esiste, continua
                        console.warn(`Errore caricamento ore per lavoro ${lavoroId}:`, error);
                    }
                }
                
                // 3. Conta operai nella squadra del caposquadra
                let dimensioneSquadra = 0;
                try {
                    const squadreRef = collection(db, `tenants/${tenantId}/squadre`);
                    const squadreQuery = query(squadreRef, where('caposquadraId', '==', caposquadraId));
                    const squadreSnapshot = await getDocs(squadreQuery);
                    
                    if (!squadreSnapshot.empty) {
                        // Prendi la prima squadra trovata (dovrebbe essercene solo una)
                        const squadraDoc = squadreSnapshot.docs[0];
                        const squadraData = squadraDoc.data();
                        dimensioneSquadra = squadraData.operai ? squadraData.operai.length : 0;
                    }
                } catch (error) {
                    console.warn('Errore caricamento squadra:', error);
                }
                
                // Aggiorna UI
                const statLavori = document.getElementById('stat-lavori-assegnati-capo');
                const statOre = document.getElementById('stat-ore-da-validare-capo');
                const statSquadra = document.getElementById('stat-squadra-capo');
                
                if (statLavori) statLavori.textContent = lavoriAssegnati;
                if (statOre) statOre.textContent = oreDaValidare;
                if (statSquadra) statSquadra.textContent = dimensioneSquadra;
            } catch (error) {
                console.error('Errore caricamento statistiche caposquadra:', error);
            }
        }
        
        // Carica lavori recenti per caposquadra
        async function loadRecentLavoriCaposquadra(userData) {
            try {
                const user = auth.currentUser;
                if (!user || !userData) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const tenantId = userData.tenantId;
                if (!tenantId) return;
                
                const caposquadraId = userData.id || user.uid;
                
                // Carica lavori assegnati al caposquadra (ultimi 5)
                const lavoriRef = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriQuery = query(lavoriRef, where('caposquadraId', '==', caposquadraId));
                const lavoriSnapshot = await getDocs(lavoriQuery);
                
                const recentLavoriEl = document.getElementById('recent-lavori-capo');
                if (!recentLavoriEl) return;
                
                if (lavoriSnapshot.empty) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Nessun lavoro assegnato</div>
                            </div>
                        </li>
                    `;
                    return;
                }
                
                // Converti in array e ordina per data creazione
                const lavoriArray = [];
                lavoriSnapshot.forEach(doc => {
                    const lavoro = doc.data();
                    lavoriArray.push({
                        id: doc.id,
                        nome: lavoro.nome || 'Senza nome',
                        stato: lavoro.stato || 'assegnato',
                        createdAt: lavoro.createdAt || lavoro.creatoIl
                    });
                });
                
                // Ordina per data creazione (pi√π recenti prima)
                lavoriArray.sort((a, b) => {
                    if (a.createdAt && b.createdAt) {
                        const dateA = a.createdAt.toMillis ? a.createdAt.toMillis() : (a.createdAt instanceof Date ? a.createdAt.getTime() : 0);
                        const dateB = b.createdAt.toMillis ? b.createdAt.toMillis() : (b.createdAt instanceof Date ? b.createdAt.getTime() : 0);
                        return dateB - dateA;
                    }
                    return 0;
                });
                
                // Prendi i primi 5
                const lavoriRecenti = lavoriArray.slice(0, 5);
                
                if (lavoriRecenti.length === 0) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Nessun lavoro recente</div>
                            </div>
                        </li>
                    `;
                    return;
                }
                
                const statoLabels = {
                    'assegnato': 'üìã Assegnato',
                    'in_corso': 'üîÑ In corso',
                    'completato': '‚úÖ Completato',
                    'completato_da_approvare': '‚è≥ In attesa approvazione',
                    'annullato': '‚ùå Annullato'
                };
                
                let html = '';
                lavoriRecenti.forEach(lavoro => {
                    const statoLabel = statoLabels[lavoro.stato] || lavoro.stato;
                    html += `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">${escapeHtml(lavoro.nome)}</div>
                                <div class="recent-item-meta">${statoLabel}</div>
                            </div>
                        </li>
                    `;
                });
                
                recentLavoriEl.innerHTML = html;
            } catch (error) {
                console.error('Errore caricamento lavori recenti caposquadra:', error);
                const recentLavoriEl = document.getElementById('recent-lavori-capo');
                if (recentLavoriEl) {
                    recentLavoriEl.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Errore caricamento lavori</div>
                            </div>
                        </li>
                    `;
                }
            }
        }

        // La funzione createOperaioSection √® stata estratta nel modulo dashboard-sections.js
        
        // Carica comunicazioni per operaio
        async function loadComunicazioniOperaio(userData) {
            try {
                const user = auth.currentUser;
                if (!user || !userData || !userData.tenantId) return;
                
                const comunicazioniCollection = collection(db, `tenants/${userData.tenantId}/comunicazioni`);
                const oggi = new Date();
                oggi.setHours(0, 0, 0, 0);
                
                // Carica comunicazioni attive dove l'operaio √® destinatario
                const q = query(
                    comunicazioniCollection,
                    where('stato', '==', 'attiva')
                );
                const querySnapshot = await getDocs(q);
                
                const container = document.getElementById('comunicazioni-operaio-list');
                if (!container) return;
                
                const comunicazioniAttive = [];
                querySnapshot.forEach(docSnap => {
                    const comm = docSnap.data();
                    const dataCom = comm.data?.toDate ? comm.data.toDate() : new Date(comm.data);
                    
                    // Verifica se l'operaio √® destinatario
                    const destinatari = comm.destinatari || [];
                    if (destinatari.includes(user.uid)) {
                        // Verifica se la comunicazione √® ancora valida (data >= oggi)
                        if (dataCom >= oggi) {
                            const haConfermato = comm.conferme?.some(c => c.userId === user.uid) || false;
                            comunicazioniAttive.push({
                                id: docSnap.id,
                                ...comm,
                                dataCom: dataCom,
                                haConfermato: haConfermato
                            });
                        }
                    }
                });
                
                // Ordina per data (pi√π recenti prima)
                comunicazioniAttive.sort((a, b) => a.dataCom - b.dataCom);
                
                if (comunicazioniAttive.length === 0) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #666; background: #f8f9fa; border-radius: 8px;">
                            Nessuna comunicazione attiva
                        </div>
                    `;
                    return;
                }
                
                container.innerHTML = comunicazioniAttive.map(comm => {
                    const dataFormatted = comm.dataCom.toLocaleDateString('it-IT', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    const oraFormatted = comm.orario || '07:00';
                    
                    const confermaButton = comm.haConfermato ? 
                        '<button class="btn btn-success" disabled style="background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: not-allowed;">‚úÖ Confermato</button>' :
                        `<button class="btn btn-primary" onclick="confermaComunicazione('${comm.id}')" style="background: #2E8B57; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer;">‚úì Conferma Ricezione</button>`;
                    
                    const linkMaps = comm.coordinatePodere ? 
                        `<a href="https://www.google.com/maps/dir/?api=1&destination=${comm.coordinatePodere.lat},${comm.coordinatePodere.lng}" target="_blank" style="color: #2E8B57; text-decoration: none; font-size: 14px; margin-left: 10px;">üìç Indicazioni</a>` : '';
                    
                    return `
                        <div style="background: white; border: 2px solid ${comm.haConfermato ? '#28a745' : '#ffc107'}; border-radius: 12px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                                <div style="flex: 1;">
                                    <div style="font-size: 18px; font-weight: 600; color: #2E8B57; margin-bottom: 8px;">
                                        üìç ${escapeHtml(comm.podere)} - ${escapeHtml(comm.terreno)}
                                    </div>
                                    <div style="font-size: 14px; color: #666; margin-bottom: 5px;">
                                        üìÖ <strong>${dataFormatted}</strong> alle <strong>${oraFormatted}</strong>
                                    </div>
                                    <div style="font-size: 13px; color: #999; margin-top: 5px;">
                                        Da: ${escapeHtml(comm.caposquadraNome || 'Caposquadra')}
                                    </div>
                                    ${comm.note ? `<div style="font-size: 13px; color: #666; margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px;">${escapeHtml(comm.note)}</div>` : ''}
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 15px; border-top: 1px solid #e9ecef;">
                                ${confermaButton}
                                ${linkMaps}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Errore caricamento comunicazioni operaio:', error);
                const container = document.getElementById('comunicazioni-operaio-list');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #dc3545; background: #f8d7da; border-radius: 8px;">
                            Errore caricamento comunicazioni
                        </div>
                    `;
                }
            }
        }
        
        // Conferma ricezione comunicazione
        async function confermaComunicazione(comunicazioneId) {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                if (!userData.tenantId) return;
                
                const comunicazioneRef = doc(db, `tenants/${userData.tenantId}/comunicazioni`, comunicazioneId);
                const comunicazioneDoc = await getDoc(comunicazioneRef);
                
                if (!comunicazioneDoc.exists()) {
                    alert('Comunicazione non trovata');
                    return;
                }
                
                const comm = comunicazioneDoc.data();
                const conferme = comm.conferme || [];
                
                // Verifica se gi√† confermato
                if (conferme.some(c => c.userId === user.uid)) {
                    alert('Hai gi√† confermato questa comunicazione');
                    return;
                }
                
                // Aggiungi conferma (usa Timestamp.now() invece di serverTimestamp() perch√© non pu√≤ essere usato dentro array)
                conferme.push({
                    userId: user.uid,
                    timestamp: Timestamp.now()
                });
                
                await updateDoc(comunicazioneRef, {
                    conferme: conferme
                });
                
                // Ricarica comunicazioni
                if (userData) {
                    await loadComunicazioniOperaio(userData);
                }
                
                alert('‚úÖ Conferma ricevuta!');
            } catch (error) {
                console.error('Errore conferma comunicazione:', error);
                alert('Errore durante la conferma: ' + error.message);
            }
        }
        
        window.confermaComunicazione = confermaComunicazione;
        
        // Carica lavori di oggi per operaio (diretti + squadra)
        async function loadLavoriOggiOperaio(userData) {
            try {
                const user = auth.currentUser;
                if (!user || !userData || !userData.tenantId) return;
                
                const operaioId = userData.id || user.uid;
                const tenantId = userData.tenantId;
                
                // Carica terreni per ottenere nomi
                const terreniRef = collection(db, `tenants/${tenantId}/terreni`);
                const terreniSnapshot = await getDocs(terreniRef);
                const terreniMap = new Map();
                terreniSnapshot.forEach(doc => {
                    terreniMap.set(doc.id, doc.data());
                });
                
                // Carica tutti i lavori
                const lavoriRef = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriSnapshot = await getDocs(lavoriRef);
                
                const oggi = new Date();
                oggi.setHours(0, 0, 0, 0);
                
                const lavoriOggi = [];
                const lavoriIdsSet = new Set(); // Per evitare duplicati
                
                // 1. LAVORI DIRETTI (assegnati direttamente all'operaio)
                lavoriSnapshot.forEach(doc => {
                    const lavoro = doc.data();
                    
                    // Verifica se √® lavoro autonomo assegnato direttamente all'operaio
                    if (lavoro.operaioId === operaioId && !lavoro.caposquadraId) {
                        const stato = lavoro.stato || 'assegnato';
                        // Solo lavori attivi
                        if (stato !== 'completato' && stato !== 'annullato' && stato !== 'completato_da_approvare') {
                            const dataInizio = lavoro.dataInizio?.toDate ? lavoro.dataInizio.toDate() : new Date(lavoro.dataInizio);
                            const dataInizioSenzaOra = new Date(dataInizio);
                            dataInizioSenzaOra.setHours(0, 0, 0, 0);
                            
                            // Se la data inizio √® oggi o passata, mostra il lavoro
                            if (dataInizioSenzaOra <= oggi) {
                                // Carica nome terreno
                                const terreno = lavoro.terrenoId ? terreniMap.get(lavoro.terrenoId) : null;
                                const terrenoNome = terreno ? terreno.nome : null;
                                
                                lavoriOggi.push({
                                    id: doc.id,
                                    ...lavoro,
                                    dataInizio: dataInizio,
                                    tipoAssegnazione: 'autonomo', // Flag per distinguere
                                    terreno: terrenoNome // Aggiungi nome terreno
                                });
                                lavoriIdsSet.add(doc.id);
                            }
                        }
                    }
                });
                
                // 2. LAVORI DI SQUADRA (tramite caposquadra)
                // Trova la squadra dell'operaio
                const squadreRef = collection(db, `tenants/${tenantId}/squadre`);
                const squadreSnapshot = await getDocs(squadreRef);
                
                let caposquadraId = null;
                squadreSnapshot.forEach(doc => {
                    const squadra = doc.data();
                    if (squadra.operai && squadra.operai.includes(operaioId)) {
                        caposquadraId = squadra.caposquadraId;
                    }
                });
                
                if (caposquadraId) {
                    lavoriSnapshot.forEach(doc => {
                        // Evita duplicati (se gi√† presente come lavoro diretto)
                        if (lavoriIdsSet.has(doc.id)) return;
                        
                        const lavoro = doc.data();
                        
                        // Verifica che sia lavoro di squadra (caposquadraId presente, operaioId null)
                        if (lavoro.caposquadraId === caposquadraId && !lavoro.operaioId) {
                            const stato = lavoro.stato || 'assegnato';
                            // Solo lavori attivi
                            if (stato !== 'completato' && stato !== 'annullato' && stato !== 'completato_da_approvare') {
                                const dataInizio = lavoro.dataInizio?.toDate ? lavoro.dataInizio.toDate() : new Date(lavoro.dataInizio);
                                const dataInizioSenzaOra = new Date(dataInizio);
                                dataInizioSenzaOra.setHours(0, 0, 0, 0);
                                
                                // Se la data inizio √® oggi o passata, mostra il lavoro
                                if (dataInizioSenzaOra <= oggi) {
                                    // Carica nome terreno
                                    const terreno = lavoro.terrenoId ? terreniMap.get(lavoro.terrenoId) : null;
                                    const terrenoNome = terreno ? terreno.nome : null;
                                    
                                    lavoriOggi.push({
                                        id: doc.id,
                                        ...lavoro,
                                        dataInizio: dataInizio,
                                        tipoAssegnazione: 'squadra', // Flag per distinguere
                                        terreno: terrenoNome // Aggiungi nome terreno
                                    });
                                    lavoriIdsSet.add(doc.id);
                                }
                            }
                        }
                    });
                }
                
                // Ordina per data (pi√π recenti prima)
                lavoriOggi.sort((a, b) => {
                    const dateA = a.dataInizio instanceof Date ? a.dataInizio : new Date(a.dataInizio);
                    const dateB = b.dataInizio instanceof Date ? b.dataInizio : new Date(b.dataInizio);
                    return dateB - dateA;
                });
                
                // Aggiorna statistiche
                const statElement = document.getElementById('stat-lavori-oggi-operaio');
                if (statElement) {
                    statElement.textContent = lavoriOggi.length;
                }
                
                // Renderizza lista lavori
                const container = document.getElementById('lavori-oggi-operaio');
                if (!container) return;
                
                if (lavoriOggi.length === 0) {
                    // Mostra messaggio appropriato in base alla situazione
                    let message = 'Nessun lavoro assegnato per oggi';
                    if (!caposquadraId && lavoriOggi.length === 0) {
                        message = 'Nessun lavoro assegnato. Contatta il manager per essere assegnato a una squadra o per ricevere lavori autonomi.';
                    }
                    
                    container.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">${message}</div>
                            </div>
                        </li>
                    `;
                    return;
                }
                
                container.innerHTML = lavoriOggi.slice(0, 5).map(lavoro => {
                    const dataFormatted = lavoro.dataInizio.toLocaleDateString('it-IT', { 
                        day: '2-digit', 
                        month: 'short', 
                        year: 'numeric' 
                    });
                    const statoLabel = {
                        'assegnato': 'Assegnato',
                        'in_corso': 'In Corso',
                        'completato': 'Completato',
                        'completato_da_approvare': 'In attesa approvazione'
                    }[lavoro.stato] || lavoro.stato;
                    
                    // Badge per tipo assegnazione
                    const tipoBadge = lavoro.tipoAssegnazione === 'autonomo' 
                        ? '<span style="background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">Autonomo</span>'
                        : '<span style="background: #2196F3; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">Squadra</span>';
                    
                    // Checkbox per segnare completato (solo per lavori autonomi attivi)
                    const checkboxCompletato = lavoro.tipoAssegnazione === 'autonomo' && 
                        lavoro.stato !== 'completato' && 
                        lavoro.stato !== 'completato_da_approvare' && 
                        lavoro.stato !== 'annullato'
                        ? `
                            <div style="margin-top: 8px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; color: #666;">
                                    <input type="checkbox" 
                                           class="checkbox-completato-lavoro" 
                                           data-lavoro-id="${lavoro.id}"
                                           ${lavoro.stato === 'completato_da_approvare' ? 'checked disabled' : ''}
                                           onchange="segnaLavoroCompletato('${lavoro.id}', this.checked)">
                                    <span>Segna come completato</span>
                                </label>
                            </div>
                        `
                        : lavoro.stato === 'completato_da_approvare'
                        ? '<div style="margin-top: 8px; color: #ffc107; font-size: 12px;">‚è≥ In attesa approvazione Manager</div>'
                        : lavoro.stato === 'completato'
                        ? '<div style="margin-top: 8px; color: #4CAF50; font-size: 12px;">‚úÖ Completato</div>'
                        : '';
                    
                    return `
                        <li class="recent-item">
                            <div style="width: 100%;">
                                <div class="recent-item-title">
                                    ${escapeHtml(lavoro.nome || 'Lavoro senza nome')}
                                    ${tipoBadge}
                                </div>
                                <div class="recent-item-description">
                                    ${escapeHtml(lavoro.terreno || 'Terreno non specificato')} ‚Ä¢ ${dataFormatted} ‚Ä¢ ${statoLabel}
                                </div>
                                ${checkboxCompletato}
                            </div>
                        </li>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Errore caricamento lavori oggi operaio:', error);
                const container = document.getElementById('lavori-oggi-operaio');
                if (container) {
                    container.innerHTML = `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">Errore caricamento lavori</div>
                            </div>
                        </li>
                    `;
                }
            }
        }
        
        // Segna lavoro come completato (per operai con lavori autonomi)
        window.segnaLavoroCompletato = async function(lavoroId, isCompletato) {
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                const tenantId = userData.tenantId;
                
                // Verifica che il lavoro esista e sia assegnato all'operaio corrente
                const lavoroDoc = await getDoc(doc(db, 'tenants', tenantId, 'lavori', lavoroId));
                if (!lavoroDoc.exists()) {
                    showAlert('Lavoro non trovato', 'error');
                    return;
                }
                
                const lavoroData = lavoroDoc.data();
                
                // Verifica che sia un lavoro autonomo assegnato all'operaio corrente
                if (lavoroData.operaioId !== user.uid || lavoroData.caposquadraId) {
                    showAlert('Non hai i permessi per completare questo lavoro', 'error');
                    return;
                }
                
                // Verifica che il lavoro non sia gi√† completato o annullato
                if (lavoroData.stato === 'completato' || lavoroData.stato === 'annullato') {
                    showAlert('Questo lavoro √® gi√† completato o annullato', 'error');
                    return;
                }
                
                if (isCompletato) {
                    // Conferma prima di segnare come completato
                    if (!confirm('Sei sicuro di voler segnare questo lavoro come completato?\n\nIl lavoro sar√† inviato al Manager per l\'approvazione finale.')) {
                        // Reset checkbox
                        const checkbox = document.querySelector(`.checkbox-completato-lavoro[data-lavoro-id="${lavoroId}"]`);
                        if (checkbox) checkbox.checked = false;
                        return;
                    }
                    
                    // Aggiorna stato a "completato_da_approvare"
                    await updateDoc(doc(db, 'tenants', tenantId, 'lavori', lavoroId), {
                        stato: 'completato_da_approvare',
                        completatoDa: user.uid,
                        completatoIl: serverTimestamp(),
                        aggiornatoIl: serverTimestamp()
                    });
                    
                    showAlert('Lavoro segnato come completato! In attesa di approvazione del Manager.', 'success');
                } else {
                    // Se deselezionato, riporta a stato precedente (solo se era in attesa approvazione)
                    if (lavoroData.stato === 'completato_da_approvare') {
                        await updateDoc(doc(db, 'tenants', tenantId, 'lavori', lavoroId), {
                            stato: 'in_corso',
                            completatoDa: null,
                            completatoIl: null,
                            aggiornatoIl: serverTimestamp()
                        });
                        
                        showAlert('Stato lavoro aggiornato', 'success');
                    }
                }
                
                // Ricarica lavori
                await loadLavoriOggiOperaio(userData);
                
            } catch (error) {
                console.error('Errore segnatura lavoro completato:', error);
                showAlert(`Errore: ${error.message}`, 'error');
                
                // Reset checkbox in caso di errore
                const checkbox = document.querySelector(`.checkbox-completato-lavoro[data-lavoro-id="${lavoroId}"]`);
                if (checkbox) checkbox.checked = !isCompletato;
            }
        };
        
        // Carica statistiche ore per operaio
        async function loadStatisticheOreOperaio(userData) {
            try {
                const user = auth.currentUser;
                if (!user || !userData || !userData.tenantId) return;
                
                const operaioId = userData.id || user.uid;
                const tenantId = userData.tenantId;
                
                // Carica tutti i lavori per trovare le ore dell'operaio
                const lavoriRef = collection(db, `tenants/${tenantId}/lavori`);
                const lavoriSnapshot = await getDocs(lavoriRef);
                
                let totaleOreMinuti = 0;
                let oreValidate = 0;
                let oreDaValidare = 0;
                let oreRifiutate = 0;
                const oreRecenti = [];
                
                for (const lavoroDoc of lavoriSnapshot.docs) {
                    const lavoroId = lavoroDoc.id;
                    
                    try {
                        const oreRef = collection(db, `tenants/${tenantId}/lavori/${lavoroId}/oreOperai`);
                        const oreQuery = query(oreRef, where('operaioId', '==', operaioId));
                        const oreSnapshot = await getDocs(oreQuery);
                        
                        oreSnapshot.forEach(oraDoc => {
                            const ora = oraDoc.data();
                            const oreNette = ora.oreNette || 0;
                            const stato = ora.stato || 'da_validare';
                            
                            // Converti ore in minuti per somma
                            const oreMinuti = Math.round(oreNette * 60);
                            totaleOreMinuti += oreMinuti;
                            
                            if (stato === 'validate') {
                                oreValidate += oreMinuti;
                            } else if (stato === 'da_validare') {
                                oreDaValidare += oreMinuti;
                            } else if (stato === 'rifiutate') {
                                oreRifiutate += oreMinuti;
                            }
                            
                            // Aggiungi alle ore recenti (ultime 5)
                            const dataOra = ora.data?.toDate ? ora.data.toDate() : new Date(ora.data);
                            oreRecenti.push({
                                id: oraDoc.id,
                                lavoroId: lavoroId,
                                lavoroNome: lavoroDoc.data().nome || 'Lavoro',
                                data: dataOra,
                                oreNette: oreNette,
                                stato: stato,
                                note: ora.note || ''
                            });
                        });
                    } catch (error) {
                        // Se la sub-collection non esiste, continua
                        console.warn(`Errore caricamento ore per lavoro ${lavoroId}:`, error);
                    }
                }
                
                // Converti minuti in ore e minuti
                const oreTotali = Math.floor(totaleOreMinuti / 60);
                const minutiTotali = totaleOreMinuti % 60;
                const oreFormatted = minutiTotali === 0 ? `${oreTotali}h` : `${oreTotali}h ${minutiTotali}min`;
                
                // Aggiorna statistiche
                document.getElementById('stat-ore-segnate-operaio').textContent = oreFormatted;
                
                // Determina stato principale
                let statoLabel = 'In attesa';
                if (oreDaValidare > 0) {
                    statoLabel = 'Da validare';
                } else if (oreValidate > 0) {
                    statoLabel = 'Validate';
                }
                document.getElementById('stat-stato-operaio').textContent = statoLabel;
                
                // Ordina ore recenti per data (pi√π recenti prima)
                oreRecenti.sort((a, b) => b.data - a.data);
                
                // Renderizza sezione "Le mie ore"
                const container = document.getElementById('mie-ore-operaio-section');
                if (!container) return;
                
                if (oreRecenti.length === 0) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #666; background: #f8f9fa; border-radius: 8px;">
                            Nessuna ora segnata ancora
                        </div>
                    `;
                    return;
                }
                
                // Statistiche riepilogative
                const oreValidateFormatted = Math.floor(oreValidate / 60) + 'h ' + (oreValidate % 60) + 'min';
                const oreDaValidareFormatted = Math.floor(oreDaValidare / 60) + 'h ' + (oreDaValidare % 60) + 'min';
                const oreRifiutateFormatted = Math.floor(oreRifiutate / 60) + 'h ' + (oreRifiutate % 60) + 'min';
                
                let html = `
                    <div style="background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 15px 0; font-size: 16px; color: #333;">Riepilogo Ore</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div style="text-align: center; padding: 15px; background: #e8f5e9; border-radius: 8px;">
                                <div style="font-size: 24px; font-weight: 600; color: #2e7d32;">${oreValidateFormatted}</div>
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">Validate</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: #fff3e0; border-radius: 8px;">
                                <div style="font-size: 24px; font-weight: 600; color: #f57c00;">${oreDaValidareFormatted}</div>
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">Da Validare</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: #ffebee; border-radius: 8px;">
                                <div style="font-size: 24px; font-weight: 600; color: #c62828;">${oreRifiutateFormatted}</div>
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">Rifiutate</div>
                            </div>
                        </div>
                    </div>
                    
                    <h4 style="margin: 20px 0 15px 0; font-size: 16px; color: #666;">Ultime Ore Segnate</h4>
                    <ul class="recent-items">
                `;
                
                oreRecenti.slice(0, 5).forEach(ora => {
                    const dataFormatted = ora.data.toLocaleDateString('it-IT', { 
                        day: '2-digit', 
                        month: 'short', 
                        year: 'numeric' 
                    });
                    const oreFormatted = Math.floor(ora.oreNette) + 'h ' + Math.round((ora.oreNette % 1) * 60) + 'min';
                    const statoBadge = {
                        'validate': '<span style="background: #4caf50; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">‚úÖ Validate</span>',
                        'da_validare': '<span style="background: #ff9800; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">‚è≥ Da validare</span>',
                        'rifiutate': '<span style="background: #f44336; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">‚ùå Rifiutate</span>'
                    }[ora.stato] || '';
                    
                    html += `
                        <li class="recent-item">
                            <div>
                                <div class="recent-item-title">${escapeHtml(ora.lavoroNome)} ${statoBadge}</div>
                                <div class="recent-item-description">
                                    ${dataFormatted} ‚Ä¢ ${oreFormatted}${ora.note ? ' ‚Ä¢ ' + escapeHtml(ora.note) : ''}
                                </div>
                            </div>
                        </li>
                    `;
                });
                
                html += '</ul>';
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Errore caricamento statistiche ore operaio:', error);
                const container = document.getElementById('mie-ore-operaio-section');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #dc3545; background: #f8d7da; border-radius: 8px;">
                            Errore caricamento statistiche ore
                        </div>
                    `;
                }
            }
        }
        
        // ========== Comunicazione Rapida Caposquadra ==========
        
        let lavoriAttiviCaposquadra = [];
        
        // Carica comunicazione rapida
        async function loadComunicazioneRapida(userData) {
            try {
                const user = auth.currentUser;
                if (!user || !userData || !userData.tenantId) return;
                
                const caposquadraId = userData.id || user.uid;
                
                // Carica lavori attivi del caposquadra
                const lavoriCollection = collection(db, `tenants/${userData.tenantId}/lavori`);
                const q = query(
                    lavoriCollection,
                    where('caposquadraId', '==', caposquadraId)
                );
                const querySnapshot = await getDocs(q);
                
                lavoriAttiviCaposquadra = [];
                querySnapshot.forEach((docSnap) => {
                    const lavoro = docSnap.data();
                    const stato = lavoro.stato || 'assegnato';
                    
                    // Solo lavori attivi
                    if (stato !== 'completato' && stato !== 'annullato' && stato !== 'completato_da_approvare') {
                        lavoriAttiviCaposquadra.push({
                            id: docSnap.id,
                            ...lavoro
                        });
                    }
                });
                
                const container = document.getElementById('comunicazione-rapida-content');
                if (!container) return;
                
                if (lavoriAttiviCaposquadra.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #666;">
                            <p style="margin-bottom: 10px;">Nessun lavoro attivo disponibile.</p>
                            <p style="font-size: 14px; color: #999;">Usa la <a href="admin/impostazioni-standalone.html" style="color: #2E8B57;">versione completa nelle Impostazioni</a> per inviare comunicazioni personalizzate.</p>
                        </div>
                    `;
                    return;
                }
                
                // Carica dettagli terreni per i lavori
                await loadDettagliTerreniPerLavori(userData.tenantId);
                
                // Renderizza form
                renderComunicazioneRapidaForm();
            } catch (error) {
                console.error('Errore caricamento comunicazione rapida:', error);
                const container = document.getElementById('comunicazione-rapida-content');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #dc3545;">
                            Errore caricamento lavori
                        </div>
                    `;
                }
            }
        }
        
        // Carica dettagli terreni per i lavori
        async function loadDettagliTerreniPerLavori(tenantId) {
            try {
                const terreniCollection = collection(db, `tenants/${tenantId}/terreni`);
                const querySnapshot = await getDocs(terreniCollection);
                
                const terreniMap = {};
                querySnapshot.forEach((docSnap) => {
                    terreniMap[docSnap.id] = docSnap.data();
                });
                
                // Aggiungi dettagli terreno a ogni lavoro
                lavoriAttiviCaposquadra.forEach(lavoro => {
                    if (lavoro.terrenoId && terreniMap[lavoro.terrenoId]) {
                        lavoro.terreno = terreniMap[lavoro.terrenoId];
                    }
                });
            } catch (error) {
                console.error('Errore caricamento terreni:', error);
            }
        }
        
        // Renderizza form comunicazione rapida
        function renderComunicazioneRapidaForm() {
            const container = document.getElementById('comunicazione-rapida-content');
            if (!container || lavoriAttiviCaposquadra.length === 0) return;
            
            const primoLavoro = lavoriAttiviCaposquadra[0];
            const podere = primoLavoro.terreno?.podere || 'Non specificato';
            const terrenoNome = primoLavoro.terreno?.nome || primoLavoro.nome || 'Non specificato';
            const lavoroNome = primoLavoro.nome || 'Lavoro senza nome';
            
            // Imposta data di default a domani
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const dateString = tomorrow.toISOString().split('T')[0];
            
            let lavoroSelectHTML = '';
            if (lavoriAttiviCaposquadra.length > 1) {
                lavoroSelectHTML = `
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #495057;">Seleziona Lavoro</label>
                        <select id="rapida-lavoro-select" onchange="handleRapidaLavoroChange()" style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                            ${lavoriAttiviCaposquadra.map((l, idx) => `
                                <option value="${l.id}" ${idx === 0 ? 'selected' : ''}>${escapeHtml(l.nome || 'Lavoro senza nome')}</option>
                            `).join('')}
                        </select>
                    </div>
                `;
            }
            
            container.innerHTML = `
                ${lavoroSelectHTML}
                <form id="comunicazione-rapida-form" onsubmit="handleSendComunicazioneRapida(event)" style="display: grid; gap: 15px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #495057;">Lavoro</label>
                            <div style="padding: 8px; background: #f8f9fa; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px; color: #666;" id="rapida-lavoro-nome">${escapeHtml(lavoroNome)}</div>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #495057;">Podere</label>
                            <div style="padding: 8px; background: #f8f9fa; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px; color: #666;" id="rapida-podere">${escapeHtml(podere)}</div>
                        </div>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #495057;">Campo/Terreno</label>
                        <div style="padding: 8px; background: #f8f9fa; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px; color: #666;" id="rapida-terreno">${escapeHtml(terrenoNome)}</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #495057;">Orario Ritrovo *</label>
                            <input type="time" id="rapida-orario" required value="07:00" style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #495057;">Note (opzionale)</label>
                            <input type="text" id="rapida-note" placeholder="Eventuali note o istruzioni..." style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <div style="font-size: 12px; color: #666;">
                            Data: <strong>${tomorrow.toLocaleDateString('it-IT', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</strong>
                        </div>
                        <button type="submit" style="background: #2E8B57; color: white; padding: 10px 20px; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                            <span>üì§</span> Invia alla Squadra
                        </button>
                    </div>
                </form>
                <div id="rapida-message" style="margin-top: 15px;"></div>
            `;
        }
        
        // Gestisce cambio lavoro nel form rapido
        function handleRapidaLavoroChange() {
            const select = document.getElementById('rapida-lavoro-select');
            if (!select) return;
            
            const lavoroId = select.value;
            const lavoro = lavoriAttiviCaposquadra.find(l => l.id === lavoroId);
            
            if (!lavoro) return;
            
            const podere = lavoro.terreno?.podere || 'Non specificato';
            const terrenoNome = lavoro.terreno?.nome || lavoro.nome || 'Non specificato';
            const lavoroNome = lavoro.nome || 'Lavoro senza nome';
            
            document.getElementById('rapida-lavoro-nome').textContent = lavoroNome;
            document.getElementById('rapida-podere').textContent = podere;
            document.getElementById('rapida-terreno').textContent = terrenoNome;
        }
        
        window.handleRapidaLavoroChange = handleRapidaLavoroChange;
        
        // Invia comunicazione rapida
        async function handleSendComunicazioneRapida(e) {
            e.preventDefault();
            
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (!userDoc.exists()) return;
                
                const userData = userDoc.data();
                if (!userData.tenantId) return;
                
                // Ottieni lavoro selezionato
                const lavoroSelect = document.getElementById('rapida-lavoro-select');
                const lavoroId = lavoroSelect ? lavoroSelect.value : lavoriAttiviCaposquadra[0].id;
                const lavoro = lavoriAttiviCaposquadra.find(l => l.id === lavoroId);
                
                if (!lavoro || !lavoro.terreno) {
                    showRapidaMessage('Errore: lavoro o terreno non trovato', 'error');
                    return;
                }
                
                const podere = lavoro.terreno.podere || 'Non specificato';
                const terrenoNome = lavoro.terreno.nome || lavoro.nome || 'Non specificato';
                const orario = document.getElementById('rapida-orario').value;
                const note = document.getElementById('rapida-note').value.trim();
                
                if (!orario) {
                    showRapidaMessage('Inserisci un orario', 'error');
                    return;
                }
                
                // Ottieni coordinate podere se disponibili
                let coordinatePodere = null;
                if (podere && podere !== 'Non specificato') {
                    try {
                        const poderiCollection = collection(db, `tenants/${userData.tenantId}/poderi`);
                        const q = query(poderiCollection, where('nome', '==', podere));
                        const poderiSnapshot = await getDocs(q);
                        if (!poderiSnapshot.empty) {
                            const podereData = poderiSnapshot.docs[0].data();
                            coordinatePodere = podereData.coordinate || null;
                        }
                    } catch (error) {
                        console.warn('Errore recupero coordinate podere:', error);
                    }
                }
                
                // Ottieni membri squadra
                const squadreCollection = collection(db, `tenants/${userData.tenantId}/squadre`);
                const q = query(squadreCollection, where('caposquadraId', '==', userData.id || user.uid));
                const squadreSnapshot = await getDocs(q);
                
                if (squadreSnapshot.empty) {
                    showRapidaMessage('Nessun membro nella tua squadra', 'error');
                    return;
                }
                
                const squadraDoc = squadreSnapshot.docs[0];
                const squadraData = squadraDoc.data();
                const membriSquadra = squadraData.operai || [];
                
                if (membriSquadra.length === 0) {
                    showRapidaMessage('Nessun membro nella tua squadra', 'error');
                    return;
                }
                
                // Crea comunicazione
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(parseInt(orario.split(':')[0]), parseInt(orario.split(':')[1]), 0, 0);
                
                const comunicazioneData = {
                    caposquadraId: userData.id || user.uid,
                    caposquadraNome: `${userData.nome || ''} ${userData.cognome || ''}`.trim(),
                    podere: podere,
                    terreno: terrenoNome,
                    data: tomorrow,
                    orario: orario,
                    note: note || null,
                    coordinatePodere: coordinatePodere,
                    destinatari: membriSquadra,
                    conferme: [],
                    stato: 'attiva',
                    createdAt: serverTimestamp()
                };
                
                const comunicazioniCollection = collection(db, `tenants/${userData.tenantId}/comunicazioni`);
                await addDoc(comunicazioniCollection, comunicazioneData);
                
                showRapidaMessage('‚úÖ Comunicazione inviata alla squadra con successo!', 'success');
                
                // Reset form
                document.getElementById('rapida-orario').value = '07:00';
                document.getElementById('rapida-note').value = '';
            } catch (error) {
                console.error('Errore invio comunicazione rapida:', error);
                showRapidaMessage('Errore durante l\'invio: ' + error.message, 'error');
            }
        }
        
        window.handleSendComunicazioneRapida = handleSendComunicazioneRapida;
        
        // Mostra messaggio nel form rapido
        function showRapidaMessage(message, type) {
            const messageDiv = document.getElementById('rapida-message');
            if (!messageDiv) return;
            
            const color = type === 'success' ? '#28a745' : '#dc3545';
            const bgColor = type === 'success' ? '#d4edda' : '#f8d7da';
            
            messageDiv.innerHTML = `
                <div style="padding: 12px; background: ${bgColor}; color: ${color}; border-radius: 6px; font-size: 14px;">
                    ${message}
                </div>
            `;
            
            if (type === 'success') {
                setTimeout(() => {
                    messageDiv.innerHTML = '';
                }, 3000);
            }
        }

        // Verifica autenticazione e carica dashboard
        // Traccia l'utente previsto per questa scheda (per gestire cambio sessione)
        let expectedUserId = sessionStorage.getItem('gfv_expected_user_id');
        
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                // Non autenticato, redirect a login
                sessionStorage.removeItem('gfv_expected_user_id');
                window.location.href = './auth/login-standalone.html';
                return;
            }
            
            // Se questa scheda aveva un utente previsto e ora √® cambiato, gestisci il cambio
            if (expectedUserId && expectedUserId !== user.uid) {
                // L'utente √® cambiato (probabilmente un'altra scheda ha fatto login)
                // Se questa scheda non √® appena stata usata per registrazione, fai logout
                const justRegistered = sessionStorage.getItem('gfv_user_just_registered');
                if (!justRegistered) {
                    console.log('‚ö†Ô∏è Utente cambiato in questa scheda, redirect a login...');
                    const { signOut } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
                    await signOut(auth);
                    sessionStorage.removeItem('gfv_expected_user_id');
                    window.location.href = './auth/login-standalone.html';
                    return;
                } else {
                    // Questa scheda √® appena stata usata per registrazione, aggiorna l'utente previsto
                    expectedUserId = user.uid;
                    sessionStorage.setItem('gfv_expected_user_id', user.uid);
                    sessionStorage.removeItem('gfv_user_just_registered');
                }
            } else if (!expectedUserId) {
                // Prima volta che carichiamo questa scheda, salva l'utente previsto
                expectedUserId = user.uid;
                sessionStorage.setItem('gfv_expected_user_id', user.uid);
            }

            // Carica dati utente
            console.log('üöÄ INIZIO CARICAMENTO DATI UTENTE');
            console.log('üöÄ User ID:', user.uid);
            console.log('üöÄ User Email:', user.email);
            
            // Verifica se l'utente si √® appena registrato
            const justRegistered = sessionStorage.getItem('gfv_user_just_registered') === 'true';
            const expectedTenantId = sessionStorage.getItem('gfv_expected_tenant_id');
            if (justRegistered) {
                console.log('üÜï Utente appena registrato, attendo propagazione Firestore...');
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            try {
                const userDocRef = doc(db, 'users', user.uid);
                console.log('üöÄ Sto leggendo documento da Firestore...');
                const userDoc = await getDoc(userDocRef);
                console.log('üöÄ Documento letto, esiste?', userDoc.exists());

                if (!userDoc.exists()) {
                    // Il documento utente non esiste, verifica prima se esiste gi√† un documento con la stessa email
                    console.warn('‚ö†Ô∏è Documento utente non trovato per UID, verifico se esiste gi√† un documento con la stessa email...');
                    try {
                        // PRIMA VERIFICA: Cerca se esiste gi√† un documento con la stessa email (per evitare duplicati)
                        const existingUsersQuery = query(
                            collection(db, 'users'),
                            where('email', '==', user.email)
                        );
                        const existingUsersSnapshot = await getDocs(existingUsersQuery);
                        
                        if (!existingUsersSnapshot.empty) {
                            // Trovato un documento esistente con la stessa email ma UID diverso
                            // Questo √® un documento orfano o duplicato - aggiornalo con il nuovo UID
                            const existingDoc = existingUsersSnapshot.docs[0];
                            const existingData = existingDoc.data();
                            console.warn('‚ö†Ô∏è Trovato documento esistente con stessa email ma UID diverso:', existingDoc.id);
                            console.warn('‚ö†Ô∏è Aggiorno il documento esistente con il nuovo UID:', user.uid);
                            
                            // Aggiorna il documento esistente con il nuovo UID
                            await setDoc(userDocRef, {
                                ...existingData,
                                id: user.uid,
                                email: user.email,
                                ultimoAccesso: serverTimestamp(),
                                isOnline: true,
                                lastSeen: serverTimestamp()
                            });
                            
                            // Elimina il vecchio documento orfano
                            await deleteDoc(doc(db, 'users', existingDoc.id));
                            console.log('‚úÖ Documento duplicato eliminato, nuovo documento creato con UID corretto');
                            
                            // Ricarica il documento appena creato per continuare con il flusso normale
                            const updatedUserDoc = await getDoc(userDocRef);
                            if (!updatedUserDoc.exists()) {
                                throw new Error('Errore: documento non creato correttamente dopo merge');
                            }
                            } else {
                                // Nessun documento esistente con questa email, procedi con la creazione normale
                                console.log('‚úÖ Nessun documento esistente trovato');
                                
                                // IMPORTANTE: Se l'utente non viene dalla registrazione, NON creare documento vuoto
                                // L'utente deve completare la registrazione prima
                                const justRegistered = sessionStorage.getItem('gfv_user_just_registered') === 'true';
                                
                                if (!justRegistered) {
                                    console.warn('‚ö†Ô∏è ATTENZIONE: Utente autenticato ma documento non trovato e non viene dalla registrazione!');
                                    console.warn('‚ö†Ô∏è Questo potrebbe indicare un problema. Redirect alla registrazione...');
                                    await auth.signOut();
                                    alert('Errore: documento utente non trovato. Completa la registrazione.');
                                    window.location.href = '../auth/registrazione-standalone.html';
                                    return;
                                }
                                
                                console.log('‚úÖ Utente viene dalla registrazione, procedo con creazione documento...');
                                
                                // Attendi un breve momento per evitare race condition con registrazione appena completata
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                
                                // Ricontrolla se nel frattempo √® stato creato il documento dalla registrazione
                                const recheckDoc = await getDoc(userDocRef);
                                if (recheckDoc.exists()) {
                                    const recheckData = recheckDoc.data();
                                    // Se il documento esiste e ha tenantId e ruoli, usa quello
                                    if (recheckData.tenantId && recheckData.ruoli && recheckData.ruoli.length > 0) {
                                        console.log('‚úÖ Documento trovato dopo attesa con dati completi, uso quello esistente');
                                        // Il documento esiste ora, continua con il flusso normale dopo il blocco try
                                    } else {
                                        console.warn('‚ö†Ô∏è Documento trovato ma incompleto, procedo con fix...');
                                        // Continua con la creazione/fix
                                    }
                                } else {
                                // Cerca se esiste un invito per questa email
                                const invitiQuery = query(
                                    collection(db, 'inviti'),
                                    where('email', '==', user.email),
                                    where('stato', '==', 'accettato')
                                );
                                const invitiSnapshot = await getDocs(invitiQuery);
                                
                                let tenantId = null;
                                let ruoli = [];
                                
                                let nome = '';
                                let cognome = '';
                                
                                if (!invitiSnapshot.empty) {
                                    // Trovato un invito accettato, usa i dati dall'invito
                                    const invitoDoc = invitiSnapshot.docs[0];
                                    const invitoData = invitoDoc.data();
                                    tenantId = invitoData.tenantId;
                                    ruoli = invitoData.ruoli || [];
                                    // Recupera nome e cognome dall'invito
                                    nome = invitoData.nome || '';
                                    cognome = invitoData.cognome || '';
                                    console.log('‚úÖ Trovato invito accettato, tenantId:', tenantId, 'ruoli:', ruoli);
                                    console.log('‚úÖ Nome e cognome dall\'invito:', nome, cognome);
                                } else {
                                    // Nessun invito trovato - verifica se l'utente si √® appena registrato
                                    // Cerca se esiste un tenant creato da questo utente (registrazione appena completata)
                                    console.log('üîç Nessun invito trovato, verifico se esiste tenant creato da questo utente...');
                                    const tenantQuery = query(
                                        collection(db, 'tenants'),
                                        where('creatoDa', '==', user.uid)
                                    );
                                    const tenantSnapshot = await getDocs(tenantQuery);
                                    
                                    if (!tenantSnapshot.empty) {
                                        // Trovato tenant creato da questo utente = si √® appena registrato
                                        const tenantDoc = tenantSnapshot.docs[0];
                                        tenantId = tenantDoc.id;
                                        ruoli = ['amministratore']; // Primo utente √® sempre amministratore
                                        console.log('‚úÖ Trovato tenant creato da questo utente (registrazione appena completata)');
                                        console.log('‚úÖ TenantId:', tenantId);
                                        console.log('‚úÖ Assegnato ruolo amministratore');
                                    } else {
                                        console.warn('‚ö†Ô∏è Nessun tenant trovato per questo utente');
                                    }
                                }
                                
                                // Se nome/cognome non sono nell'invito, prova a recuperarli da displayName di Firebase Auth
                                if (!nome && !cognome && user.displayName) {
                                    const nameParts = user.displayName.split(' ');
                                    nome = nameParts[0] || '';
                                    cognome = nameParts.slice(1).join(' ') || '';
                                }
                                
                                // Crea il documento utente con merge per evitare sovrascritture
                                const newUserData = {
                                    id: user.uid,
                                    email: user.email,
                                    nome: nome,
                                    cognome: cognome,
                                    tenantId: tenantId,
                                    ruoli: ruoli.length > 0 ? ruoli : (tenantId ? ['amministratore'] : []), // Se ha tenant ma non ruoli, assegna amministratore
                                    stato: 'attivo',
                                    createdAt: serverTimestamp(),
                                    createdBy: user.uid,
                                    ultimoAccesso: serverTimestamp(),
                                    isOnline: true,
                                    lastSeen: serverTimestamp()
                                };
                                
                                await setDoc(userDocRef, newUserData, { merge: true });
                                console.log('‚úÖ Documento utente creato automaticamente con ruoli:', newUserData.ruoli);
                            }
                        }
                        
                        // Ricarica il documento
                        const newUserDoc = await getDoc(userDocRef);
                        if (newUserDoc.exists()) {
                            // Continua con il flusso normale usando i dati appena creati
                            const userData = newUserDoc.data();
                            console.log('‚úÖ Dati utente creati:', userData);
                            // Continua con il codice esistente usando userData invece di userDoc.data()
                            // Ma per ora, ricarichiamo tutto il blocco
                            const nomeCompleto = `${userData.nome || ''} ${userData.cognome || ''}`.trim();
                            const email = userData.email || user.email;
                            const ruoliFromDoc = userData.ruoli || [];
                            
                            console.log('‚úÖ Dati utente letti dopo creazione:', userData);
                            console.log('‚úÖ Ruoli letti:', ruoliFromDoc);
                            console.log('‚úÖ Tipo ruoli:', typeof ruoliFromDoc, Array.isArray(ruoliFromDoc));
                            
                            // Aggiorna ultimo accesso periodicamente
                            const onlineInterval = setInterval(async () => {
                                try {
                                    await updateDoc(userDocRef, {
                                        lastSeen: serverTimestamp()
                                    });
                                } catch (error) {
                                    console.warn('Errore aggiornamento stato online:', error);
                                    clearInterval(onlineInterval);
                                }
                            }, 30000);
                            
                            window.gfvOnlineInterval = onlineInterval;
                            
                            window.addEventListener('beforeunload', async () => {
                                try {
                                    await updateDoc(userDocRef, {
                                        isOnline: false
                                    });
                                } catch (error) {
                                    // Ignora errori durante il beforeunload
                                }
                            });
                            
                            // Se i ruoli non sono un array, prova a convertirli
                            let ruoliArray = ruoliFromDoc;
                            if (!Array.isArray(ruoliArray)) {
                                if (typeof ruoliArray === 'string') {
                                    ruoliArray = [ruoliArray];
                                } else if (ruoliArray && typeof ruoliArray === 'object') {
                                    ruoliArray = Object.values(ruoliArray);
                                } else {
                                    ruoliArray = [];
                                }
                                console.log('Ruoli convertiti:', ruoliArray);
                            }
                            
                            // Aggiorna header
                            document.getElementById('user-info').textContent = 
                                `Utente: ${nomeCompleto || 'N/A'} (${email})`;
                            
                            // Normalizza ruoli prima di mostrarli
                            const normalizedRoles = normalizeRoles(ruoliArray);
                            
                            // Mostra ruoli
                            const rolesContainer = document.getElementById('user-roles');
                            if (normalizedRoles.length > 0) {
                                rolesContainer.innerHTML = normalizedRoles.map(role => {
                                    const displayName = roleNames[role] || role.charAt(0).toUpperCase() + role.slice(1);
                                    return `<span class="role-badge">${displayName}</span>`;
                                }).join('');
                            } else {
                                rolesContainer.innerHTML = '<span class="role-badge">Nessun ruolo</span>';
                            }
                            
                            // Crea copia userData con ruoli normalizzati per il rendering
                            const userDataNormalized = {
                                ...userData,
                                ruoli: normalizedRoles
                            };
                            
                            console.log('Ruoli normalizzati:', normalizedRoles);
                            console.log('UserData normalizzato:', userDataNormalized);
                            
                            // Carica moduli disponibili dal tenant
                            let availableModules = [];
                            if (userData.tenantId) {
                                try {
                                    const tenantDoc = await getDoc(doc(db, 'tenants', userData.tenantId));
                                    if (tenantDoc.exists()) {
                                        const tenantData = tenantDoc.data();
                                        availableModules = tenantData.modules || [];
                                    }
                                } catch (e) {
                                    console.warn('Errore caricamento moduli tenant:', e);
                                }
                            }
                            
                            // Renderizza dashboard
                            await renderDashboard(userDataNormalized, availableModules);
                            return; // Esci qui per non eseguire il codice sotto
                        }
                    } catch (error) {
                        console.error('‚ùå Errore creazione documento utente:', error);
                        // Continua con il flusso di errore
                    }
                }

                if (userDoc.exists()) {
                    // Aggiorna ultimo accesso e imposta come online quando si carica la dashboard
                    try {
                        await updateDoc(userDocRef, {
                            ultimoAccesso: serverTimestamp(),
                            isOnline: true,
                            lastSeen: serverTimestamp()
                        });
                    } catch (error) {
                        console.warn('Errore aggiornamento ultimo accesso:', error);
                    }
                    
                    // Aggiorna periodicamente lo stato online (ogni 30 secondi)
                    const onlineInterval = setInterval(async () => {
                        try {
                            await updateDoc(userDocRef, {
                                lastSeen: serverTimestamp()
                            });
                        } catch (error) {
                            console.warn('Errore aggiornamento stato online:', error);
                            clearInterval(onlineInterval);
                        }
                    }, 30000); // Ogni 30 secondi
                    
                    // Quando l'utente chiude la pagina o naviga via, imposta offline
                    window.addEventListener('beforeunload', async () => {
                        try {
                            await updateDoc(userDocRef, {
                                isOnline: false
                            });
                        } catch (error) {
                            // Ignora errori durante il beforeunload
                        }
                    });
                    
                    // Salva l'interval per pulirlo al logout
                    window.gfvOnlineInterval = onlineInterval;
                    
                    console.log('üîç DEBUG: Sto leggendo il documento utente...');
                    const userDocUpdated = await getDoc(userDocRef);
                    console.log('üîç DEBUG: Documento letto, esiste?', userDocUpdated.exists());
                    
                    if (!userDocUpdated.exists()) {
                        console.error('‚ùå ERRORE: Il documento utente non esiste in Firestore!');
                        console.error('‚ùå User ID:', user.uid);
                        throw new Error('Documento utente non trovato');
                    }
                    
                    let userData = userDocUpdated.data();
                    console.log('üîç DEBUG: Dati utente letti:', userData);
                    console.log('üîç DEBUG: userData.ruoli =', userData.ruoli);
                    console.log('üîç DEBUG: userData.tenantId =', userData.tenantId);
                    
                    // FIX: Se l'utente ha tenantId null o ruoli vuoti, cerca il tenant creato da lui
                    const ruoliVuoti = !userData.ruoli || !Array.isArray(userData.ruoli) || userData.ruoli.length === 0;
                    const tenantIdMancante = !userData.tenantId;
                    
                    if (tenantIdMancante || ruoliVuoti) {
                        console.warn('‚ö†Ô∏è PROBLEMA RILEVATO: tenantId o ruoli mancanti');
                        console.warn('‚ö†Ô∏è tenantId nel documento:', userData.tenantId, 'ruoli:', userData.ruoli);
                        
                        let foundTenantId = null;
                        
                        // PRIMA: Prova a usare il tenantId da sessionStorage (se l'utente si √® appena registrato)
                        const expectedTenantId = sessionStorage.getItem('gfv_expected_tenant_id');
                        if (expectedTenantId) {
                            console.log('üîç Verifico tenantId da sessionStorage:', expectedTenantId);
                            try {
                                const tenantCheck = await getDoc(doc(db, 'tenants', expectedTenantId));
                                if (tenantCheck.exists()) {
                                    foundTenantId = expectedTenantId;
                                    console.log('‚úÖ TenantId da sessionStorage valido:', foundTenantId);
                                } else {
                                    console.warn('‚ö†Ô∏è TenantId da sessionStorage non trovato in Firestore');
                                }
                            } catch (error) {
                                console.warn('‚ö†Ô∏è Errore verifica tenantId da sessionStorage:', error);
                            }
                        }
                        
                        // SECONDA: Se non trovato, cerca tenant creato da questo utente
                        if (!foundTenantId) {
                            console.warn('‚ö†Ô∏è Cerco tenant creato da questo utente...');
                            try {
                                const tenantQuery = query(
                                    collection(db, 'tenants'),
                                    where('creatoDa', '==', user.uid)
                                );
                                const tenantSnapshot = await getDocs(tenantQuery);
                                
                                if (!tenantSnapshot.empty) {
                                    const tenantDoc = tenantSnapshot.docs[0];
                                    foundTenantId = tenantDoc.id;
                                    console.log('‚úÖ Trovato tenant creato da questo utente:', foundTenantId);
                                } else {
                                    console.warn('‚ö†Ô∏è Nessun tenant trovato per questo utente');
                                }
                            } catch (error) {
                                console.error('‚ùå Errore durante ricerca tenant:', error);
                            }
                        }
                        
                        // Se abbiamo trovato un tenantId, aggiorna il documento
                        if (foundTenantId) {
                            const updates = {};
                            
                            if (tenantIdMancante) {
                                updates.tenantId = foundTenantId;
                                userData.tenantId = foundTenantId;
                                console.log('‚úÖ Aggiornato tenantId:', foundTenantId);
                            }
                            
                            if (ruoliVuoti) {
                                updates.ruoli = ['amministratore'];
                                userData.ruoli = ['amministratore'];
                                console.log('‚úÖ Assegnato ruolo amministratore');
                            }
                            
                            // Aggiorna il documento utente
                            if (Object.keys(updates).length > 0) {
                                await updateDoc(userDocRef, updates);
                                console.log('‚úÖ Documento utente aggiornato con:', updates);
                                
                                // Attendi propagazione
                                await new Promise(resolve => setTimeout(resolve, 500));
                                
                                // Ricarica i dati aggiornati
                                const updatedDoc = await getDoc(userDocRef);
                                if (updatedDoc.exists()) {
                                    userData = updatedDoc.data();
                                    console.log('‚úÖ Dati utente aggiornati:', userData);
                                }
                            }
                        } else {
                            console.error('‚ùå ERRORE: Impossibile trovare tenant per questo utente!');
                            console.error('‚ùå User ID:', user.uid);
                            console.error('‚ùå Email:', user.email);
                        }
                        
                        // Pulisci sessionStorage dopo aver usato i dati
                        sessionStorage.removeItem('gfv_user_just_registered');
                        sessionStorage.removeItem('gfv_expected_tenant_id');
                    }
                    
                    const nomeCompleto = `${userData.nome || ''} ${userData.cognome || ''}`.trim();
                    const email = userData.email || user.email;
                    const ruoli = userData.ruoli || [];
                    
                    // Debug: log per vedere cosa viene letto
                    console.log('‚úÖ Dati utente letti:', userData);
                    console.log('‚úÖ Ruoli letti:', ruoli);
                    console.log('‚úÖ Tipo ruoli:', typeof ruoli, Array.isArray(ruoli));
                    
                    // Se i ruoli non sono un array, prova a convertirli
                    let ruoliArray = ruoli;
                    if (!Array.isArray(ruoli)) {
                        if (typeof ruoli === 'string') {
                            ruoliArray = [ruoli];
                        } else if (ruoli && typeof ruoli === 'object') {
                            ruoliArray = Object.values(ruoli);
                        } else {
                            ruoliArray = [];
                        }
                        console.log('Ruoli convertiti:', ruoliArray);
                    }
                    
                    // Aggiorna header
                    document.getElementById('user-info').textContent = 
                        `Utente: ${nomeCompleto || 'N/A'} (${email})`;
                    
                    // Normalizza ruoli prima di mostrarli
                    const normalizedRoles = normalizeRoles(ruoliArray);
                    
                    // Mostra ruoli
                    const rolesContainer = document.getElementById('user-roles');
                    if (normalizedRoles.length > 0) {
                        rolesContainer.innerHTML = normalizedRoles.map(role => {
                            const displayName = roleNames[role] || role.charAt(0).toUpperCase() + role.slice(1);
                            return `<span class="role-badge">${displayName}</span>`;
                        }).join('');
                    } else {
                        rolesContainer.innerHTML = '<span class="role-badge">Nessun ruolo</span>';
                    }
                    
                    // Crea copia userData con ruoli normalizzati per il rendering
                    const userDataNormalized = {
                        ...userData,
                        ruoli: normalizedRoles
                    };
                    
                    console.log('Ruoli normalizzati:', normalizedRoles);
                    console.log('UserData normalizzato:', userDataNormalized);
                    console.log('üîç DEBUG: normalizedRoles.length =', normalizedRoles.length);
                    console.log('üîç DEBUG: userData.tenantId =', userData.tenantId);
                    
                    // Fix automatico: se l'utente non ha ruoli ma ha un tenant, assegna amministratore
                    if (normalizedRoles.length === 0 && userData.tenantId) {
                        console.warn('‚ö†Ô∏è ATTENZIONE: normalizedRoles √® vuoto ma tenantId esiste!');
                        console.warn('‚ö†Ô∏è Ruoli originali:', ruoli);
                        console.warn('‚ö†Ô∏è Ruoli array:', ruoliArray);
                        console.warn('‚ö†Ô∏è Ruoli normalizzati:', normalizedRoles);
                        console.warn('‚ö†Ô∏è Utente senza ruoli ma con tenant, assegno amministratore automaticamente...');
                        try {
                            // Salva i ruoli come array
                            await updateDoc(doc(db, 'users', user.uid), {
                                ruoli: ['amministratore']
                            });
                            console.log('‚úÖ Ruoli aggiornati in Firestore');
                            
                            // Attendi un momento per assicurarsi che Firestore abbia processato
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            
                            // Ricarica i dati
                            const updatedDoc = await getDoc(doc(db, 'users', user.uid));
                            if (updatedDoc.exists()) {
                                const updatedData = updatedDoc.data();
                                const updatedRuoli = updatedData.ruoli || [];
                                console.log('Ruoli letti dopo fix:', updatedRuoli);
                                
                                // Se ancora non ci sono ruoli, prova a convertirli
                                let updatedRuoliArray = updatedRuoli;
                                if (!Array.isArray(updatedRuoli)) {
                                    if (typeof updatedRuoli === 'string') {
                                        updatedRuoliArray = [updatedRuoli];
                                    } else if (updatedRuoli && typeof updatedRuoli === 'object') {
                                        updatedRuoliArray = Object.values(updatedRuoli);
                                    } else {
                                        updatedRuoliArray = ['amministratore']; // Fallback
                                    }
                                }
                                
                                const updatedNormalized = normalizeRoles(updatedRuoliArray);
                                console.log('Ruoli normalizzati dopo fix:', updatedNormalized);
                                
                                // Aggiorna display
                                if (updatedNormalized.length > 0) {
                                    const rolesContainer = document.getElementById('user-roles');
                                    rolesContainer.innerHTML = updatedNormalized.map(role => {
                                        const displayName = roleNames[role] || role.charAt(0).toUpperCase() + role.slice(1);
                                        return `<span class="role-badge">${displayName}</span>`;
                                    }).join('');
                                }
                                
                                // Carica moduli disponibili
                                let availableModules = [];
                                if (updatedData.tenantId) {
                                    try {
                                        const tenantDoc = await getDoc(doc(db, 'tenants', updatedData.tenantId));
                                        if (tenantDoc.exists()) {
                                            const tenantData = tenantDoc.data();
                                            availableModules = tenantData.modules || [];
                                        }
                                    } catch (error) {
                                        console.warn('Errore caricamento moduli tenant:', error);
                                    }
                                }
                                
                                // La visibilit√† del link "Invita Collaboratore" viene gestita in renderDashboard
                                // in base a se Manodopera √® attivo o no
                            
                            // Renderizza con ruoli aggiornati e moduli
                                await renderDashboard({
                                    ...updatedData,
                                    ruoli: updatedNormalized
                                }, availableModules);
                                return; // Esci qui per non eseguire il renderDashboard sotto
                            } else {
                                console.error('‚ùå Documento non trovato dopo update');
                            }
                        } catch (error) {
                            console.error('‚ùå Errore assegnazione ruolo automatica:', error);
                            console.error('Dettagli errore:', error.message, error.stack);
                            // Anche in caso di errore, prova a mostrare la dashboard con ruolo amministratore
                            const rolesContainer = document.getElementById('user-roles');
                            rolesContainer.innerHTML = '<span class="role-badge">üëë Amministratore</span>';
                            
                            // Carica moduli disponibili
                            let availableModules = [];
                            if (userData.tenantId) {
                                try {
                                    const tenantDoc = await getDoc(doc(db, 'tenants', userData.tenantId));
                                    if (tenantDoc.exists()) {
                                        const tenantData = tenantDoc.data();
                                        availableModules = tenantData.modules || [];
                                    }
                                } catch (e) {
                                    console.warn('Errore caricamento moduli tenant:', e);
                                }
                            }
                            
                            // La visibilit√† del link "Invita Collaboratore" viene gestita in renderDashboard
                            // in base a se Manodopera √® attivo o no
                            
                            // Renderizza con ruolo amministratore di default
                            await renderDashboard({
                                ...userData,
                                ruoli: ['amministratore']
                            }, availableModules);
                            return;
                        }
                    }
                    
                    // Carica moduli disponibili dal tenant
                    let availableModules = [];
                    if (userData.tenantId) {
                        try {
                            const tenantDoc = await getDoc(doc(db, 'tenants', userData.tenantId));
                            if (tenantDoc.exists()) {
                                const tenantData = tenantDoc.data();
                                availableModules = tenantData.modules || [];
                            }
                        } catch (error) {
                            console.warn('Errore caricamento moduli tenant:', error);
                        }
                    }
                    
                    // La visibilit√† del link "Invita Collaboratore" viene gestita in renderDashboard
                    // in base a se Manodopera √® attivo o no
                    
                    // Renderizza dashboard con moduli
                    await renderDashboard(userDataNormalized, availableModules);
                } else {
                    document.getElementById('user-info').textContent = 
                        `Utente: ${user.email}`;
                    document.getElementById('user-roles').innerHTML = 
                        '<span class="role-badge">Nessun ruolo</span>';
                    
                    // Renderizza dashboard vuota
                    renderDashboard({ ruoli: [] }, []);
                }
            } catch (error) {
                console.error('Errore caricamento dati utente:', error);
                document.getElementById('user-info').textContent = 
                    `Utente: ${user.email}`;
                document.getElementById('user-roles').innerHTML = 
                    '<span class="role-badge">Errore caricamento</span>';
                
                // Renderizza dashboard vuota
                renderDashboard({ ruoli: [] }, []);
            }
        });

        // Pulizia listener quando si chiude la pagina
        window.addEventListener('beforeunload', () => {
            if (manutenzioniUnsubscribe) {
                manutenzioniUnsubscribe();
                manutenzioniUnsubscribe = null;
            }
            if (guastiUnsubscribe) {
                guastiUnsubscribe();
                guastiUnsubscribe = null;
            }
        });

        // Logout
        document.getElementById('logout-button').addEventListener('click', async () => {
            try {
                // Ferma l'aggiornamento dello stato online
                if (window.gfvOnlineInterval) {
                    clearInterval(window.gfvOnlineInterval);
                }
                
                // Pulizia listener manutenzioni e guasti
                if (manutenzioniUnsubscribe) {
                    manutenzioniUnsubscribe();
                    manutenzioniUnsubscribe = null;
                }
                if (guastiUnsubscribe) {
                    guastiUnsubscribe();
                    guastiUnsubscribe = null;
                }
                
                // Imposta offline prima del logout
                const user = auth.currentUser;
                if (user) {
                    try {
                        const userDocRef = doc(db, 'users', user.uid);
                        await updateDoc(userDocRef, {
                            isOnline: false
                        });
                    } catch (error) {
                        console.warn('Errore aggiornamento stato offline:', error);
                    }
                }
                
                // Rimuovi anche il flag di sessione
                sessionStorage.removeItem('gfv_expected_user_id');
                sessionStorage.removeItem('gfv_user_just_registered');
                await signOut(auth);
                window.location.href = './auth/login-standalone.html';
            } catch (error) {
                console.error('Errore logout:', error);
                alert('Errore durante il logout');
            }
        });

        console.log('‚úÖ Dashboard caricata');
    </script>
    
    <!-- Service Worker Registration for PWA -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/gfv-platform/service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker registrato con successo:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Registrazione Service Worker fallita:', error);
                    });
            });
        }
    </script>
</body>
</html>

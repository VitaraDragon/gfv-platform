rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper: verifica autenticazione
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper: verifica che l'utente appartenga al tenant
    // Supporta sia tenantMemberships (nuovo) che tenantId (deprecato, retrocompatibilità)
    // Legge il documento users dell'utente corrente (ha sempre permesso di lettura)
    function belongsToTenant(tenantId) {
      return isAuthenticated() && (
        // Verifica retrocompatibilità: tenantId deprecato
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId ||
        // Verifica nuova struttura: tenantMemberships - usa keys().hasAny() invece di 'in'
        (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships.keys().hasAny([tenantId]) &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships[tenantId].stato == 'attivo')
      );
    }
    
    // Helper: verifica ruolo utente per un tenant specifico
    // Supporta sia tenantMemberships (nuovo) che ruoli deprecati (retrocompatibilità)
    // @param role - Nome ruolo da verificare
    // @param tenantId - ID tenant (opzionale, se non specificato usa tenantId deprecato)
    function hasRole(role, tenantId) {
      return isAuthenticated() && (
        // Se tenantId è specificato, verifica prima in tenantMemberships - usa keys().hasAny() invece di 'in'
        (tenantId != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships.keys().hasAny([tenantId]) &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships[tenantId].stato == 'attivo' &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships[tenantId].ruoli != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantMemberships[tenantId].ruoli.hasAny([role])) ||
        // Retrocompatibilità: se tenantId è specificato ma non in tenantMemberships, verifica tenantId deprecato
        (tenantId != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.ruoli != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.ruoli.hasAny([role])) ||
        // Retrocompatibilità: verifica ruoli deprecati (se tenantId è null)
        (tenantId == null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.ruoli != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.ruoli.hasAny([role]))
      );
    }
    
    // Helper: verifica se è Manager o Amministratore per un tenant
    // @param tenantId - ID tenant (opzionale, se non specificato usa tenantId deprecato)
    function isManagerOrAdmin(tenantId) {
      return isAuthenticated() &&
             (hasRole('manager', tenantId) || hasRole('amministratore', tenantId));
    }
    
    // Helper: verifica se è Caposquadra per un tenant
    // @param tenantId - ID tenant (opzionale, se non specificato usa tenantId deprecato)
    function isCaposquadra(tenantId) {
      return isAuthenticated() && hasRole('caposquadra', tenantId);
    }
    
    // Collection: users (globale)
    // IMPORTANTE: Permetti lettura del proprio documento per evitare dipendenza circolare
    // Permetti anche lettura di utenti dello stesso tenant (per statistiche, report, ecc.)
    // Permetti anche lettura a manager/admin per verificare se un'email esiste già (necessario per inviti)
    match /users/{userId} {
      allow read: if isAuthenticated() && (
        request.auth.uid == userId || 
        // Permetti lettura se l'utente richiedente appartiene allo stesso tenant del documento richiesto
        // Gestisce anche il caso in cui resource.data.tenantId potrebbe essere null o non esistere
        (resource.data.keys().hasAny(['tenantId']) &&
         resource.data.tenantId != null && 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == resource.data.tenantId) ||
        // Permetti lettura a manager/admin per verificare se un'email esiste già (necessario per inviti)
        // Verifica se l'utente richiedente è manager o admin (usa ruoli deprecati per semplicità)
        (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.ruoli != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.ruoli.hasAny(['manager', 'amministratore']))
      );
      
      // Creazione: solo durante registrazione (utente crea il proprio documento)
      allow create: if isAuthenticated() && request.auth.uid == userId;
      
      // Aggiornamento: 
      // - Utente può aggiornare il proprio documento
      // - Manager/Admin possono aggiornare documenti di utenti dello stesso tenant, ma solo campi contratto
      allow update: if isAuthenticated() && (
        // Caso 1: Utente aggiorna il proprio documento
        request.auth.uid == userId ||
        // Caso 2: Manager/Admin aggiorna documento di utente dello stesso tenant (solo campi contratto)
        // NOTA: Per users collection, non abbiamo tenantId nel path, quindi usiamo retrocompatibilità
        (resource.data.keys().hasAny(['tenantId']) &&
         resource.data.tenantId != null &&
         isManagerOrAdmin(resource.data.tenantId) &&
         // Verifica che l'utente da aggiornare appartenga allo stesso tenant
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId != null &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == resource.data.tenantId &&
         // Permetti aggiornamento solo di questi campi specifici (campi contratto)
         request.resource.data.diff(resource.data).affectedKeys().hasOnly([
           'tipoOperaio',
           'tipoContratto',
           'dataInizioContratto',
           'dataScadenzaContratto',
           'noteContratto',
           'tariffaPersonalizzata'
         ]))
      );
      
      // Eliminazione: solo utente può eliminare il proprio documento (o disattivarlo)
      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // Collection: tenants (globale)
    match /tenants/{tenantId} {
      // Lettura: autenticati del tenant O lettura pubblica (necessaria per pagina accettazione preventivo che cerca in tutti i tenant)
      allow read: if isAuthenticated() && belongsToTenant(tenantId) || true;
      
      // Scrittura: 
      // - Manager/admin del tenant possono scrivere (operazioni normali)
      // - Utente autenticato può CREARE un nuovo tenant durante la registrazione (quando non ha ancora un documento users)
      allow create: if isAuthenticated() && (
        // Caso 1: Utente già registrato (ha documento users) - deve essere manager/admin del tenant
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         isManagerOrAdmin(tenantId) && 
         belongsToTenant(tenantId)) ||
        // Caso 2: Utente in registrazione (non ha ancora documento users) - può creare tenant se è il creatore
        (!exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         request.resource.data.creatoDa == request.auth.uid)
      );
      
      // Aggiornamento/Eliminazione: solo manager/admin del tenant
      allow update, delete: if isAuthenticated() && isManagerOrAdmin(tenantId) && belongsToTenant(tenantId);
    }
    
    // Collection: inviti (globale)
    // NOTA: Permettiamo lettura pubblica per permettere verifica token durante registrazione
    // I dati dell'invito (email, nome, cognome, ruoli) non sono sensibili e devono essere accessibili
    // La sicurezza è garantita dal token unico e casuale che viene verificato
    match /inviti/{invitoId} {
      // Lettura: pubblica (necessaria per registrazione con token non autenticato)
      allow read: if true;
      
      // TEMP: allenta tutto per test inviti (permesso totale) - DA RIPRISTINARE
      allow create: if true;
      
      // Aggiornamento: 
      // - Manager/admin del tenant dell'invito possono aggiornare tutto
      // - Utente appena registrato può aggiornare solo il proprio invito (stato -> "accettato")
      allow update: if isAuthenticated() && (
        // Manager/admin del tenant dell'invito: possono aggiornare tutto
        (resource.data.tenantId != null &&
         belongsToTenant(resource.data.tenantId) &&
         isManagerOrAdmin(resource.data.tenantId)) ||
        // Utente appena registrato: può aggiornare solo il proprio invito
        // Verifica che l'email dell'invito corrisponda all'email dell'utente autenticato
        (resource.data.email != null &&
         // Prova prima con email dal token (più veloce), altrimenti leggi documento users
         // NOTA: Le email in Firebase Auth sono già normalizzate in lowercase, quindi il confronto diretto è sicuro
         ((request.auth.token.email != null &&
           resource.data.email == request.auth.token.email) ||
          (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email != null &&
           resource.data.email == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email)) &&
         // Permette aggiornamento solo di questi campi specifici
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['stato', 'accettatoIl']) &&
         // Verifica che lo stato sia valido (solo transizione a "accettato")
         request.resource.data.stato == 'accettato' &&
         resource.data.stato == 'invitato')
      );
      
      // Eliminazione: solo manager/admin del tenant dell'invito
      allow delete: if isAuthenticated() && 
        resource.data.tenantId != null &&
        belongsToTenant(resource.data.tenantId) &&
        isManagerOrAdmin(resource.data.tenantId);
    }
    
    // Dati tenant (multi-tenant) - Regola generica per tutte le subcollection
    // NOTA: Le regole specifiche hanno priorità, questa è solo un fallback
    // DISABILITATA per evitare conflitti con onSnapshot
    // match /tenants/{tenantId}/{document=**} {
    //   allow read: if isAuthenticated() && belongsToTenant(tenantId);
    // }
    
    // Regole specifiche per collection Conto Terzi
    
    // Collection: clienti
    match /tenants/{tenantId}/clienti/{clienteId} {
      // Lettura: autenticati del tenant O lettura pubblica (necessaria per pagina accettazione preventivo)
      // NOTA: Meno sicuro, ma necessario per mostrare dati cliente nel preventivo pubblico
      allow read: if isAuthenticated() && belongsToTenant(tenantId) || true;
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }
    
    // Collection: tariffe
    match /tenants/{tenantId}/tariffe/{tariffaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }
    
    // Collection: preventivi
    match /tenants/{tenantId}/preventivi/{preventivoId} {
      // Lettura: autenticati del tenant O lettura pubblica (necessaria per query con tokenAccettazione)
      // NOTA: Per query, dobbiamo permettere lettura pubblica, ma solo preventivi con tokenAccettazione saranno accessibili
      // La sicurezza è garantita dal fatto che il token è unico e casuale
      allow read: if isAuthenticated() && belongsToTenant(tenantId) || true;
      
      // Creazione: solo manager/admin autenticati
      allow create: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
      
      // Aggiornamento: manager/admin autenticati O aggiornamento pubblico solo di stato/dataAccettazione per preventivi con token
      allow update: if (isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId)) ||
                     (resource.data.tokenAccettazione != null && 
                      // Permetti aggiornamento solo di questi campi specifici
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['stato', 'dataAccettazione', 'dataRifiuto']) &&
                      // Verifica che lo stato sia valido per accettazione/rifiuto
                      (request.resource.data.stato == 'accettato_email' || request.resource.data.stato == 'rifiutato'));
      
      // Eliminazione: solo manager/admin autenticati
      allow delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }
    
    // Collection: poderi-clienti
    match /tenants/{tenantId}/poderi-clienti/{podereId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }
    
    // Collection: terreni (già esistente, ma assicuriamoci che funzioni)
    match /tenants/{tenantId}/terreni/{terrenoId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: poderi (aziendali, non clienti)
    match /tenants/{tenantId}/poderi/{podereId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: liste (dati personalizzati, es. colture)
    match /tenants/{tenantId}/liste/{listaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: impostazioni (impostazioni tenant, es. coefficienti morfologia, tariffe operai)
    match /tenants/{tenantId}/impostazioni/{impostazioneId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: categorie (unificata per lavori e attrezzi)
    match /tenants/{tenantId}/categorie/{categoriaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: tipiLavoro (tipi di lavoro gerarchici)
    match /tenants/{tenantId}/tipiLavoro/{tipoId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: colture (colture unificate)
    match /tenants/{tenantId}/colture/{colturaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: categorieLavori (vecchia collezione, per migrazione)
    match /tenants/{tenantId}/categorieLavori/{categoriaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: categorieAttrezzi (vecchia collezione, per migrazione)
    match /tenants/{tenantId}/categorieAttrezzi/{categoriaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }
    
    // Collection: lavori (già esistente)
    match /tenants/{tenantId}/lavori/{lavoroId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      
      // Creazione ed eliminazione: solo manager/admin
      allow create, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
      
      // Aggiornamento: manager/admin possono aggiornare tutto
      // Caposquadra può aggiornare solo campi di progresso e stato per lavori assegnati a lui
      // Operaio può segnare come completato lavori autonomi assegnati a lui
      allow update: if isAuthenticated() && belongsToTenant(tenantId) && (
        // Manager/Admin: possono aggiornare tutto
        isManagerOrAdmin(tenantId) ||
        // Caposquadra: può aggiornare solo campi di progresso e stato per lavori di squadra assegnati a lui
        (isCaposquadra(tenantId) && 
         // Verifica che il lavoro sia assegnato a questo caposquadra (lavoro di squadra, non autonomo)
         resource.data.caposquadraId == request.auth.uid &&
         resource.data.operaioId == null &&
         // Permetti aggiornamento solo di questi campi specifici
         request.resource.data.diff(resource.data).affectedKeys().hasOnly([
           'superficieTotaleLavorata',
           'superficieRimanente',
           'percentualeCompletamento',
           'percentualeCompletamentoTracciata',
           'giorniEffettivi',
           'statoProgresso',
           'stato',
           'completatoDa',
           'completatoIl',
           'aggiornatoIl'
         ]) &&
         // Verifica che lo stato sia valido (solo transizioni permesse)
         (request.resource.data.stato == 'in_corso' ||
          request.resource.data.stato == 'completato' ||
          request.resource.data.stato == 'completato_da_approvare' ||
          request.resource.data.stato == resource.data.stato)) ||
        // Operaio: può segnare come completato lavori autonomi assegnati a lui
        // E può aggiornare progressi quando traccia zone lavorate
        (hasRole('operaio', tenantId) &&
         // Verifica che il lavoro sia autonomo assegnato a questo operaio
         resource.data.operaioId == request.auth.uid &&
         resource.data.caposquadraId == null &&
         // Permetti aggiornamento solo di questi campi specifici
         request.resource.data.diff(resource.data).affectedKeys().hasOnly([
           'stato',
           'percentualeCompletamentoTracciata',
           'superficieTotaleLavorata',
           'superficieRimanente',
           'percentualeCompletamento',
           'giorniEffettivi',
           'statoProgresso',
           'completatoDa',
           'completatoIl',
           'aggiornatoIl'
         ]) &&
         // Verifica che lo stato sia valido (solo transizioni permesse per operai)
         (request.resource.data.stato == 'completato_da_approvare' ||
          request.resource.data.stato == 'in_corso' ||
          request.resource.data.stato == resource.data.stato))
      );
    }
    
    // Collection: attivita (già esistente)
    match /tenants/{tenantId}/attivita/{attivitaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId);
    }

    // Collection: squadre (Manodopera)
    match /tenants/{tenantId}/squadre/{squadraId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: guasti (Parco Macchine)
    // NOTA: Usa controllo diretto invece di belongsToTenant per evitare problemi con onSnapshot
    match /tenants/{tenantId}/guasti/{guastoId} {
      allow read: if isAuthenticated() && 
                     get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
      allow create, update, delete: if isAuthenticated() && 
                                       get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
    }

    // Collection: macchine (Parco Macchine)
    match /tenants/{tenantId}/macchine/{macchinaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: vigneti (Modulo Vigneto)
    match /tenants/{tenantId}/vigneti/{vignetoId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: vendemmie (sotto vigneti)
    match /tenants/{tenantId}/vigneti/{vignetoId}/vendemmie/{vendemmiaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: potature (sotto vigneti)
    match /tenants/{tenantId}/vigneti/{vignetoId}/potature/{potaturaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: trattamenti (sotto vigneti)
    match /tenants/{tenantId}/vigneti/{vignetoId}/trattamenti/{trattamentoId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: statistiche_vigneto (aggregazioni pre-calcolate per performance)
    // NOTA: Permettiamo creazione/aggiornamento a tutti gli utenti autenticati del tenant
    // perché le aggregazioni sono solo cache e vengono calcolate automaticamente
    // La sicurezza è garantita dal fatto che contengono solo dati aggregati già accessibili
    match /tenants/{tenantId}/statistiche_vigneto/{statsId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update: if isAuthenticated() && belongsToTenant(tenantId);
      allow delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: statistiche_frutteto (aggregazioni pre-calcolate per performance)
    match /tenants/{tenantId}/statistiche_frutteto/{statsId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update: if isAuthenticated() && belongsToTenant(tenantId);
      allow delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: frutteti (Modulo Frutteto)
    match /tenants/{tenantId}/frutteti/{fruttetoId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: raccolte (sotto frutteti)
    match /tenants/{tenantId}/frutteti/{fruttetoId}/raccolte/{raccoltaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: potature (sotto frutteti)
    match /tenants/{tenantId}/frutteti/{fruttetoId}/potature/{potaturaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: trattamenti (sotto frutteti)
    match /tenants/{tenantId}/frutteti/{fruttetoId}/trattamenti/{trattamentoId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: raccolteFrutta (raccolte frutta standalone, non sotto frutteti)
    match /tenants/{tenantId}/raccolteFrutta/{raccoltaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: pianificazioni-impianti (pianificazioni nuovi impianti)
    match /tenants/{tenantId}/pianificazioni-impianti/{pianificazioneId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Subcollection: oreOperai (sotto lavori)
    match /tenants/{tenantId}/lavori/{lavoroId}/oreOperai/{oraId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId);
    }

    // Subcollection: zoneLavorate (sotto lavori)
    match /tenants/{tenantId}/lavori/{lavoroId}/zoneLavorate/{zonaId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId);
    }

    // Subcollection: manutenzioni (sotto macchine)
    match /tenants/{tenantId}/macchine/{macchinaId}/manutenzioni/{manutenzioneId} {
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      allow create, update, delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }

    // Collection: comunicazioni (comunicazioni caposquadra -> operai)
    match /tenants/{tenantId}/comunicazioni/{comunicazioneId} {
      // Lettura: operai e caposquadra del tenant possono leggere comunicazioni dove sono destinatari
      // NOTA: Il filtro per destinatari viene fatto lato client, qui permettiamo lettura a tutti gli utenti del tenant
      allow read: if isAuthenticated() && belongsToTenant(tenantId);
      
      // Creazione: solo caposquadra e manager/admin
      allow create: if isAuthenticated() && belongsToTenant(tenantId) && 
                     (hasRole('caposquadra', tenantId) || isManagerOrAdmin(tenantId));
      
      // Aggiornamento: caposquadra/manager/admin possono aggiornare tutto, operai solo il campo conferme
      allow update: if isAuthenticated() && belongsToTenant(tenantId) && (
        // Caposquadra/manager/admin: possono aggiornare tutto
        (hasRole('caposquadra', tenantId) || isManagerOrAdmin(tenantId)) ||
        // Operai: possono aggiornare solo il campo conferme (per confermare ricezione)
        (hasRole('operaio', tenantId) && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['conferme']))
      );
      
      // Eliminazione: solo manager/admin
      allow delete: if isAuthenticated() && belongsToTenant(tenantId) && isManagerOrAdmin(tenantId);
    }
  }
}


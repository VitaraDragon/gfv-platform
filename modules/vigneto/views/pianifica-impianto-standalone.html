<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pianificazione Nuovo Impianto - GFV Platform</title>
    <link rel="manifest" href="../../../manifest.json">
    <meta name="theme-color" content="#6A1B9A">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #E1BEE7 0%, #6A1B9A 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #6A1B9A 0%, #4A148C 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-primary:hover {
            background: rgba(255,255,255,0.3);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .layout-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-top: 20px;
        }

        .map-container {
            position: relative;
            height: 600px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            max-height: 600px;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #6A1B9A;
            margin-bottom: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #6A1B9A;
        }

        .form-group small {
            display: block;
            margin-top: 5px;
            color: #6c757d;
            font-size: 12px;
        }

        /* Stili per controlli rotazione */
        .rotation-preset {
            margin-bottom: 15px;
        }

        .rotation-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .btn-rotation {
            width: 40px;
            height: 40px;
            border: 2px solid #6A1B9A;
            background: white;
            color: #6A1B9A;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .btn-rotation:hover {
            background: #6A1B9A;
            color: white;
        }

        .btn-rotation:active {
            transform: scale(0.95);
        }

        .rotation-slider-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .rotation-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .rotation-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6A1B9A;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rotation-slider::-webkit-slider-thumb:hover {
            background: #4A148C;
            transform: scale(1.2);
        }

        .rotation-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6A1B9A;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .rotation-slider::-moz-range-thumb:hover {
            background: #4A148C;
            transform: scale(1.2);
        }

        .rotation-value-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
            color: #6A1B9A;
            padding: 5px 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .rotation-compass {
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .calculations {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .calc-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .calc-item:last-child {
            border-bottom: none;
        }

        .calc-label {
            font-weight: 500;
            color: #495057;
        }

        .calc-value {
            font-weight: 600;
            color: #6A1B9A;
        }

        .terreno-selector {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        @media (max-width: 1200px) {
            .layout-grid {
                grid-template-columns: 1fr;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>üìê Pianificazione Nuovo Impianto</h1>
                <p style="opacity: 0.9; margin-top: 5px;">Calcola automaticamente file, ceppi, pali e materiali necessari</p>
            </div>
            <div class="header-actions">
                <a href="vigneto-dashboard-standalone.html" class="btn btn-primary">‚Üê Dashboard</a>
            </div>
        </div>

        <div class="content">
            <!-- Selezione Terreno -->
            <div class="terreno-selector">
                <div class="form-group">
                    <label for="terrenoSelect">Seleziona Terreno *</label>
                    <select id="terrenoSelect" class="form-control">
                        <option value="">-- Seleziona un terreno --</option>
                    </select>
                    <small>Seleziona un terreno con poligono mappato per iniziare la pianificazione</small>
                </div>
            </div>

            <!-- Alert se terreno non selezionato -->
            <div id="alertNoTerreno" class="alert alert-info" style="display: none;">
                <strong>‚ÑπÔ∏è Informazione:</strong> Seleziona un terreno dalla lista sopra per visualizzare la mappa e iniziare la pianificazione.
            </div>

            <!-- Layout Mappa + Pannello Controllo -->
            <div id="planningLayout" style="display: none;">
                <div class="layout-grid">
                    <!-- Mappa -->
                    <div class="map-container">
                        <div id="map"></div>
                    </div>

                    <!-- Pannello Controllo -->
                    <div class="control-panel">
                        <!-- Parametri Impianto -->
                        <div class="section">
                            <h3 class="section-title">üìê Parametri Impianto</h3>
                            
                            <div class="form-group">
                                <label for="tipoColtura">Tipo Coltura *</label>
                                <select id="tipoColtura">
                                    <option value="vigneto">üçá Vigneto</option>
                                    <option value="frutteto">üçé Frutteto</option>
                                    <option value="oliveto">ü´í Oliveto</option>
                                </select>
                            </div>

                            <div class="form-group" id="formaAllevamentoGroup" style="display: none;">
                                <label for="formaAllevamento">Forma di Allevamento</label>
                                <select id="formaAllevamento">
                                    <option value="">Seleziona forma di allevamento</option>
                                </select>
                                <small style="color: #666; font-size: 12px; margin-top: 5px; display: block;">
                                    Seleziona la forma di allevamento per il calcolo dei materiali
                                </small>
                            </div>

                            <div class="form-group">
                                <label for="angoloRotazione">Orientamento Reticolato</label>
                                
                                <!-- Dropdown direzioni predefinite -->
                                <select id="direzionePredefinita" class="rotation-preset">
                                    <option value="custom">Personalizzato</option>
                                    <option value="0">Nord-Sud (0¬∞)</option>
                                    <option value="45">Nord-Est / Sud-Ovest (45¬∞)</option>
                                    <option value="90">Est-Ovest (90¬∞)</option>
                                    <option value="135">Sud-Est / Nord-Ovest (135¬∞)</option>
                                    <option value="180">Sud-Nord (180¬∞)</option>
                                    <option value="225">Sud-Ovest / Nord-Est (225¬∞)</option>
                                    <option value="270">Ovest-Est (270¬∞)</option>
                                    <option value="315">Nord-Ovest / Sud-Est (315¬∞)</option>
                                </select>
                                
                                <!-- Controlli rotazione -->
                                <div class="rotation-controls">
                                    <button type="button" class="btn-rotation" id="btnRotazioneMinus" title="Ruota di -1¬∞">‚àí</button>
                                    
                                    <div class="rotation-slider-container">
                                        <input type="range" id="angoloRotazioneSlider" min="0" max="360" value="0" step="1" class="rotation-slider">
                                        <div class="rotation-value-display">
                                            <span id="angoloRotazioneDisplay">0¬∞</span>
                                            <span class="rotation-compass">üß≠</span>
                                        </div>
                                    </div>
                                    
                                    <button type="button" class="btn-rotation" id="btnRotazionePlus" title="Ruota di +1¬∞">+</button>
                                </div>
                                
                                <!-- Campo nascosto per valore preciso -->
                                <input type="hidden" id="angoloRotazione" value="0">
                                
                                <small>Seleziona una direzione predefinita o usa lo slider per regolazioni fini</small>
                            </div>

                            <div class="form-group">
                                <label>Larghezza Carraie (m)</label>
                                
                                <!-- Pulsanti selezione rapida -->
                                <div style="margin-bottom: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
                                    <button type="button" id="btnSelezionaPrincipali" style="padding: 6px 12px; background: #6A1B9A; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500;">üéØ Principali (6m)</button>
                                    <button type="button" id="btnSelezionaLaterali" style="padding: 6px 12px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500;">‚ÜîÔ∏è Laterali (4m)</button>
                                    <button type="button" id="btnConfigurazioneTipica" style="padding: 6px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500;">‚ö° Configurazione Tipica</button>
                                </div>
                                
                                <!-- Lista dinamica di tutte le carraie con checkbox -->
                                <div id="listaCarraie" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 5px; background: #f9f9f9;">
                                    <div style="font-size: 11px; color: #6c757d; margin-bottom: 8px; font-weight: 500;">Seleziona le carraie da configurare:</div>
                                    <!-- La lista verr√† popolata dinamicamente da JavaScript -->
                                </div>
                                
                                <!-- Input per la larghezza del gruppo selezionato -->
                                <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                                    <div style="flex: 1;">
                                        <label for="larghezzaCarraieSelezionate" style="font-size: 12px; font-weight: 500; color: #6c757d;">Larghezza carraie selezionate (m)</label>
                                        <input type="number" id="larghezzaCarraieSelezionate" step="0.1" min="0" value="2.0" style="width: 100%;">
                                    </div>
                                    <button type="button" id="applicaLarghezzaCarraie" style="margin-top: 20px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Applica</button>
                                </div>
                                
                                <!-- Manteniamo i 4 input per retrocompatibilit√† (nascosti) -->
                                <div style="display: none;">
                                    <input type="number" id="larghezzaCarraiaA" step="0.1" min="0" value="2.0">
                                    <input type="number" id="larghezzaCarraiaB" step="0.1" min="0" value="2.0">
                                    <input type="number" id="larghezzaCarraiaC" step="0.1" min="0" value="4.0">
                                    <input type="number" id="larghezzaCarraiaD" step="0.1" min="0" value="4.0">
                                    <small id="infoCarraiaA">-</small>
                                    <small id="infoCarraiaB">-</small>
                                    <small id="infoCarraiaC">-</small>
                                    <small id="infoCarraiaD">-</small>
                                </div>
                                
                                <small style="font-size: 11px; color: #6c757d; margin-top: 5px; display: block;">Seleziona una o pi√π carraie e imposta la larghezza, poi clicca "Applica"</small>
                            </div>

                            <div class="form-group">
                                <label>Sesto di impianto</label>
                                
                                <div style="margin-top: 8px;">
                                    <label for="distanzaFile" style="font-size: 12px; font-weight: 500; color: #6c757d;">Distanza tra File (m) *</label>
                                    <input type="number" id="distanzaFile" step="0.1" min="0.1" value="2.5">
                                    <small>Distanza tra le file di piante</small>
                                </div>
                                
                                <div style="margin-top: 12px;">
                                    <label for="distanzaUnita" style="font-size: 12px; font-weight: 500; color: #6c757d;">Distanza tra Unit√† (m) *</label>
                                    <input type="number" id="distanzaUnita" step="0.1" min="0.1" value="0.8">
                                    <small>Distanza tra ceppi/piante nella fila</small>
                                </div>
                            </div>
                        </div>

                        <!-- Calcoli Automatici -->
                        <div class="section">
                            <h3 class="section-title">üìä Calcoli Automatici</h3>
                            <div class="calculations">
                                <div class="calc-item">
                                    <span class="calc-label">Numero File:</span>
                                    <span class="calc-value" id="calcNumeroFile">-</span>
                                </div>
                                <div class="calc-item">
                                    <span class="calc-label">Unit√† Totali:</span>
                                    <span class="calc-value" id="calcNumeroUnita">-</span>
                                </div>
                                <div class="calc-item">
                                    <span class="calc-label">Superficie Lorda:</span>
                                    <span class="calc-value" id="calcSuperficieLorda">-</span>
                                </div>
                                <div class="calc-item">
                                    <span class="calc-label">Superficie Carraie:</span>
                                    <span class="calc-value" id="calcSuperficieCarraie">-</span>
                                </div>
                                <div class="calc-item">
                                    <span class="calc-label">Superficie Netta:</span>
                                    <span class="calc-value" id="calcSuperficieNetta">-</span>
                                </div>
                                <div class="calc-item">
                                    <span class="calc-label">Densit√† Effettiva:</span>
                                    <span class="calc-value" id="calcDensitaEffettiva">-</span>
                                </div>
                            </div>
                        </div>

                        <!-- Azioni -->
                        <div class="section">
                            <h3 class="section-title">‚öôÔ∏è Azioni</h3>
                            <button id="btnSalva" class="btn btn-success" style="width: 100%; margin-bottom: 10px;">
                                üíæ Salva Pianificazione
                            </button>
                            <button id="btnReset" class="btn btn-secondary" style="width: 100%;">
                                üîÑ Reset Parametri
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Google Maps config -->
    <script>
        const mapsConfigScript = document.createElement('script');
        mapsConfigScript.src = '../../../core/config/google-maps-config.js';
        mapsConfigScript.onerror = function() {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = 'https://raw.githubusercontent.com/VitaraDragon/gfv-platform/main/core/config/google-maps-config.js';
            document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(mapsConfigScript);
    </script>
    
    <!-- Google Maps API -->
    <script>
        let googleMapsReady = false;
        
        // Carica Google Maps API dopo che la config √® pronta
        function loadGoogleMapsAPI() {
            if (typeof google !== 'undefined' && google.maps) {
                googleMapsReady = true;
                return;
            }
            
            // Verifica se lo script √® gi√† stato aggiunto
            if (document.querySelector('script[src*="maps.googleapis.com"]')) {
                // Aspetta che Google Maps sia caricato
                const checkInterval = setInterval(() => {
                    if (typeof google !== 'undefined' && google.maps) {
                        clearInterval(checkInterval);
                        googleMapsReady = true;
                    }
                }, 100);
                setTimeout(() => {
                    clearInterval(checkInterval);
                }, 5000);
                return;
            }
            
            const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDno2cpcMHfs_FqhD4-hi_esj6pBixyJBk';
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=geometry&loading=async`;
            script.async = true;
            script.defer = true;
            script.onload = function() {
                googleMapsReady = true;
            };
            script.onerror = function() {
                console.warn('‚ö†Ô∏è Google Maps API non disponibile');
            };
            document.head.appendChild(script);
        }
        
        // Prova a caricare dopo un breve delay per assicurarsi che la config sia caricata
        setTimeout(loadGoogleMapsAPI, 500);
    </script>

    <!-- Load Firebase config -->
    <script>
        const configScript = document.createElement('script');
        configScript.src = '../../../core/config/firebase-config.js';
        configScript.onerror = function() {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = 'https://raw.githubusercontent.com/VitaraDragon/gfv-platform/main/core/config/firebase-config.js';
            document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(configScript);
    </script>

    <!-- Scripts -->
    <script type="module">
        // Funzione per attendere il config Firebase
        async function waitForConfig() {
            return new Promise((resolve, reject) => {
                if (typeof window.firebaseConfig !== 'undefined') {
                    resolve(window.firebaseConfig);
                    return;
                }
                
                // Carica direttamente il config dal percorso corretto
                const configScript = document.createElement('script');
                configScript.src = '../../../core/config/firebase-config.js';
                
                configScript.onload = function() {
                    setTimeout(() => {
                        if (typeof window.firebaseConfig !== 'undefined') {
                            resolve(window.firebaseConfig);
                        } else {
                            loadFallbackConfig().then(resolve).catch(reject);
                        }
                    }, 100);
                };
                
                configScript.onerror = function() {
                    loadFallbackConfig().then(resolve).catch(reject);
                };
                
                document.head.appendChild(configScript);
            });
        }
        
        function loadFallbackConfig() {
            return new Promise((resolve, reject) => {
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://raw.githubusercontent.com/VitaraDragon/gfv-platform/main/core/config/firebase-config.js';
                
                fallbackScript.onload = function() {
                    setTimeout(() => {
                        if (typeof window.firebaseConfig !== 'undefined') {
                            resolve(window.firebaseConfig);
                        } else {
                            reject(new Error('Firebase config non trovato'));
                        }
                    }, 100);
                };
                
                fallbackScript.onerror = function() {
                    reject(new Error('Errore caricamento config da GitHub'));
                };
                
                document.head.appendChild(fallbackScript);
            });
        }

        import { initializeFirebase, getAuthInstance, getDb } from '../../../../core/services/firebase-service.js';
        import { getCurrentTenantId, getCurrentTenant, initializeTenantService } from '../../../../core/services/tenant-service.js';
        import { initializeAuthService } from '../../../../core/services/auth-service.js';
        import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getDoc, doc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAllTerreni } from '../../../../core/services/terreni-service.js';
        import { createPianificazione, getPianificazione, updatePianificazione } from '../services/pianificazione-impianto-service.js';
        import { getFormeAllevamentoList, getChiaveTecnica, getNomeVisualizzato } from '../config/forme-allevamento.js';

        // Variabili globali
        let map = null;
        let terrenoPolygon = null;
        let currentTerreno = null;
        let reticolatoLines = []; // Array di Polyline per le file del reticolato
        let carraieLateraliPolygon = null; // Poligono per le carraie laterali (parallele ai filari)
        let carraiePerpendicolariPolygon = null; // Poligono per le carraie perpendicolari (estremit√† filari)
        let currentPianificazioneId = null; // ID pianificazione in modifica (se presente)

        // Inizializzazione
        async function init() {
            try {
                // 1. Carica e inizializza Firebase
                const firebaseConfig = await waitForConfig();
                initializeFirebase(firebaseConfig);
                const auth = getAuthInstance();
                const db = getDb();
                
                // 2. Inizializza servizi
                initializeAuthService();
                initializeTenantService();
                
                // 3. Verifica autenticazione con onAuthStateChanged
                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        window.location.href = '../../../../core/auth/login-standalone.html';
                        return;
                    }
                    
                    try {
                        // Carica dati utente
                        const userDoc = await getDoc(doc(db, 'users', user.uid));
                        if (!userDoc.exists()) {
                            window.location.href = '../../../../core/auth/login-standalone.html';
                            return;
                        }
                        
                        const userData = userDoc.data();
                        
                        // 4. Verifica che il modulo vigneto sia attivo
                        const tenantId = getCurrentTenantId();
                        
                        if (tenantId) {
                            const tenant = await getCurrentTenant();
                            if (!tenant || !tenant.modules || !tenant.modules.includes('vigneto')) {
                                alert('Il modulo Vigneto non √® attivo. Attivalo dalla pagina Abbonamento.');
                                window.location.href = '../../../../core/admin/abbonamento-standalone.html';
                                return;
                            }
                        }

                        // 5. Leggi parametro URL per modifica pianificazione
                        const urlParams = new URLSearchParams(window.location.search);
                        currentPianificazioneId = urlParams.get('pianificazioneId');

                        // 6. Carica terreni e inizializza UI
                        await loadTerreni();

                        // 7. Se c'√® un ID pianificazione, carica i dati
                        if (currentPianificazioneId) {
                            await loadPianificazionePerModifica(currentPianificazioneId);
                        }

                        // Popola dropdown forma allevamento
                        populateFormaAllevamentoDropdown();
                        
                        // Gestisce cambio tipo coltura per mostrare/nascondere forma allevamento
                        const tipoColturaSelect = document.getElementById('tipoColtura');
                        if (tipoColturaSelect) {
                            tipoColturaSelect.addEventListener('change', function() {
                                const formaAllevamentoGroup = document.getElementById('formaAllevamentoGroup');
                                if (formaAllevamentoGroup) {
                                    formaAllevamentoGroup.style.display = 
                                        tipoColturaSelect.value === 'vigneto' ? 'block' : 'none';
                                }
                            });
                            // Mostra/nascondi all'inizio
                            const formaAllevamentoGroup = document.getElementById('formaAllevamentoGroup');
                            if (formaAllevamentoGroup) {
                                formaAllevamentoGroup.style.display = 
                                    tipoColturaSelect.value === 'vigneto' ? 'block' : 'none';
                            }
                        }

                        // Inizializza event listeners
                        const terrenoSelect = document.getElementById('terrenoSelect');
                        const distanzaFile = document.getElementById('distanzaFile');
                        const distanzaUnita = document.getElementById('distanzaUnita');
                        const btnSalva = document.getElementById('btnSalva');
                        const btnReset = document.getElementById('btnReset');
                        
                        if (terrenoSelect) terrenoSelect.addEventListener('change', onTerrenoSelected);
                        if (distanzaFile) distanzaFile.addEventListener('input', onParametriChanged);
                        if (distanzaUnita) distanzaUnita.addEventListener('input', onParametriChanged);
                        const larghezzaCarraiaA = document.getElementById('larghezzaCarraiaA');
                        const larghezzaCarraiaB = document.getElementById('larghezzaCarraiaB');
                        const larghezzaCarraiaC = document.getElementById('larghezzaCarraiaC');
                        const larghezzaCarraiaD = document.getElementById('larghezzaCarraiaD');
                        if (larghezzaCarraiaA) larghezzaCarraiaA.addEventListener('input', onParametriChanged);
                        if (larghezzaCarraiaB) larghezzaCarraiaB.addEventListener('input', onParametriChanged);
                        if (larghezzaCarraiaC) larghezzaCarraiaC.addEventListener('input', onParametriChanged);
                        if (larghezzaCarraiaD) larghezzaCarraiaD.addEventListener('input', onParametriChanged);
                        if (btnSalva) btnSalva.addEventListener('click', onSalvaPianificazione);
                        if (btnReset) btnReset.addEventListener('click', onResetParametri);
                        
                        // Controlli rotazione (con retry se elementi non pronti)
                        setTimeout(() => {
                            initRotationControls();
                        }, 100);
                    } catch (error) {
                        console.error('Errore in onAuthStateChanged:', error);
                        alert('Errore nel caricamento dei dati: ' + error.message);
                    }
                });
            } catch (error) {
                console.error('Errore inizializzazione:', error);
                alert('Errore nell\'inizializzazione: ' + error.message);
            }
        }

        // Popola dropdown forma allevamento
        function populateFormaAllevamentoDropdown() {
            try {
                const select = document.getElementById('formaAllevamento');
                if (!select) return;
                
                const formeList = getFormeAllevamentoList();
                select.innerHTML = '<option value="">Seleziona forma di allevamento</option>';
                
                formeList.forEach(nome => {
                    const option = document.createElement('option');
                    option.value = nome;
                    option.textContent = nome;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Errore popolamento dropdown forma allevamento:', error);
            }
        }

        // Carica lista terreni
        async function loadTerreni() {
            try {
                const terreni = await getAllTerreni();
                const select = document.getElementById('terrenoSelect');
                
                // Filtra solo terreni con poligono mappato
                const terreniMappati = terreni.filter(t => 
                    t.polygonCoords && 
                    Array.isArray(t.polygonCoords) && 
                    t.polygonCoords.length >= 3
                );

                if (terreniMappati.length === 0) {
                    select.innerHTML = '<option value="">Nessun terreno con poligono mappato disponibile</option>';
                    return;
                }

                terreniMappati.forEach(terreno => {
                    const option = document.createElement('option');
                    option.value = terreno.id;
                    // Formatta superficie con 2 decimali (es. 1,44 Ha)
                    const superficieFormattata = terreno.superficie 
                        ? parseFloat(terreno.superficie).toFixed(2).replace('.', ',')
                        : 'N/A';
                    option.textContent = `${terreno.nome} (${superficieFormattata} Ha)`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Errore caricamento terreni:', error);
            }
        }

        // Inizializza controlli rotazione
        function initRotationControls() {
            const direzioneSelect = document.getElementById('direzionePredefinita');
            const slider = document.getElementById('angoloRotazioneSlider');
            const hiddenInput = document.getElementById('angoloRotazione');
            const display = document.getElementById('angoloRotazioneDisplay');
            const compass = document.querySelector('.rotation-compass');
            const btnMinus = document.getElementById('btnRotazioneMinus');
            const btnPlus = document.getElementById('btnRotazionePlus');
            
            // Verifica che tutti gli elementi esistano
            if (!direzioneSelect || !slider || !hiddenInput || !display || !btnMinus || !btnPlus) {
                console.warn('Alcuni elementi dei controlli rotazione non trovati, riprovo tra poco...');
                // Riprova dopo un breve delay
                setTimeout(initRotationControls, 100);
                return;
            }
            
            // Funzione per aggiornare tutti i controlli
            function updateRotation(value, skipSlider = false) {
                try {
                    // Normalizza valore tra 0 e 360
                    value = ((value % 360) + 360) % 360;
                    
                    // Aggiorna campo nascosto
                    if (hiddenInput) {
                        hiddenInput.value = value;
                    }
                    
                    // Aggiorna slider (se non √® il trigger)
                    if (!skipSlider && slider) {
                        slider.value = value;
                    }
                    
                    // Aggiorna display
                    if (display) {
                        display.textContent = `${Math.round(value)}¬∞`;
                    }
                    
                    // Ruota bussola visivamente
                    if (compass) {
                        compass.style.transform = `rotate(${value}deg)`;
                    }
                    
                    // Aggiorna dropdown se corrisponde a una direzione predefinita
                    if (direzioneSelect) {
                        const presetValue = parseInt(value);
                        const presetOptions = [0, 45, 90, 135, 180, 225, 270, 315];
                        if (presetOptions.includes(presetValue)) {
                            direzioneSelect.value = presetValue.toString();
                        } else {
                            direzioneSelect.value = 'custom';
                        }
                    }
                    
                    // Trigger cambio parametri (solo se la funzione esiste)
                    if (typeof onParametriChanged === 'function') {
                        onParametriChanged();
                    }
                } catch (error) {
                    console.warn('Errore in updateRotation:', error);
                }
            }
            
            // Dropdown direzioni predefinite
            if (direzioneSelect) {
                direzioneSelect.addEventListener('change', function() {
                    if (this.value !== 'custom') {
                        updateRotation(parseInt(this.value));
                    }
                });
            }
            
            // Slider
            if (slider) {
                slider.addEventListener('input', function() {
                    updateRotation(parseFloat(this.value), true);
                });
            }
            
            // Pulsanti +/-
            if (btnMinus) {
                btnMinus.addEventListener('click', function() {
                    const current = parseFloat(hiddenInput?.value) || 0;
                    updateRotation(current - 1);
                });
            }
            
            if (btnPlus) {
                btnPlus.addEventListener('click', function() {
                    const current = parseFloat(hiddenInput?.value) || 0;
                    updateRotation(current + 1);
                });
            }
            
            // Inizializza display
            updateRotation(0);
        }

        // Handler selezione terreno
        async function onTerrenoSelected(event) {
            const terrenoId = event.target.value;
            
            if (!terrenoId) {
                document.getElementById('planningLayout').style.display = 'none';
                document.getElementById('alertNoTerreno').style.display = 'block';
                return;
            }

            try {
                const terreni = await getAllTerreni();
                currentTerreno = terreni.find(t => t.id === terrenoId);
                
                if (!currentTerreno) {
                    alert('Terreno non trovato');
                    return;
                }

                document.getElementById('alertNoTerreno').style.display = 'none';
                document.getElementById('planningLayout').style.display = 'block';

                // Inizializza mappa
                await initMap();
            } catch (error) {
                console.error('Errore selezione terreno:', error);
                alert('Errore nel caricamento del terreno');
            }
        }

        // Inizializza Google Maps
        async function initMap() {
            if (!currentTerreno || !currentTerreno.polygonCoords) {
                return;
            }

            // Aspetta che Google Maps sia caricato
            await waitForGoogleMaps();
            
            if (typeof google === 'undefined' || !google.maps) {
                console.error('Google Maps non disponibile');
                alert('Errore: Google Maps non disponibile. Ricarica la pagina.');
                return;
            }

            const defaultCenter = { lat: 44.4949, lng: 11.3426 }; // Bologna area
            
            // Crea mappa
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 15,
                center: defaultCenter,
                mapTypeId: google.maps.MapTypeId.SATELLITE
            });

            // Disegna poligono terreno
            const terrenoCoords = currentTerreno.polygonCoords.map(c => 
                new google.maps.LatLng(c.lat, c.lng)
            );

            terrenoPolygon = new google.maps.Polygon({
                paths: terrenoCoords,
                fillColor: '#2E8B57',
                fillOpacity: 0.2,
                strokeColor: '#2E8B57',
                strokeWeight: 3,
                strokeOpacity: 0.8,
                clickable: false,
                zIndex: 1
            });

            terrenoPolygon.setMap(map);

            // Centra mappa sul terreno
            const bounds = new google.maps.LatLngBounds();
            terrenoCoords.forEach(coord => bounds.extend(coord));
            map.fitBounds(bounds);

            // Aggiorna calcoli iniziali (dopo un breve delay per assicurarsi che la mappa sia pronta)
            setTimeout(() => {
                onParametriChanged();
            }, 500);
        }

        // Verifica se Google Maps √® pronto
        function waitForGoogleMaps() {
            return new Promise((resolve) => {
                if (typeof google !== 'undefined' && google.maps) {
                    resolve();
                    return;
                }

                // Aspetta che Google Maps sia caricato
                const checkInterval = setInterval(() => {
                    if (typeof google !== 'undefined' && google.maps) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);
                
                // Timeout dopo 10 secondi
                setTimeout(() => {
                    clearInterval(checkInterval);
                    if (typeof google !== 'undefined' && google.maps) {
                        resolve();
                    } else {
                        console.warn('‚ö†Ô∏è Google Maps non disponibile dopo timeout');
                        resolve(); // Non bloccare, continua comunque
                    }
                }, 10000);
            });
        }

        // Handler cambio parametri
        function onParametriChanged() {
            if (!map || !currentTerreno || !terrenoPolygon) {
                return;
            }

            // Rimuovi reticolato esistente
            clearReticolato();
            
            // Calcola e disegna nuovo reticolato
            calcolaEDisegnaReticolato();
            
            // Aggiorna calcoli
            updateCalcoli();
            
            // Se le carraie sono gi√† state disegnate, ricalcola la classificazione
            // (perch√© cambiando l'angolo dei filari, cambia quali sono principali/laterali)
            if (window.carraieData && window.carraieData.length > 0 && window.tuttiLatiInfo) {
                setTimeout(() => {
                    popolaListaCarraie(window.carraieData, window.tuttiLatiInfo);
                }, 200);
            }
        }
        
        // Rimuovi reticolato esistente
        function clearReticolato() {
            reticolatoLines.forEach(line => {
                line.setMap(null);
            });
            reticolatoLines = [];

            if (carraieLateraliPolygon) {
                if (Array.isArray(carraieLateraliPolygon)) {
                    carraieLateraliPolygon.forEach(p => p && p.setMap && p.setMap(null));
                } else {
                    carraieLateraliPolygon.setMap(null);
                }
                carraieLateraliPolygon = null;
            }
            if (carraiePerpendicolariPolygon) {
                if (Array.isArray(carraiePerpendicolariPolygon)) {
                    carraiePerpendicolariPolygon.forEach(p => p && p.setMap && p.setMap(null));
                } else {
                    carraiePerpendicolariPolygon.setMap(null);
                }
                carraiePerpendicolariPolygon = null;
            }
        }
        
        // Calcola e disegna reticolato
        function calcolaEDisegnaReticolato() {
            if (!terrenoPolygon || !currentTerreno) {
                return;
            }
            
            const distanzaFile = parseFloat(document.getElementById('distanzaFile').value);
            const distanzaUnita = parseFloat(document.getElementById('distanzaUnita').value);
            const larghezzaA = parseFloat(document.getElementById('larghezzaCarraiaA')?.value) || 0;
            const larghezzaB = parseFloat(document.getElementById('larghezzaCarraiaB')?.value) || 0;
            const larghezzaC = parseFloat(document.getElementById('larghezzaCarraiaC')?.value) || 0;
            const larghezzaD = parseFloat(document.getElementById('larghezzaCarraiaD')?.value) || 0;
            const angoloRotazione = parseFloat(document.getElementById('angoloRotazione').value) || 0;
            
            if (!distanzaFile || !distanzaUnita || distanzaFile <= 0 || distanzaUnita <= 0) {
                return;
            }
            
            // Ottieni bounds del terreno
            const bounds = new google.maps.LatLngBounds();
            const terrenoCoords = currentTerreno.polygonCoords.map(c => 
                new google.maps.LatLng(c.lat, c.lng)
            );
            terrenoCoords.forEach(coord => bounds.extend(coord));
            
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            
            // Calcola reticolato con rotazione
            calcolaReticolatoConRotazione(terrenoCoords, bounds, distanzaFile, distanzaUnita, larghezzaA, larghezzaB, larghezzaC, larghezzaD, angoloRotazione);
        }
        
        // Calcola reticolato con rotazione
        function calcolaReticolatoConRotazione(terrenoCoords, bounds, distanzaFile, distanzaUnita, larghezzaA, larghezzaB, larghezzaC, larghezzaD, angoloRotazione) {
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            
            // Calcola centro del terreno
            const centerLat = (ne.lat() + sw.lat()) / 2;
            const centerLng = (ne.lng() + sw.lng()) / 2;
            const center = new google.maps.LatLng(centerLat, centerLng);
            
            // Crea poligono terreno per calcoli intersezione
            const terrenoPoly = new google.maps.Polygon({ paths: terrenoCoords });
            
            // Calcola dimensioni bounds in metri
            const widthMeters = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(centerLat, sw.lng()),
                new google.maps.LatLng(centerLat, ne.lng())
            );
            const heightMeters = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(sw.lat(), centerLng),
                new google.maps.LatLng(ne.lat(), centerLng)
            );
            
            // Direzione base: Nord (0¬∞) o ruotata
            const baseDirection = angoloRotazione; // 0¬∞ = Nord, 90¬∞ = Est, ecc.
            
            // Direzione perpendicolare (per spostare le linee)
            const perpendicularDirection = (baseDirection + 90) % 360;
            
            // Calcola quante linee generare (abbondante per coprire tutto il terreno)
            const maxDimension = Math.max(widthMeters, heightMeters);
            const numLines = Math.ceil(maxDimension / distanzaFile) + 2;
            
            // Disegna carraie perimetrali PRIMA dei filari (cos√¨ possiamo escluderle dai filari)
            // Usa window.carraieWidths se disponibile (valori aggiornati), altrimenti usa i parametri passati
            let largA = larghezzaA;
            let largB = larghezzaB;
            let largC = larghezzaC;
            let largD = larghezzaD;
            
            // Se window.carraieWidths esiste e ha valori, usa quelli (sono i valori pi√π aggiornati)
            if (window.carraieWidths && window.carraieWidths.size > 0) {
                largA = window.carraieWidths.get(0) || larghezzaA;
                largB = window.carraieWidths.get(1) || larghezzaB;
                largC = window.carraieWidths.get(2) || larghezzaC;
                largD = window.carraieWidths.get(3) || larghezzaD;
            }
            
            // Disegna le carraie solo se non sono gi√† state disegnate o se le larghezze sono cambiate
            const carraieGiaDisegnate = window.carraieData && window.carraieData.length > 0;
            if (!carraieGiaDisegnate && (largA > 0 || largB > 0 || largC > 0 || largD > 0) && 
                isFinite(largA) && isFinite(largB) && isFinite(largC) && isFinite(largD)) {
                disegnaCarraiePerimetrali(terrenoCoords, largA, largB, largC, largD, angoloRotazione);
            } else if (carraieGiaDisegnate) {
                // Le carraie sono gi√† state disegnate, non ridisegnarle
                // (saranno gi√† aggiornate se necessario)
            } else {
                // Rimuovi carraie se larghezze non valide o zero
                if (carraieLateraliPolygon) {
                    if (Array.isArray(carraieLateraliPolygon)) {
                        carraieLateraliPolygon.forEach(p => p && p.setMap && p.setMap(null));
                    } else {
                        carraieLateraliPolygon.setMap(null);
                    }
                    carraieLateraliPolygon = null;
                }
                if (carraiePerpendicolariPolygon) {
                    if (Array.isArray(carraiePerpendicolariPolygon)) {
                        carraiePerpendicolariPolygon.forEach(p => p && p.setMap && p.setMap(null));
                    } else {
                        carraiePerpendicolariPolygon.setMap(null);
                    }
                    carraiePerpendicolariPolygon = null;
                }
            }
            
            const fileCoords = [];
            let fileIndex = 0;
            
            // Verifica che le carraie siano disponibili prima di disegnare i filari
            const carraieDisponibili = window.carraieData && window.carraieData.length > 0 
                ? window.carraieData.filter(c => c && c.polygon && c.larghezza > 0).length
                : 0;
            
            // Genera linee parallele ruotate
            // Partiamo dal centro e ci spostiamo in entrambe le direzioni
            for (let i = -numLines / 2; i <= numLines / 2; i++) {
                // Sposta il punto di partenza perpendicolarmente alla direzione delle linee
                const offsetDistance = i * distanzaFile;
                const lineCenter = google.maps.geometry.spherical.computeOffset(
                    center,
                    offsetDistance,
                    perpendicularDirection
                );
                
                // Crea una linea lunga abbastanza da attraversare tutto il terreno
                // La linea va nella direzione base (ruotata)
                const lineLength = maxDimension * 1.5; // Abbondante
                const lineStart = google.maps.geometry.spherical.computeOffset(
                    lineCenter,
                    -lineLength / 2,
                    baseDirection
                );
                const lineEnd = google.maps.geometry.spherical.computeOffset(
                    lineCenter,
                    lineLength / 2,
                    baseDirection
                );
                
                // Calcola intersezione con poligono terreno
                const intersection = calcolaIntersezioneLineaPoligono(lineStart, lineEnd, terrenoCoords);
                
                if (intersection && intersection.length >= 2) {
                    // Taglia i segmenti che intersecano con le carraie
                    // Passa anche il numero di carraie disponibili per debug
                    const segments = tagliaLineaEscludendoCarraie(intersection[0], intersection[1]);
                    
                    // Disegna ogni segmento rimanente
                    segments.forEach(segment => {
                        if (segment && segment.length >= 2) {
                            const polyline = new google.maps.Polyline({
                                path: segment,
                                strokeColor: '#C62828', // Rosso scuro pi√π visibile
                                strokeOpacity: 0.85, // Opacit√† aumentata
                                strokeWeight: 3, // Spessore aumentato per migliore visibilit√†
                                zIndex: 2,
                                map: map
                            });
                            
                            reticolatoLines.push(polyline);
                            fileCoords.push({
                                file: fileIndex + 1,
                                start: { lat: segment[0].lat(), lng: segment[0].lng() },
                                end: { lat: segment[segment.length - 1].lat(), lng: segment[segment.length - 1].lng() }
                            });
                            fileIndex++;
                        }
                    });
                }
            }
            
            // Salva coordinate reticolato per calcoli
            window.reticolatoCoords = fileCoords;
        }
        
        // Classifica un segmento come principale o laterale basandosi sull'orientamento dei filari
        function classificaSegmento(latoInfo, angoloFilari) {
            if (!latoInfo || angoloFilari === undefined) {
                return 'laterale'; // Default
            }
            
            // Normalizza gli angoli tra 0 e 360
            const angoloSegmento = ((latoInfo.sideBearing % 360) + 360) % 360;
            const angoloFilariNorm = ((angoloFilari % 360) + 360) % 360;
            
            // Calcola differenza angolare (considera che 180¬∞ = parallelo, 90¬∞/270¬∞ = perpendicolare)
            let diffAngolo = Math.abs(angoloSegmento - angoloFilariNorm);
            if (diffAngolo > 180) {
                diffAngolo = 360 - diffAngolo;
            }
            
            // Tolleranza: se la differenza √® vicina a 90¬∞ (o 270¬∞), √® perpendicolare = principale
            // Se √® vicina a 0¬∞ o 180¬∞, √® parallela = laterale
            const tolleranza = 20; // gradi di tolleranza
            
            if (Math.abs(diffAngolo - 90) < tolleranza || Math.abs(diffAngolo - 270) < tolleranza) {
                return 'principale'; // Perpendicolare ai filari
            } else if (diffAngolo < tolleranza || Math.abs(diffAngolo - 180) < tolleranza) {
                return 'laterale'; // Parallela ai filari
            }
            
            // Default: se non √® chiaramente parallela o perpendicolare, considera laterale
            return 'laterale';
        }
        
        // Identifica i 4 lati principali del terreno (semplicemente i 4 pi√π lunghi)
        function identificaQuattroLatiPrincipali(terrenoCoordsLatLng) {
            if (!terrenoCoordsLatLng || terrenoCoordsLatLng.length < 4) {
                return [];
            }
            
            // Calcola informazioni per ogni lato
            const latiInfo = [];
            for (let i = 0; i < terrenoCoordsLatLng.length; i++) {
                const current = terrenoCoordsLatLng[i];
                const next = terrenoCoordsLatLng[(i + 1) % terrenoCoordsLatLng.length];
                
                const lunghezza = google.maps.geometry.spherical.computeDistanceBetween(current, next);
                const bearing = google.maps.geometry.spherical.computeHeading(current, next);
                
                // Punto medio del lato
                const puntoMedio = google.maps.geometry.spherical.interpolate(current, next, 0.5);
                
                latiInfo.push({
                    index: i,
                    current: current,
                    next: next,
                    lunghezza: lunghezza,
                    sideBearing: bearing,
                    puntoMedio: puntoMedio
                });
            }
            
            // Salva tuttiLatiInfo in window per uso nelle funzioni di classificazione
            window.tuttiLatiInfo = latiInfo;
            
            // Calcola classificazione principale/laterale per ogni lato
            if (!window.carraieClassificazione) {
                window.carraieClassificazione = new Map();
            }
            const angoloFilari = parseFloat(angoloReticolato) || 0;
            latiInfo.forEach(lato => {
                const tipo = classificaSegmento(lato, angoloFilari);
                window.carraieClassificazione.set(lato.index, tipo);
            });
            
            // Log di tutti i lati per debug
            console.log(`[CARRAIE] Tutti i lati del terreno:`);
            latiInfo.forEach(l => {
                console.log(`  Lato ${l.index}: ${l.lunghezza.toFixed(2)}m, bearing=${l.sideBearing.toFixed(1)}¬∞`);
            });
            
            // Ordina per lunghezza (dal pi√π lungo al pi√π corto) e prendi i primi 4
            const latiOrdinati = [...latiInfo].sort((a, b) => b.lunghezza - a.lunghezza);
            const quattroLati = latiOrdinati.slice(0, 4);
            
            // Ordina per indice per mantenere ordine consistente (A = primo indice, B = secondo, ecc.)
            quattroLati.sort((a, b) => a.index - b.index);
            
            console.log(`[CARRAIE] Selezionati i 4 lati pi√π lunghi (ordinati per indice):`);
            quattroLati.forEach((l, idx) => {
                const nome = ['A', 'B', 'C', 'D'][idx];
                console.log(`  Carraia ${nome}: Lato ${l.index} (${l.lunghezza.toFixed(2)}m)`);
            });
            
            return quattroLati;
        }
        
        // Disegna carraie perimetrali (strade di servizio intorno al perimetro)
        // Crea carraie solo per i 4 lati principali con larghezze specifiche
        function disegnaCarraiePerimetrali(terrenoCoords, larghezzaA, larghezzaB, larghezzaC, larghezzaD, angoloReticolato) {
            console.log('[CARRAIE] ===== INIZIO disegnaCarraiePerimetrali =====');
            console.log('[CARRAIE] Parametri:', {
                terrenoCoordsLength: terrenoCoords?.length,
                larghezzaA,
                larghezzaB,
                larghezzaC,
                larghezzaD,
                angoloReticolato
            });
            
            if (!terrenoCoords || terrenoCoords.length < 3) {
                console.warn('[CARRAIE] terrenoCoords non valido', terrenoCoords);
                return;
            }
            
            // Valida larghezze carraie
            const largA = parseFloat(larghezzaA) || 0;
            const largB = parseFloat(larghezzaB) || 0;
            const largC = parseFloat(larghezzaC) || 0;
            const largD = parseFloat(larghezzaD) || 0;
            const angoloRet = parseFloat(angoloReticolato) || 0;
            
            console.log('[CARRAIE] Larghezze validate:', {
                largA,
                largB,
                largC,
                largD,
                angoloRet
            });
            
            // Rimuovi tutte le carraie precedenti (poligoni e marker)
            console.log('[CARRAIE] Rimozione poligoni precedenti');
            if (carraieLateraliPolygon) {
                if (Array.isArray(carraieLateraliPolygon)) {
                    carraieLateraliPolygon.forEach(p => p && p.setMap && p.setMap(null));
                } else {
                    carraieLateraliPolygon.setMap(null);
                }
                carraieLateraliPolygon = null;
            }
            if (carraiePerpendicolariPolygon) {
                if (Array.isArray(carraiePerpendicolariPolygon)) {
                    carraiePerpendicolariPolygon.forEach(p => p && p.setMap && p.setMap(null));
                } else {
                    carraiePerpendicolariPolygon.setMap(null);
                }
                carraiePerpendicolariPolygon = null;
            }
            // Rimuovi anche i marker delle etichette se esistono
            if (window.carraieData) {
                window.carraieData.forEach(c => {
                    if (c.marker) {
                        c.marker.setMap(null);
                    }
                });
                window.carraieData = [];
            }
            
            // Inizializza lo stato centrale delle larghezze se non esiste
            if (!window.carraieWidths) {
                window.carraieWidths = new Map();
            }
            
            if ((largA <= 0 && largB <= 0 && largC <= 0 && largD <= 0) || 
                !isFinite(largA) || !isFinite(largB) || !isFinite(largC) || !isFinite(largD)) {
                console.warn('[CARRAIE] Larghezze non valide');
                return;
            }
            
            // Converti coordinate a LatLng
            const terrenoCoordsLatLng = [];
            for (let i = 0; i < terrenoCoords.length; i++) {
                let lat, lng;
                
                if (!terrenoCoords[i] || typeof terrenoCoords[i] !== 'object') {
                    continue;
                }
                
                if (typeof terrenoCoords[i].lat === 'function' && typeof terrenoCoords[i].lng === 'function') {
                    try {
                        lat = terrenoCoords[i].lat();
                        lng = terrenoCoords[i].lng();
                    } catch (e) {
                        continue;
                    }
                } else if (terrenoCoords[i].lat !== undefined && terrenoCoords[i].lng !== undefined) {
                    lat = parseFloat(terrenoCoords[i].lat);
                    lng = parseFloat(terrenoCoords[i].lng);
                } else {
                    continue;
                }
                
                if (isFinite(lat) && isFinite(lng)) {
                    try {
                        terrenoCoordsLatLng.push(new google.maps.LatLng(lat, lng));
                    } catch (e) {
                        continue;
                    }
                }
            }
            
            if (terrenoCoordsLatLng.length < 3) {
                console.warn('[CARRAIE] Coordinate terreno non valide');
                return;
            }
            
            // Usa computeSignedArea per determinare il verso del poligono
            // Positivo = orario (clockwise), Negativo = antiorario (counterclockwise)
            const areaTerrenoSigned = google.maps.geometry.spherical.computeSignedArea(terrenoCoordsLatLng);
            const isClockwise = areaTerrenoSigned > 0;
            
            // Calcola anche area assoluta per log
            const areaTerreno = Math.abs(areaTerrenoSigned);
            
            console.log('[CARRAIE] Analisi terreno:', {
                numVertici: terrenoCoordsLatLng.length,
                areaTerreno: areaTerreno.toFixed(2),
                isClockwise
            });
            
            // Crea poligoni per TUTTI i lati del terreno (qualsiasi numero, non limitato a 4)
            const larghezze = [largA, largB, largC, largD];
            
            // Calcola informazioni per TUTTI i lati del poligono
            const tuttiLatiConLunghezza = [];
            for (let i = 0; i < terrenoCoordsLatLng.length; i++) {
                const current = terrenoCoordsLatLng[i];
                const next = terrenoCoordsLatLng[(i + 1) % terrenoCoordsLatLng.length];
                const lunghezza = google.maps.geometry.spherical.computeDistanceBetween(current, next);
                tuttiLatiConLunghezza.push({ index: i, lunghezza: lunghezza });
            }
            
            // Determina le larghezze per ogni lato
            // Usa sempre window.carraieWidths come fonte unica di verit√†
            const latiOrdinati = [...tuttiLatiConLunghezza].sort((a, b) => b.lunghezza - a.lunghezza);
            const quattroLatiLunghi = latiOrdinati.slice(0, 4);
            
            // Se window.carraieWidths √® vuoto (prima volta), inizializza con i 4 lati pi√π lunghi
            if (window.carraieWidths.size === 0) {
                quattroLatiLunghi.forEach((lato, idx) => {
                    window.carraieWidths.set(lato.index, larghezze[idx]);
                });
                console.log(`[CARRAIE] Inizializzazione larghezze ai 4 lati pi√π lunghi: ${quattroLatiLunghi.map((l, idx) => `Lato ${l.index} (${l.lunghezza.toFixed(1)}m) = ${larghezze[idx]}m`).join(', ')}`);
            }
            
            // Crea Map delle larghezze per tutti i lati (usa 0 se non specificato)
            const larghezzePerLato = new Map();
            for (let i = 0; i < terrenoCoordsLatLng.length; i++) {
                larghezzePerLato.set(i, window.carraieWidths.get(i) || 0);
            }
            
            console.log(`[CARRAIE] Terreno con ${terrenoCoordsLatLng.length} lati. Creazione poligoni per tutti i lati.`);
            
            // Aggiorna le info nei label del modal (per retrocompatibilit√†)
            const labels = ['infoCarraiaA', 'infoCarraiaB', 'infoCarraiaC', 'infoCarraiaD'];
            quattroLatiLunghi.forEach((lato, idx) => {
                const labelEl = document.getElementById(labels[idx]);
                if (labelEl) {
                    labelEl.textContent = `Lato ${lato.index}: ${lato.lunghezza.toFixed(1)}m`;
                }
            });
            
            // Calcola informazioni per TUTTI i lati del poligono
            const tuttiLatiInfo = [];
            for (let i = 0; i < terrenoCoordsLatLng.length; i++) {
                const current = terrenoCoordsLatLng[i];
                const next = terrenoCoordsLatLng[(i + 1) % terrenoCoordsLatLng.length];
                
                const bearing = google.maps.geometry.spherical.computeHeading(current, next);
                const lunghezza = google.maps.geometry.spherical.computeDistanceBetween(current, next);
                const larghezza = larghezzePerLato.get(i) || 0;
                
                tuttiLatiInfo.push({
                    index: i,
                    current: current,
                    next: next,
                    sideBearing: bearing,
                    lunghezza: lunghezza,
                    larghezza: larghezza
                });
            }
            
            // Salva tuttiLatiInfo in window per uso nelle funzioni di classificazione
            window.tuttiLatiInfo = tuttiLatiInfo;
            
            // Calcola classificazione principale/laterale per ogni lato
            // Priorit√†: 1) Larghezza (se >= 5.5m = principale, <= 4.5m = laterale)
            //           2) Orientamento rispetto ai filari
            if (!window.carraieClassificazione) {
                window.carraieClassificazione = new Map();
            }
            const angoloFilari = parseFloat(angoloReticolato) || 0;
            tuttiLatiInfo.forEach(lato => {
                // Controlla se esiste gi√† una classificazione basata sulla larghezza
                const larghezza = larghezzePerLato.get(lato.index) || 0;
                let tipo = null;
                
                // Se la larghezza indica un tipo specifico, usa quello
                if (larghezza >= 5.5) {
                    tipo = 'principale';
                } else if (larghezza <= 4.5 && larghezza > 0) {
                    tipo = 'laterale';
                }
                
                // Se non c'√® una classificazione basata sulla larghezza, usa l'orientamento
                if (!tipo) {
                    tipo = classificaSegmento(lato, angoloFilari);
                }
                
                window.carraieClassificazione.set(lato.index, tipo);
            });
            
            // Funzione per creare un poligono rettangolare per un singolo lato
            function creaPoligonoCarraiaSingoloLato(latoInfo, larghezza, nomeCarraia) {
                if (larghezza <= 0) {
                    // Se larghezza √® 0, crea comunque il poligono ma invisibile (per la selezione)
                    larghezza = 0.1; // Larghezza minima per visualizzazione
                }
                
                // Crea poligono terreno temporaneo per verificare se punti sono dentro
                const terrenoPoly = new google.maps.Polygon({ paths: terrenoCoordsLatLng });
                
                // Prova prima con offset +90¬∞ (destra rispetto alla direzione del lato)
                let testBearing = (latoInfo.sideBearing + 90) % 360;
                const testPoint = google.maps.geometry.spherical.computeOffset(
                    latoInfo.puntoMedio || google.maps.geometry.spherical.interpolate(latoInfo.current, latoInfo.next, 0.5),
                    larghezza,
                    testBearing
                );
                
                // Verifica se il punto di test √® dentro il poligono terreno
                const isInside = google.maps.geometry.poly.containsLocation(testPoint, terrenoPoly);
                
                // Se il punto √® fuori, inverti la direzione (-90¬∞ invece di +90¬∞)
                const inwardBearing = isInside 
                    ? testBearing
                    : (latoInfo.sideBearing - 90 + 360) % 360;
                
                // Calcola offset per gli estremi del lato
                const offsetStart = google.maps.geometry.spherical.computeOffset(
                    latoInfo.current,
                    larghezza,
                    inwardBearing
                );
                
                const offsetEnd = google.maps.geometry.spherical.computeOffset(
                    latoInfo.next,
                    larghezza,
                    inwardBearing
                );
                
                // Crea il poligono rettangolare
                const carraiaCoords = [
                    latoInfo.current,
                    latoInfo.next,
                    offsetEnd,
                    offsetStart
                ];
                
                // Determina colore in base al tipo (se classificazione disponibile)
                let fillColor = '#FFB74D'; // Arancione default
                let strokeColor = '#E65100'; // Arancione scuro default
                
                if (window.carraieClassificazione) {
                    const tipo = window.carraieClassificazione.get(latoInfo.index);
                    if (tipo === 'principale') {
                        fillColor = '#FF9800'; // Arancione pi√π intenso per principali
                        strokeColor = '#E65100'; // Arancione scuro
                    } else if (tipo === 'laterale') {
                        fillColor = '#64B5F6'; // Azzurro per laterali
                        strokeColor = '#1976D2'; // Blu scuro
                    }
                }
                
                const polygon = new google.maps.Polygon({
                    paths: carraiaCoords,
                    fillColor: fillColor,
                    fillOpacity: larghezza > 0.1 ? 0.4 : 0.15, // Opacit√† aumentata
                    strokeColor: strokeColor,
                    strokeWeight: larghezza > 0.1 ? 3 : 2, // Spessore aumentato
                    strokeOpacity: larghezza > 0.1 ? 0.9 : 0.5, // Opacit√† bordo aumentata
                    zIndex: 1.5,
                    map: map,
                    // Aggiungi dati custom per identificazione
                    carraiaIndex: latoInfo.index,
                    carraiaNome: nomeCarraia
                });
                
                // Aggiungi event listener per selezionare il poligono cliccandoci sopra
                polygon.addListener('click', function() {
                    selezionaCarraia(latoInfo.index);
                });
                
                // Evidenzia il poligono al hover per mostrare che √® cliccabile
                polygon.addListener('mouseover', function() {
                    if (map) {
                        map.setOptions({ draggableCursor: 'pointer' });
                    }
                });
                
                polygon.addListener('mouseout', function() {
                    if (map) {
                        map.setOptions({ draggableCursor: null });
                    }
                });
                
                // Crea un marker con etichetta al centro del poligono
                const puntoMedio = google.maps.geometry.spherical.interpolate(latoInfo.current, latoInfo.next, 0.5);
                const offsetMedio = google.maps.geometry.spherical.computeOffset(
                    puntoMedio,
                    larghezza / 2,
                    inwardBearing
                );
                
                const marker = new google.maps.Marker({
                    position: offsetMedio,
                    map: map,
                    label: {
                        text: nomeCarraia,
                        color: '#000',
                        fontSize: '14px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 0,
                        fillOpacity: 0,
                        strokeOpacity: 0
                    },
                    zIndex: 2,
                    carraiaIndex: latoInfo.index,
                    carraiaNome: nomeCarraia
                });
                
                return {
                    polygon: polygon,
                    marker: marker,
                    index: latoInfo.index,
                    nome: nomeCarraia,
                    larghezza: larghezza > 0.1 ? larghezza : 0
                };
            }
            
            // Crea un poligono per ogni lato del terreno
            const carraiePoligoni = [];
            const lettere = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
            
            tuttiLatiInfo.forEach((lato, idx) => {
                const nomeCarraia = lettere[idx]; // Solo la lettera (A, B, C, ecc.)
                const larghezza = larghezzePerLato.get(lato.index) || 0;
                const carraiaData = creaPoligonoCarraiaSingoloLato(lato, larghezza, nomeCarraia);
                carraiePoligoni.push(carraiaData);
            });
            
            // Salva come array (manteniamo compatibilit√† con codice esistente)
            carraieLateraliPolygon = carraiePoligoni.map(c => c.polygon);
            carraiePerpendicolariPolygon = null;
            
            // Salva anche i dati completi per la gestione della selezione
            // Sincronizza le larghezze con window.carraieWidths
            window.carraieData = carraiePoligoni.map(c => ({
                ...c,
                larghezza: window.carraieWidths.get(c.index) || 0
            }));
            
            // Calcola area totale approssimativa
            let areaTotaleCarraie = 0;
            carraiePoligoni.forEach(c => {
                if (c.larghezza > 0) {
                    const lato = tuttiLatiInfo[c.index];
                    areaTotaleCarraie += lato.lunghezza * c.larghezza;
                }
            });
            
            console.log(`[CARRAIE] Creati ${carraiePoligoni.length} poligoni di carraia separati`);
            console.log(`[CARRAIE] Area totale carraie (approssimativa): ${areaTotaleCarraie.toFixed(2)} m¬≤`);
            
            // Popola la lista dinamica delle carraie nell'interfaccia
            // Assicurati che tuttiLatiInfo abbia sideBearing per ogni lato
            const tuttiLatiInfoCompleti = tuttiLatiInfo.map(lato => {
                // Se sideBearing non √® presente, calcolalo
                if (lato.sideBearing === undefined && lato.current && lato.next) {
                    lato.sideBearing = google.maps.geometry.spherical.computeHeading(lato.current, lato.next);
                }
                return lato;
            });
            window.tuttiLatiInfo = tuttiLatiInfoCompleti;
            popolaListaCarraie(carraiePoligoni, tuttiLatiInfoCompleti);
            
            console.log('[CARRAIE] ===== FINE disegnaCarraiePerimetrali =====');
        }
        
        // Funzione per popolare la lista dinamica delle carraie
        function popolaListaCarraie(carraiePoligoni, tuttiLatiInfo) {
            const listaContainer = document.getElementById('listaCarraie');
            if (!listaContainer) return;
            
            // Svuota la lista
            listaContainer.innerHTML = '<div style="font-size: 11px; color: #6c757d; margin-bottom: 8px; font-weight: 500;">Seleziona le carraie da configurare:</div>';
            
            // Ottieni angolo filari per classificazione
            const angoloFilari = parseFloat(document.getElementById('angoloRotazione')?.value || 0);
            
            // Classifica ogni segmento
            const segmentiClassificati = carraiePoligoni.map(carraia => {
                const lato = tuttiLatiInfo[carraia.index];
                const tipo = classificaSegmento(lato, angoloFilari);
                return { carraia, lato, tipo };
            });
            
            // Salva classificazione in window per uso futuro
            if (!window.carraieClassificazione) {
                window.carraieClassificazione = new Map();
            }
            segmentiClassificati.forEach(({ carraia, tipo }) => {
                window.carraieClassificazione.set(carraia.index, tipo);
            });
            
            // Crea un checkbox per ogni carraia
            segmentiClassificati.forEach(({ carraia, lato, tipo }, idx) => {
                // Leggi la larghezza da window.carraieWidths (fonte unica di verit√†)
                const larghezza = (window.carraieWidths && window.carraieWidths.get(carraia.index)) || 0;
                
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 6px; border-bottom: 1px solid #eee;';
                
                // Colore di sfondo basato sul tipo
                if (tipo === 'principale') {
                    div.style.backgroundColor = '#FFF3E0'; // Arancione chiaro per principali
                } else {
                    div.style.backgroundColor = '#E1F5FE'; // Azzurro chiaro per laterali
                }
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `carraia_${carraia.index}`;
                checkbox.value = carraia.index;
                checkbox.style.cssText = 'cursor: pointer;';
                
                // Non selezionare automaticamente (l'utente user√† i pulsanti rapidi)
                checkbox.checked = false;
                
                const label = document.createElement('label');
                label.htmlFor = `carraia_${carraia.index}`;
                label.style.cssText = 'flex: 1; cursor: pointer; font-size: 12px;';
                
                // Badge per tipo
                const badge = tipo === 'principale' 
                    ? '<span style="background: #FF9800; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; margin-right: 6px;">PRINCIPALE</span>'
                    : '<span style="background: #2196F3; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; margin-right: 6px;">LATERALE</span>';
                
                label.innerHTML = `${badge}${carraia.nome} - Lato ${carraia.index} (${lato.lunghezza.toFixed(1)}m) - Larghezza: ${larghezza.toFixed(1)}m`;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                listaContainer.appendChild(div);
            });
            
            // Aggiungi listener per il pulsante "Applica"
            const btnApplica = document.getElementById('applicaLarghezzaCarraie');
            if (btnApplica) {
                btnApplica.onclick = function() {
                    applicaLarghezzaCarraieSelezionate();
                };
            }
            
            // Aggiungi listener per pulsanti selezione rapida
            const btnPrincipali = document.getElementById('btnSelezionaPrincipali');
            const btnLaterali = document.getElementById('btnSelezionaLaterali');
            const btnTipica = document.getElementById('btnConfigurazioneTipica');
            
            if (btnPrincipali) {
                btnPrincipali.onclick = function() {
                    selezionaTuttePrincipali();
                };
            }
            
            if (btnLaterali) {
                btnLaterali.onclick = function() {
                    selezionaTutteLaterali();
                };
            }
            
            if (btnTipica) {
                btnTipica.onclick = function() {
                    applicaConfigurazioneTipica();
                };
            }
        }
        
        // Seleziona tutte le carraie principali
        function selezionaTuttePrincipali() {
            if (!window.carraieData || !window.carraieClassificazione) {
                return;
            }
            
            window.carraieData.forEach(carraia => {
                const tipo = window.carraieClassificazione.get(carraia.index);
                if (tipo === 'principale') {
                    const checkbox = document.getElementById(`carraia_${carraia.index}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        // Evidenzia sulla mappa
                        if (carraia.polygon) {
                            carraia.polygon.setOptions({
                                fillOpacity: 0.6,
                                strokeWeight: 4
                            });
                        }
                    }
                }
            });
            
            // Imposta larghezza suggerita a 6m
            const inputLarghezza = document.getElementById('larghezzaCarraieSelezionate');
            if (inputLarghezza) {
                inputLarghezza.value = '6.0';
            }
        }
        
        // Seleziona tutte le carraie laterali
        function selezionaTutteLaterali() {
            if (!window.carraieData || !window.carraieClassificazione) {
                return;
            }
            
            window.carraieData.forEach(carraia => {
                const tipo = window.carraieClassificazione.get(carraia.index);
                if (tipo === 'laterale') {
                    const checkbox = document.getElementById(`carraia_${carraia.index}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        // Evidenzia sulla mappa
                        if (carraia.polygon) {
                            carraia.polygon.setOptions({
                                fillOpacity: 0.6,
                                strokeWeight: 4
                            });
                        }
                    }
                }
            });
            
            // Imposta larghezza suggerita a 4m
            const inputLarghezza = document.getElementById('larghezzaCarraieSelezionate');
            if (inputLarghezza) {
                inputLarghezza.value = '4.0';
            }
        }
        
        // Applica configurazione tipica (principali 6m, laterali 4m)
        function applicaConfigurazioneTipica() {
            if (!window.carraieData || !window.carraieClassificazione) {
                return;
            }
            
            // Inizializza window.carraieWidths se non esiste
            if (!window.carraieWidths) {
                window.carraieWidths = new Map();
            }
            
            // Applica larghezze in base al tipo
            window.carraieData.forEach(carraia => {
                const tipo = window.carraieClassificazione.get(carraia.index);
                const larghezza = tipo === 'principale' ? 6.0 : 4.0;
                
                window.carraieWidths.set(carraia.index, larghezza);
                
                // Seleziona checkbox
                const checkbox = document.getElementById(`carraia_${carraia.index}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            // Ridisegna le carraie con le nuove larghezze
            const terrenoCoords = terrenoPolygon ? terrenoPolygon.getPath().getArray() : null;
            if (terrenoCoords && terrenoCoords.length > 0) {
                const largA = window.carraieWidths.get(0) || 0;
                const largB = window.carraieWidths.get(1) || 0;
                const largC = window.carraieWidths.get(2) || 0;
                const largD = window.carraieWidths.get(3) || 0;
                const angoloRotazione = parseFloat(document.getElementById('angoloRotazione')?.value || 0);
                
                disegnaCarraiePerimetrali(terrenoCoords, largA, largB, largC, largD, angoloRotazione);
                
                // Ridisegna anche i filari se sono gi√† stati disegnati
                if (reticolatoLines && reticolatoLines.length > 0) {
                    const distanzaFile = parseFloat(document.getElementById('distanzaFile')?.value || 2.5);
                    const distanzaUnita = parseFloat(document.getElementById('distanzaUnita')?.value || 1.0);
                    const bounds = new google.maps.LatLngBounds();
                    terrenoCoords.forEach(coord => bounds.extend(coord));
                    calcolaReticolatoConRotazione(terrenoCoords, bounds, distanzaFile, distanzaUnita, largA, largB, largC, largD, angoloRotazione);
                    updateCalcoli();
                }
                
                // Aggiorna la lista
                setTimeout(() => {
                    if (window.carraieData && window.carraieData.length > 0) {
                        const tuttiLatiInfo = [];
                        for (let i = 0; i < terrenoCoords.length; i++) {
                            const current = terrenoCoords[i];
                            const next = terrenoCoords[(i + 1) % terrenoCoords.length];
                            const lunghezza = google.maps.geometry.spherical.computeDistanceBetween(
                                new google.maps.LatLng(current.lat(), current.lng()),
                                new google.maps.LatLng(next.lat(), next.lng())
                            );
                            const bearing = google.maps.geometry.spherical.computeHeading(
                                new google.maps.LatLng(current.lat(), current.lng()),
                                new google.maps.LatLng(next.lat(), next.lng())
                            );
                            tuttiLatiInfo.push({ 
                                index: i, 
                                lunghezza: lunghezza,
                                sideBearing: bearing
                            });
                        }
                        popolaListaCarraie(window.carraieData, tuttiLatiInfo);
                    }
                }, 100);
            }
        }
        
        // Funzione per applicare la larghezza alle carraie selezionate
        function applicaLarghezzaCarraieSelezionate() {
            if (!window.carraieData || window.carraieData.length === 0) {
                console.warn('[CARRAIE] Nessuna carraia disponibile');
                return;
            }
            
            const inputLarghezza = document.getElementById('larghezzaCarraieSelezionate');
            if (!inputLarghezza) return;
            
            const larghezza = parseFloat(inputLarghezza.value) || 0;
            
            // Inizializza window.carraieWidths se non esiste
            if (!window.carraieWidths) {
                window.carraieWidths = new Map();
            }
            
            // Inizializza classificazione se non esiste
            if (!window.carraieClassificazione) {
                window.carraieClassificazione = new Map();
            }
            
            // Determina tipo in base alla larghezza applicata
            // Se larghezza >= 5.5m ‚Üí principale, se <= 4.5m ‚Üí laterale
            // Altrimenti mantieni classificazione esistente
            let nuovoTipo = null;
            if (larghezza >= 5.5) {
                nuovoTipo = 'principale';
            } else if (larghezza <= 4.5) {
                nuovoTipo = 'laterale';
            }
            
            // Trova tutte le checkbox selezionate e aggiorna window.carraieWidths
            const indiciSelezionati = [];
            window.carraieData.forEach(carraia => {
                const checkboxId = `carraia_${carraia.index}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    window.carraieWidths.set(carraia.index, larghezza);
                    indiciSelezionati.push(carraia.index);
                    
                    // Riclassifica automaticamente se la larghezza indica un tipo specifico
                    if (nuovoTipo) {
                        window.carraieClassificazione.set(carraia.index, nuovoTipo);
                        console.log(`[CARRAIE] Riclassificata carraia ${carraia.nome} (indice ${carraia.index}) come ${nuovoTipo} (larghezza ${larghezza}m)`);
                    }
                    
                    console.log(`[CARRAIE] Aggiornata larghezza carraia ${carraia.nome} (indice ${carraia.index}) a ${larghezza}m`);
                }
            });
            
            if (indiciSelezionati.length === 0) {
                alert('Seleziona almeno una carraia');
                return;
            }
            
            console.log(`[CARRAIE] Applicazione larghezza ${larghezza}m a ${indiciSelezionati.length} carraie selezionate`);
            
            // Ridisegna le carraie con le nuove larghezze
            const terrenoCoords = terrenoPolygon ? terrenoPolygon.getPath().getArray() : null;
            if (terrenoCoords && terrenoCoords.length > 0) {
                // Per retrocompatibilit√†, prendi le prime 4 larghezze per i parametri della funzione
                // Ma la funzione legger√† da window.carraieWidths
                const largA = window.carraieWidths.get(0) || 0;
                const largB = window.carraieWidths.get(1) || 0;
                const largC = window.carraieWidths.get(2) || 0;
                const largD = window.carraieWidths.get(3) || 0;
                
                const angoloRotazione = parseFloat(document.getElementById('angoloRotazione')?.value || 0);
                disegnaCarraiePerimetrali(terrenoCoords, largA, largB, largC, largD, angoloRotazione);
                
                // Ridisegna anche i filari se sono gi√† stati disegnati
                // Questo risolve il problema quando si creano le carraie dopo aver selezionato il sesto
                if (reticolatoLines && reticolatoLines.length > 0) {
                    const distanzaFile = parseFloat(document.getElementById('distanzaFile')?.value || 2.5);
                    const distanzaUnita = parseFloat(document.getElementById('distanzaUnita')?.value || 1.0);
                    const bounds = new google.maps.LatLngBounds();
                    terrenoCoords.forEach(coord => bounds.extend(coord));
                    calcolaReticolatoConRotazione(terrenoCoords, bounds, distanzaFile, distanzaUnita, largA, largB, largC, largD, angoloRotazione);
                    
                    // Aggiorna i calcoli automatici dopo aver ridisegnato i filari
                    // Questo √® necessario perch√© cambiando la larghezza delle carraie cambia l'area disponibile
                    console.log('[CARRAIE] Chiamata updateCalcoli() dopo modifica larghezze carraie');
                    updateCalcoli();
                }
                
                // Aggiorna anche la lista delle carraie per mostrare le nuove larghezze
                setTimeout(() => {
                    if (window.carraieData && window.carraieData.length > 0) {
                        // Ricrea tuttiLatiInfo per passarlo a popolaListaCarraie
                        const tuttiLatiInfo = [];
                        for (let i = 0; i < terrenoCoords.length; i++) {
                            const current = terrenoCoords[i];
                            const next = terrenoCoords[(i + 1) % terrenoCoords.length];
                            const lunghezza = google.maps.geometry.spherical.computeDistanceBetween(
                                new google.maps.LatLng(current.lat(), current.lng()),
                                new google.maps.LatLng(next.lat(), next.lng())
                            );
                            const bearing = google.maps.geometry.spherical.computeHeading(
                                new google.maps.LatLng(current.lat(), current.lng()),
                                new google.maps.LatLng(next.lat(), next.lng())
                            );
                            tuttiLatiInfo.push({ 
                                index: i, 
                                lunghezza: lunghezza,
                                sideBearing: bearing
                            });
                        }
                        // Salva anche in window
                        window.tuttiLatiInfo = tuttiLatiInfo;
                        popolaListaCarraie(window.carraieData, tuttiLatiInfo);
                    }
                }, 100);
            }
        }
        
        // Funzione per selezionare/deselezionare una carraia cliccandola sulla mappa
        function selezionaCarraia(index) {
            const checkbox = document.getElementById(`carraia_${index}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                // Evidenzia visivamente il poligono selezionato
                if (window.carraieData) {
                    const carraia = window.carraieData.find(c => c.index === index);
                    if (carraia && carraia.polygon) {
                        // Determina colore in base al tipo
                        let fillColor = '#FFB74D';
                        let strokeColor = '#E65100';
                        if (window.carraieClassificazione) {
                            const tipo = window.carraieClassificazione.get(index);
                            if (tipo === 'principale') {
                                fillColor = '#FF9800';
                                strokeColor = '#E65100';
                            } else if (tipo === 'laterale') {
                                fillColor = '#64B5F6';
                                strokeColor = '#1976D2';
                            }
                        }
                        
                        if (checkbox.checked) {
                            carraia.polygon.setOptions({
                                fillColor: fillColor,
                                fillOpacity: 0.6, // Aumentata per evidenziare meglio la selezione
                                strokeColor: strokeColor,
                                strokeWeight: 4 // Aumentato per evidenziare meglio la selezione
                            });
                        } else {
                            const larghezza = carraia.larghezza || 0;
                            carraia.polygon.setOptions({
                                fillColor: fillColor,
                                fillOpacity: larghezza > 0.1 ? 0.4 : 0.15,
                                strokeColor: strokeColor,
                                strokeWeight: larghezza > 0.1 ? 3 : 2
                            });
                        }
                    }
                }
            }
        }
        
        // Funzione vecchia rimossa - non pi√π necessaria (codice eliminato)
        
        // Calcola intersezione tra due linee (segmenti)
        function calcolaIntersezioneDueLinee(p1, p2, p3, p4) {
            // p1, p2: punti della prima linea
            // p3, p4: punti della seconda linea
            // Ritorna il punto di intersezione o null se le linee sono parallele
            
            try {
                // Converti a coordinate cartesiane per calcolo pi√π preciso
                const lat1 = p1.lat();
                const lng1 = p1.lng();
                const lat2 = p2.lat();
                const lng2 = p2.lng();
                const lat3 = p3.lat();
                const lng3 = p3.lng();
                const lat4 = p4.lat();
                const lng4 = p4.lng();
                
                // Calcola denominatori per formula intersezione linee
                const denom = (lat1 - lat2) * (lng3 - lng4) - (lng1 - lng2) * (lat3 - lat4);
                
                // Se denom √® 0, le linee sono parallele
                if (Math.abs(denom) < 1e-10) {
                    // Linee parallele, usa il punto medio tra i due punti pi√π vicini
                    const dist1 = google.maps.geometry.spherical.computeDistanceBetween(p2, p3);
                    const dist2 = google.maps.geometry.spherical.computeDistanceBetween(p2, p4);
                    return dist1 < dist2 ? p3 : p4;
                }
                
                // Calcola parametri t e u per formula intersezione
                const t = ((lat1 - lat3) * (lng3 - lng4) - (lng1 - lng3) * (lat3 - lat4)) / denom;
                const u = -((lat1 - lat2) * (lng1 - lng3) - (lng1 - lng2) * (lat1 - lat3)) / denom;
                
                // Verifica che l'intersezione sia sui segmenti (0 <= t <= 1 e 0 <= u <= 1)
                // Ma per i nostri scopi, accettiamo anche intersezioni leggermente fuori
                if (t < -0.1 || t > 1.1 || u < -0.1 || u > 1.1) {
                    // Intersezione fuori dai segmenti, usa approssimazione
                    const mid1 = new google.maps.LatLng(
                        (lat1 + lat2) / 2,
                        (lng1 + lng2) / 2
                    );
                    const mid2 = new google.maps.LatLng(
                        (lat3 + lat4) / 2,
                        (lng3 + lng4) / 2
                    );
                    // Ritorna punto medio tra i due punti medi
                    return new google.maps.LatLng(
                        (mid1.lat() + mid2.lat()) / 2,
                        (mid1.lng() + mid2.lng()) / 2
                    );
                }
                
                // Calcola punto di intersezione
                const lat = lat1 + t * (lat2 - lat1);
                const lng = lng1 + t * (lng2 - lng1);
                
                return new google.maps.LatLng(lat, lng);
            } catch (error) {
                console.warn('Errore calcolo intersezione linee:', error);
                // Fallback: ritorna punto medio tra p2 e p3
                return new google.maps.LatLng(
                    (p2.lat() + p3.lat()) / 2,
                    (p2.lng() + p3.lng()) / 2
                );
            }
        }
        
        // Calcola intersezione tra una linea e un poligono
        function calcolaIntersezioneLineaPoligono(lineStart, lineEnd, polygonCoords) {
            // Crea un poligono temporaneo per verificare containsLocation
            const tempPoly = new google.maps.Polygon({ paths: polygonCoords });
            
            // Campiona punti lungo la linea per trovare dove entra ed esce dal poligono
            const samples = [];
            const numSamples = 200; // Pi√π campioni = pi√π precisione
            
            let firstInside = null;
            let lastInside = null;
            
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const lat = lineStart.lat() + (lineEnd.lat() - lineStart.lat()) * t;
                const lng = lineStart.lng() + (lineEnd.lng() - lineStart.lng()) * t;
                const point = new google.maps.LatLng(lat, lng);
                
                const isInside = google.maps.geometry.poly.containsLocation(point, tempPoly);
                
                if (isInside) {
                    if (firstInside === null) {
                        firstInside = point;
                    }
                    lastInside = point;
                }
            }
            
            if (firstInside === null || lastInside === null) {
                return null;
            }
            
            // Ritorna primo e ultimo punto dentro il poligono
            return [firstInside, lastInside];
        }
        
        // Verifica se un punto √® dentro una delle carraie
        function isPointInCarraie(point) {
            // Prima controlla tutte le carraie in window.carraieData (nuovo sistema)
            if (window.carraieData && window.carraieData.length > 0) {
                for (let i = 0; i < window.carraieData.length; i++) {
                    const carraia = window.carraieData[i];
                    // Controlla solo carraie con larghezza > 0 (quelle visibili)
                    if (carraia && carraia.polygon && carraia.larghezza > 0) {
                        try {
                            // Usa direttamente il poligono esistente invece di crearne uno nuovo
                            if (google.maps.geometry.poly.containsLocation(point, carraia.polygon)) {
                                return true;
                            }
                        } catch (e) {
                            // Fallback: se il controllo diretto fallisce, prova con i paths
                            try {
                                const paths = carraia.polygon.getPaths();
                                if (paths && paths.getLength) {
                                    for (let j = 0; j < paths.getLength(); j++) {
                                        const path = paths.getAt(j);
                                        if (path && path.getLength && path.getLength() > 0) {
                                            const tempPoly = new google.maps.Polygon({ paths: path });
                                            if (google.maps.geometry.poly.containsLocation(point, tempPoly)) {
                                                return true;
                                            }
                                        }
                                    }
                                }
                            } catch (e2) {
                                // Ignora errori
                            }
                        }
                    }
                }
            }
            
            // Fallback: controlla anche le vecchie variabili per retrocompatibilit√†
            const checkPolygon = (polygon) => {
                if (!polygon) return false;
                
                if (Array.isArray(polygon)) {
                    // √à un array di poligoni
                    return polygon.some(p => {
                        if (!p || !p.getPaths) return false;
                        const paths = p.getPaths();
                        for (let j = 0; j < paths.getLength(); j++) {
                            const path = paths.getAt(j);
                            const tempPoly = new google.maps.Polygon({ paths: path });
                            if (google.maps.geometry.poly.containsLocation(point, tempPoly)) {
                                return true;
                            }
                        }
                        return false;
                    });
                } else {
                    // √à un singolo poligono
                    const paths = polygon.getPaths();
                    for (let j = 0; j < paths.getLength(); j++) {
                        const path = paths.getAt(j);
                        const tempPoly = new google.maps.Polygon({ paths: path });
                        if (google.maps.geometry.poly.containsLocation(point, tempPoly)) {
                            return true;
                        }
                    }
                    return false;
                }
            };
            
            return checkPolygon(carraieLateraliPolygon) || checkPolygon(carraiePerpendicolariPolygon);
        }
        
        // Trova il punto di transizione tra dentro/fuori carraia usando ricerca binaria
        function trovaTransizioneCarraia(tStart, tEnd, lineStart, lineEnd, isStartInCarraia) {
            // Precisione bilanciata: abbastanza per accuratezza, non troppo per performance
            const precision = 0.0001; // Precisione in termini di t
            let low = tStart;
            let high = tEnd;
            
            for (let iter = 0; iter < 15; iter++) { // Max 15 iterazioni (sufficiente per precisione)
                const mid = (low + high) / 2;
                const lat = lineStart.lat() + (lineEnd.lat() - lineStart.lat()) * mid;
                const lng = lineStart.lng() + (lineEnd.lng() - lineStart.lng()) * mid;
                const point = new google.maps.LatLng(lat, lng);
                const isInCarraia = isPointInCarraie(point);
                
                if (isInCarraia === isStartInCarraia) {
                    low = mid;
                } else {
                    high = mid;
                }
                
                if (high - low < precision) {
                    break;
                }
            }
            
            const t = (low + high) / 2;
            const lat = lineStart.lat() + (lineEnd.lat() - lineStart.lat()) * t;
            const lng = lineStart.lng() + (lineEnd.lng() - lineStart.lng()) * t;
            return new google.maps.LatLng(lat, lng);
        }
        
        // Taglia una linea escludendo le parti che intersecano con le carraie
        function tagliaLineaEscludendoCarraie(lineStart, lineEnd) {
            // Controlla se ci sono carraie (nuovo sistema o vecchio)
            const carraieAttive = window.carraieData && window.carraieData.length > 0 
                ? window.carraieData.filter(c => c && c.polygon && c.larghezza > 0)
                : [];
            const hasCarraie = carraieAttive.length > 0 || carraieLateraliPolygon || carraiePerpendicolariPolygon;
            
            // Se non ci sono carraie, ritorna la linea originale
            if (!hasCarraie) {
                return [[lineStart, lineEnd]];
            }
            
            // Debug: verifica che le carraie siano accessibili
            if (carraieAttive.length > 0) {
                // Verifica che almeno una carraia abbia un poligono valido
                const carraieValide = carraieAttive.filter(c => {
                    try {
                        const paths = c.polygon.getPaths();
                        return paths && paths.getLength && paths.getLength() > 0;
                    } catch (e) {
                        return false;
                    }
                });
                if (carraieValide.length === 0) {
                    console.warn('[CARRAIE] Nessuna carraia valida trovata per taglio filari');
                    return [[lineStart, lineEnd]];
                }
            }
            
            // Campiona punti lungo la linea per identificare quali parti sono dentro le carraie
            // Numero ottimizzato: abbastanza per precisione, non troppo per performance
            const numSamples = 100; // Campioni iniziali per identificare le zone
            const samples = [];
            
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const lat = lineStart.lat() + (lineEnd.lat() - lineStart.lat()) * t;
                const lng = lineStart.lng() + (lineEnd.lng() - lineStart.lng()) * t;
                const point = new google.maps.LatLng(lat, lng);
                const isInCarraia = isPointInCarraie(point);
                
                samples.push({
                    point: point,
                    t: t,
                    isInCarraia: isInCarraia
                });
            }
            
            // Costruisci segmenti escludendo le parti dentro le carraie
            const segments = [];
            let currentSegmentStart = null;
            let currentSegmentStartT = null;
            
            for (let i = 0; i < samples.length; i++) {
                const sample = samples[i];
                const prevSample = i > 0 ? samples[i - 1] : null;
                
                if (!sample.isInCarraia) {
                    // Siamo fuori da una carraia
                    if (currentSegmentStart === null) {
                        // Inizia un nuovo segmento
                        if (prevSample && prevSample.isInCarraia) {
                            // Transizione da dentro a fuori: trova punto esatto di transizione
                            currentSegmentStart = trovaTransizioneCarraia(
                                prevSample.t, sample.t, lineStart, lineEnd, true
                            );
                            currentSegmentStartT = null; // Non necessario, ma per coerenza
                        } else {
                            currentSegmentStart = sample.point;
                            currentSegmentStartT = sample.t;
                        }
                    }
                } else {
                    // Siamo dentro una carraia
                    if (currentSegmentStart !== null) {
                        // Chiudi il segmento precedente trovando il punto esatto di transizione
                        let segmentEnd;
                        if (prevSample && !prevSample.isInCarraia) {
                            // Transizione da fuori a dentro: trova punto esatto
                            segmentEnd = trovaTransizioneCarraia(
                                prevSample.t, sample.t, lineStart, lineEnd, false
                            );
                        } else {
                            segmentEnd = prevSample ? prevSample.point : currentSegmentStart;
                        }
                        
                        if (currentSegmentStart && segmentEnd) {
                            segments.push([currentSegmentStart, segmentEnd]);
                        }
                        currentSegmentStart = null;
                        currentSegmentStartT = null;
                    }
                }
            }
            
            // Chiudi l'ultimo segmento se necessario
            if (currentSegmentStart !== null) {
                const lastSample = samples[samples.length - 1];
                if (!lastSample.isInCarraia) {
                    segments.push([currentSegmentStart, lineEnd]);
                } else if (samples.length > 1) {
                    // L'ultimo punto √® dentro una carraia, trova transizione
                    const prevSample = samples[samples.length - 2];
                    if (!prevSample.isInCarraia) {
                        const segmentEnd = trovaTransizioneCarraia(
                            prevSample.t, lastSample.t, lineStart, lineEnd, false
                        );
                        segments.push([currentSegmentStart, segmentEnd]);
                    }
                }
            }
            
            // Se non ci sono segmenti validi, ritorna array vuoto
            return segments.filter(seg => seg && seg.length >= 2 && 
                seg[0] && seg[1] && 
                isFinite(seg[0].lat()) && isFinite(seg[0].lng()) &&
                isFinite(seg[1].lat()) && isFinite(seg[1].lng()));
        }

        // Aggiorna calcoli visualizzati
        function updateCalcoli() {
            console.log('[CALCOLI] updateCalcoli() chiamato');
            if (!currentTerreno || !terrenoPolygon) {
                document.getElementById('calcNumeroFile').textContent = '-';
                document.getElementById('calcNumeroUnita').textContent = '-';
                document.getElementById('calcSuperficieLorda').textContent = '-';
                document.getElementById('calcSuperficieCarraie').textContent = '-';
                document.getElementById('calcSuperficieNetta').textContent = '-';
                document.getElementById('calcDensitaEffettiva').textContent = '-';
                return;
            }
            
            const distanzaFile = parseFloat(document.getElementById('distanzaFile').value);
            const distanzaUnita = parseFloat(document.getElementById('distanzaUnita').value);
            const larghezzaA = parseFloat(document.getElementById('larghezzaCarraiaA')?.value) || 0;
            const larghezzaB = parseFloat(document.getElementById('larghezzaCarraiaB')?.value) || 0;
            const larghezzaC = parseFloat(document.getElementById('larghezzaCarraiaC')?.value) || 0;
            const larghezzaD = parseFloat(document.getElementById('larghezzaCarraiaD')?.value) || 0;
            
            if (!distanzaFile || !distanzaUnita || distanzaFile <= 0 || distanzaUnita <= 0) {
                return;
            }
            
            // Superficie lorda (dal terreno)
            const superficieLorda = currentTerreno.superficie || 0;
            document.getElementById('calcSuperficieLorda').textContent = `${superficieLorda.toFixed(2)} ha`;
            
            // Numero file (dal reticolato disegnato)
            const numeroFile = reticolatoLines.length;
            document.getElementById('calcNumeroFile').textContent = numeroFile;
            
            // Calcola superficie carraie (somma delle aree di tutti i poligoni)
            let superficieCarraie = 0;
            if ((larghezzaA > 0 || larghezzaB > 0 || larghezzaC > 0 || larghezzaD > 0) && 
                currentTerreno.polygonCoords) {
                try {
                    // Funzione helper per calcolare area di un poligono o array di poligoni
                    const calcolaAreaPoligoni = (polygon) => {
                        if (!polygon) return 0;
                        
                        let areaTotale = 0;
                        const poligoni = Array.isArray(polygon) ? polygon : [polygon];
                        
                        poligoni.forEach(p => {
                            if (!p || !p.getPaths) return;
                            const paths = p.getPaths();
                            if (paths && paths.getLength() > 0) {
                                // Per ogni path del poligono, calcola l'area
                                for (let i = 0; i < paths.getLength(); i++) {
                                    const path = paths.getAt(i);
                                    const coords = [];
                                    for (let j = 0; j < path.getLength(); j++) {
                                        coords.push(path.getAt(j));
                                    }
                                    if (coords.length >= 3) {
                                        const area = google.maps.geometry.spherical.computeArea(coords);
                                        areaTotale += Math.abs(area); // Area sempre positiva
                                    }
                                }
                            }
                        });
                        
                        return areaTotale / 10000; // Converti da m¬≤ a ha
                    };
                    
                    // Calcola area carraie usando i poligoni da window.carraieData
                    if (window.carraieData && window.carraieData.length > 0) {
                        window.carraieData.forEach(carraia => {
                            if (carraia.polygon && carraia.larghezza > 0) {
                                superficieCarraie += calcolaAreaPoligoni(carraia.polygon);
                            }
                        });
                    }
                    
                    // Fallback se i poligoni non sono disponibili
                    if (superficieCarraie === 0) {
                        const terrenoCoords = currentTerreno.polygonCoords.map(c => 
                            new google.maps.LatLng(c.lat, c.lng)
                        );
                        let perimetroMetri = 0;
                        for (let i = 0; i < terrenoCoords.length; i++) {
                            const nextIndex = (i + 1) % terrenoCoords.length;
                            const distanza = google.maps.geometry.spherical.computeDistanceBetween(
                                terrenoCoords[i],
                                terrenoCoords[nextIndex]
                            );
                            perimetroMetri += distanza;
                        }
                        const mediaLarghezza = (larghezzaA + larghezzaB + larghezzaC + larghezzaD) / 4;
                        superficieCarraie = (perimetroMetri * mediaLarghezza) / 10000;
                    }
                } catch (error) {
                    console.warn('Errore calcolo area carraie, uso approssimazione:', error);
                    // Fallback: calcolo approssimato
                    const terrenoCoords = currentTerreno.polygonCoords.map(c => 
                        new google.maps.LatLng(c.lat, c.lng)
                    );
                    let perimetroMetri = 0;
                    for (let i = 0; i < terrenoCoords.length; i++) {
                        const nextIndex = (i + 1) % terrenoCoords.length;
                        const distanza = google.maps.geometry.spherical.computeDistanceBetween(
                            terrenoCoords[i],
                            terrenoCoords[nextIndex]
                        );
                        perimetroMetri += distanza;
                    }
                    const mediaLarghezza = (larghezzaA + larghezzaB + larghezzaC + larghezzaD) / 4;
                    superficieCarraie = (perimetroMetri * mediaLarghezza) / 10000;
                }
            }
            document.getElementById('calcSuperficieCarraie').textContent = `${superficieCarraie.toFixed(2)} ha`;
            
            // Superficie netta = lorda - carraie
            const superficieNetta = Math.max(0, superficieLorda - superficieCarraie);
            document.getElementById('calcSuperficieNetta').textContent = `${superficieNetta.toFixed(2)} ha`;
            
            // Calcola numero unit√† totali
            let numeroUnitaTotale = 0;
            if (window.reticolatoCoords && window.reticolatoCoords.length > 0) {
                // Per ogni fila, calcola lunghezza e numero unit√†
                window.reticolatoCoords.forEach(file => {
                    const start = new google.maps.LatLng(file.start.lat, file.start.lng);
                    const end = new google.maps.LatLng(file.end.lat, file.end.lng);
                    const lunghezzaFila = google.maps.geometry.spherical.computeDistanceBetween(start, end);
                    const unitaPerFila = Math.floor(lunghezzaFila / distanzaUnita);
                    numeroUnitaTotale += unitaPerFila;
                });
            }
            document.getElementById('calcNumeroUnita').textContent = numeroUnitaTotale.toLocaleString('it-IT');
            
            // Densit√† effettiva (unit√†/ha basata su superficie netta)
            const densitaEffettiva = superficieNetta > 0 ? (numeroUnitaTotale / superficieNetta) : 0;
            document.getElementById('calcDensitaEffettiva').textContent = `${densitaEffettiva.toFixed(0)} unit√†/ha`;
        }

        // Handler salva pianificazione
        // Carica pianificazione esistente per modifica
        async function loadPianificazionePerModifica(pianificazioneId) {
            try {
                const pianificazione = await getPianificazione(pianificazioneId);
                if (!pianificazione) {
                    alert('Pianificazione non trovata');
                    window.location.href = 'pianifica-impianto-standalone.html';
                    return;
                }

                // Precompila tipo coltura
                // Precompila campo terreno
                const terrenoSelect = document.getElementById('terrenoSelect');
                if (terrenoSelect && pianificazione.terrenoId) {
                    terrenoSelect.value = pianificazione.terrenoId;
                    // Trigger selezione terreno per caricare mappa
                    await onTerrenoSelected({ target: terrenoSelect });
                }

                // Attendi che la mappa sia inizializzata
                await new Promise(resolve => setTimeout(resolve, 1500));

                // Precompila campi distanze
                const distanzaFileEl = document.getElementById('distanzaFile');
                const distanzaUnitaEl = document.getElementById('distanzaUnita');
                if (distanzaFileEl && pianificazione.distanzaFile) {
                    distanzaFileEl.value = pianificazione.distanzaFile;
                }
                if (distanzaUnitaEl && pianificazione.distanzaUnita) {
                    distanzaUnitaEl.value = pianificazione.distanzaUnita;
                }

                // Precompila tipo coltura
                const tipoColturaEl = document.getElementById('tipoColtura');
                if (tipoColturaEl && pianificazione.tipoColtura) {
                    tipoColturaEl.value = pianificazione.tipoColtura;
                    // Mostra/nascondi forma allevamento in base al tipo coltura
                    const formaAllevamentoGroup = document.getElementById('formaAllevamentoGroup');
                    if (formaAllevamentoGroup) {
                        formaAllevamentoGroup.style.display = 
                            pianificazione.tipoColtura === 'vigneto' ? 'block' : 'none';
                    }
                }

                // Precompila forma allevamento (se vigneto)
                if (pianificazione.tipoColtura === 'vigneto' && pianificazione.formaAllevamento) {
                    const formaAllevamentoEl = document.getElementById('formaAllevamento');
                    if (formaAllevamentoEl) {
                        // Converti chiave tecnica ‚Üí nome visualizzato
                        const nomeVisualizzato = getNomeVisualizzato(pianificazione.formaAllevamento);
                        if (nomeVisualizzato) {
                            formaAllevamentoEl.value = nomeVisualizzato;
                        } else {
                            // Se non trovato, prova a usare direttamente la chiave
                            formaAllevamentoEl.value = pianificazione.formaAllevamento;
                        }
                    }
                }

                // Precompila angolo rotazione
                const angoloRotazioneEl = document.getElementById('angoloRotazione');
                if (angoloRotazioneEl && pianificazione.angoloRotazione !== undefined) {
                    angoloRotazioneEl.value = pianificazione.angoloRotazione;
                    // Aggiorna controlli rotazione
                    if (typeof initRotationControls === 'function') {
                        setTimeout(() => {
                            const hiddenInput = document.getElementById('angoloRotazione');
                            const slider = document.getElementById('angoloRotazioneSlider');
                            const display = document.getElementById('angoloRotazioneDisplay');
                            const compass = document.querySelector('.rotation-compass');
                            const direzioneSelect = document.getElementById('direzionePredefinita');
                            
                            if (hiddenInput) hiddenInput.value = pianificazione.angoloRotazione;
                            if (slider) slider.value = pianificazione.angoloRotazione;
                            if (display) display.textContent = `${Math.round(pianificazione.angoloRotazione)}¬∞`;
                            if (compass) compass.style.transform = `rotate(${pianificazione.angoloRotazione}deg)`;
                            if (direzioneSelect) {
                                const presetValue = parseInt(pianificazione.angoloRotazione);
                                const presetOptions = [0, 45, 90, 135, 180, 225, 270, 315];
                                if (presetOptions.includes(presetValue)) {
                                    direzioneSelect.value = presetValue.toString();
                                } else {
                                    direzioneSelect.value = 'custom';
                                }
                            }
                        }, 500);
                    }
                }

                // Precompila larghezze carraie (retrocompatibilit√† A, B, C, D)
                const larghezzaAEl = document.getElementById('larghezzaCarraiaA');
                const larghezzaBEl = document.getElementById('larghezzaCarraiaB');
                const larghezzaCEl = document.getElementById('larghezzaCarraiaC');
                const larghezzaDEl = document.getElementById('larghezzaCarraiaD');
                
                if (pianificazione.larghezzeCarraie && typeof pianificazione.larghezzeCarraie === 'object') {
                    // Nuovo formato: tutte le larghezze
                    if (!window.carraieWidths) {
                        window.carraieWidths = new Map();
                    }
                    Object.keys(pianificazione.larghezzeCarraie).forEach((key, index) => {
                        const larghezza = pianificazione.larghezzeCarraie[key];
                        window.carraieWidths.set(index, larghezza);
                        
                        // Precompila anche i campi A, B, C, D per retrocompatibilit√†
                        if (index === 0 && larghezzaAEl) larghezzaAEl.value = larghezza;
                        if (index === 1 && larghezzaBEl) larghezzaBEl.value = larghezza;
                        if (index === 2 && larghezzaCEl) larghezzaCEl.value = larghezza;
                        if (index === 3 && larghezzaDEl) larghezzaDEl.value = larghezza;
                    });
                } else if (pianificazione.larghezzaCarraiaA !== undefined || 
                          pianificazione.larghezzaCarraiaB !== undefined ||
                          pianificazione.larghezzaCarraiaC !== undefined ||
                          pianificazione.larghezzaCarraiaD !== undefined) {
                    // Formato retrocompatibile: solo A, B, C, D
                    if (!window.carraieWidths) {
                        window.carraieWidths = new Map();
                    }
                    if (larghezzaAEl && pianificazione.larghezzaCarraiaA) {
                        larghezzaAEl.value = pianificazione.larghezzaCarraiaA;
                        window.carraieWidths.set(0, pianificazione.larghezzaCarraiaA);
                    }
                    if (larghezzaBEl && pianificazione.larghezzaCarraiaB) {
                        larghezzaBEl.value = pianificazione.larghezzaCarraiaB;
                        window.carraieWidths.set(1, pianificazione.larghezzaCarraiaB);
                    }
                    if (larghezzaCEl && pianificazione.larghezzaCarraiaC) {
                        larghezzaCEl.value = pianificazione.larghezzaCarraiaC;
                        window.carraieWidths.set(2, pianificazione.larghezzaCarraiaC);
                    }
                    if (larghezzaDEl && pianificazione.larghezzaCarraiaD) {
                        larghezzaDEl.value = pianificazione.larghezzaCarraiaD;
                        window.carraieWidths.set(3, pianificazione.larghezzaCarraiaD);
                    }
                }

                // Cambia testo pulsante salva
                const btnSalva = document.getElementById('btnSalva');
                if (btnSalva) {
                    btnSalva.textContent = 'üíæ Aggiorna Pianificazione';
                }

                // Attendi che la mappa sia pronta, poi disegna reticolato e carraie
                setTimeout(() => {
                    // Se ci sono coordinate reticolato salvate, ripristinale (per calcoli)
                    if (pianificazione.reticolatoCoords && Array.isArray(pianificazione.reticolatoCoords)) {
                        window.reticolatoCoords = pianificazione.reticolatoCoords;
                    }
                    
                    // Trigger ricalcolo per disegnare reticolato e carraie con i parametri caricati
                    if (typeof onParametriChanged === 'function') {
                        onParametriChanged();
                    }
                }, 1500);
            } catch (error) {
                console.error('Errore caricamento pianificazione:', error);
                alert('Errore nel caricamento della pianificazione: ' + error.message);
                // Reindirizza alla pagina senza parametri
                window.location.href = 'pianifica-impianto-standalone.html';
            }
        }

        async function onSalvaPianificazione() {
            if (!currentTerreno) {
                alert('Seleziona un terreno prima di salvare');
                return;
            }

            const distanzaFile = parseFloat(document.getElementById('distanzaFile').value);
            const distanzaUnita = parseFloat(document.getElementById('distanzaUnita').value);
            const angoloRotazione = parseFloat(document.getElementById('angoloRotazione').value);
            const tipoColtura = document.getElementById('tipoColtura').value;
            
            // Leggi forma allevamento (se vigneto) e converti nome visualizzato ‚Üí chiave tecnica
            let formaAllevamento = null;
            if (tipoColtura === 'vigneto') {
                const formaAllevamentoSelect = document.getElementById('formaAllevamento');
                const nomeVisualizzato = formaAllevamentoSelect ? formaAllevamentoSelect.value : null;
                if (nomeVisualizzato) {
                    formaAllevamento = getChiaveTecnica(nomeVisualizzato);
                }
            }

            if (!distanzaFile || !distanzaUnita) {
                alert('Compila tutti i campi obbligatori');
                return;
            }

            // Leggi le larghezze da window.carraieWidths (valori aggiornati) invece che dagli input nascosti
            // Per retrocompatibilit√†, salva anche le prime 4 come A, B, C, D
            const larghezzaA = window.carraieWidths ? (window.carraieWidths.get(0) || 0) : 0;
            const larghezzaB = window.carraieWidths ? (window.carraieWidths.get(1) || 0) : 0;
            const larghezzaC = window.carraieWidths ? (window.carraieWidths.get(2) || 0) : 0;
            const larghezzaD = window.carraieWidths ? (window.carraieWidths.get(3) || 0) : 0;
            
            // Salva tutte le larghezze delle carraie (non solo le prime 4)
            const larghezzeCarraie = {};
            if (window.carraieWidths && window.carraieWidths.size > 0) {
                window.carraieWidths.forEach((larghezza, index) => {
                    larghezzeCarraie[`lato${index}`] = larghezza;
                });
            }

            try {
                // Calcola i valori che verranno salvati (stessa logica di updateCalcoli)
                const superficieLorda = currentTerreno.superficie || 0;
                const numeroFile = reticolatoLines.length;
                
                // Calcola superficie carraie
                let superficieCarraie = 0;
                if ((larghezzaA > 0 || larghezzaB > 0 || larghezzaC > 0 || larghezzaD > 0) && 
                    currentTerreno.polygonCoords) {
                    try {
                        const calcolaAreaPoligoni = (polygon) => {
                            if (!polygon) return 0;
                            let areaTotale = 0;
                            const poligoni = Array.isArray(polygon) ? polygon : [polygon];
                            poligoni.forEach(p => {
                                if (!p || !p.getPaths) return;
                                const paths = p.getPaths();
                                if (paths && paths.getLength() > 0) {
                                    for (let i = 0; i < paths.getLength(); i++) {
                                        const path = paths.getAt(i);
                                        const coords = [];
                                        for (let j = 0; j < path.getLength(); j++) {
                                            coords.push(path.getAt(j));
                                        }
                                        if (coords.length >= 3) {
                                            const area = google.maps.geometry.spherical.computeArea(coords);
                                            areaTotale += Math.abs(area);
                                        }
                                    }
                                }
                            });
                            return areaTotale / 10000; // Converti da m¬≤ a ha
                        };
                        
                        if (window.carraieData && window.carraieData.length > 0) {
                            window.carraieData.forEach(carraia => {
                                if (carraia.polygon && carraia.larghezza > 0) {
                                    superficieCarraie += calcolaAreaPoligoni(carraia.polygon);
                                }
                            });
                        }
                        
                        if (superficieCarraie === 0) {
                            const terrenoCoords = currentTerreno.polygonCoords.map(c => 
                                new google.maps.LatLng(c.lat, c.lng)
                            );
                            let perimetroMetri = 0;
                            for (let i = 0; i < terrenoCoords.length; i++) {
                                const nextIndex = (i + 1) % terrenoCoords.length;
                                const distanza = google.maps.geometry.spherical.computeDistanceBetween(
                                    terrenoCoords[i],
                                    terrenoCoords[nextIndex]
                                );
                                perimetroMetri += distanza;
                            }
                            const mediaLarghezza = (larghezzaA + larghezzaB + larghezzaC + larghezzaD) / 4;
                            superficieCarraie = (perimetroMetri * mediaLarghezza) / 10000;
                        }
                    } catch (error) {
                        console.warn('Errore calcolo area carraie:', error);
                        const terrenoCoords = currentTerreno.polygonCoords.map(c => 
                            new google.maps.LatLng(c.lat, c.lng)
                        );
                        let perimetroMetri = 0;
                        for (let i = 0; i < terrenoCoords.length; i++) {
                            const nextIndex = (i + 1) % terrenoCoords.length;
                            const distanza = google.maps.geometry.spherical.computeDistanceBetween(
                                terrenoCoords[i],
                                terrenoCoords[nextIndex]
                            );
                            perimetroMetri += distanza;
                        }
                        const mediaLarghezza = (larghezzaA + larghezzaB + larghezzaC + larghezzaD) / 4;
                        superficieCarraie = (perimetroMetri * mediaLarghezza) / 10000;
                    }
                }
                
                const superficieNetta = Math.max(0, superficieLorda - superficieCarraie);
                
                // Calcola numero unit√† totali e lunghezza filari totale
                let numeroUnitaTotale = 0;
                let lunghezzaFilariTotale = 0;
                if (window.reticolatoCoords && window.reticolatoCoords.length > 0) {
                    window.reticolatoCoords.forEach(file => {
                        const start = new google.maps.LatLng(file.start.lat, file.start.lng);
                        const end = new google.maps.LatLng(file.end.lat, file.end.lng);
                        const lunghezzaFila = google.maps.geometry.spherical.computeDistanceBetween(start, end);
                        lunghezzaFilariTotale += lunghezzaFila;
                        const unitaPerFila = Math.floor(lunghezzaFila / distanzaUnita);
                        numeroUnitaTotale += unitaPerFila;
                    });
                }
                
                const densitaEffettiva = superficieNetta > 0 ? (numeroUnitaTotale / superficieNetta) : 0;
                
                // Prepara reticolatoCoords per il salvataggio (solo coordinate, non oggetti Google Maps)
                const reticolatoCoordsForSave = window.reticolatoCoords ? window.reticolatoCoords.map(file => ({
                    start: { lat: file.start.lat, lng: file.start.lng },
                    end: { lat: file.end.lat, lng: file.end.lng }
                })) : [];

                const pianificazioneData = {
                    terrenoId: currentTerreno.id,
                    tipoColtura: tipoColtura,
                    formaAllevamento: formaAllevamento, // Chiave tecnica (es. "guyot", "cordone_speronato")
                    distanzaFile: distanzaFile,
                    distanzaUnita: distanzaUnita,
                    // Retrocompatibilit√†: mantieni A, B, C, D
                    larghezzaCarraiaA: larghezzaA,
                    larghezzaCarraiaB: larghezzaB,
                    larghezzaCarraiaC: larghezzaC,
                    larghezzaCarraiaD: larghezzaD,
                    // Nuovo: salva tutte le larghezze
                    larghezzeCarraie: larghezzeCarraie,
                    angoloRotazione: angoloRotazione,
                    // CALCOLI - questi sono i valori che mancavano!
                    numeroFile: numeroFile,
                    numeroUnitaTotale: numeroUnitaTotale,
                    superficieLorda: superficieLorda,
                    superficieCarraie: superficieCarraie,
                    superficieNettaImpianto: superficieNetta,
                    densitaEffettiva: densitaEffettiva,
                    lunghezzaFilariTotale: lunghezzaFilariTotale,
                    reticolatoCoords: reticolatoCoordsForSave,
                    stato: 'bozza'
                };

                console.log('[PIANIFICAZIONE] Dati da salvare:', {
                    numeroFile: pianificazioneData.numeroFile,
                    numeroUnitaTotale: pianificazioneData.numeroUnitaTotale,
                    superficieNettaImpianto: pianificazioneData.superficieNettaImpianto,
                    lunghezzaFilariTotale: pianificazioneData.lunghezzaFilariTotale
                });

                // Se c'√® un ID, aggiorna invece di creare
                if (currentPianificazioneId) {
                    await updatePianificazione(currentPianificazioneId, pianificazioneData);
                    alert('Pianificazione aggiornata con successo!');
                    console.log('Pianificazione aggiornata:', currentPianificazioneId);
                } else {
                    const pianificazioneId = await createPianificazione(pianificazioneData);
                    alert('Pianificazione salvata con successo!');
                    console.log('Pianificazione creata:', pianificazioneId);
                }
            } catch (error) {
                console.error('Errore salvataggio pianificazione:', error);
                alert(`Errore nel salvataggio: ${error.message}`);
            }
        }

        // Handler reset parametri
        function onResetParametri() {
            const distanzaFileEl = document.getElementById('distanzaFile');
            const distanzaUnitaEl = document.getElementById('distanzaUnita');
            const larghezzaCarraiaAEl = document.getElementById('larghezzaCarraiaA');
            const larghezzaCarraiaBEl = document.getElementById('larghezzaCarraiaB');
            const larghezzaCarraiaCEl = document.getElementById('larghezzaCarraiaC');
            const larghezzaCarraiaDEl = document.getElementById('larghezzaCarraiaD');

            if (distanzaFileEl) distanzaFileEl.value = '2.5';
            if (distanzaUnitaEl) distanzaUnitaEl.value = '0.8';
            if (larghezzaCarraiaAEl) larghezzaCarraiaAEl.value = '2.0';
            if (larghezzaCarraiaBEl) larghezzaCarraiaBEl.value = '2.0';
            if (larghezzaCarraiaCEl) larghezzaCarraiaCEl.value = '4.0';
            if (larghezzaCarraiaDEl) larghezzaCarraiaDEl.value = '4.0';
            
            // Reset rotazione usando i controlli
            const direzioneSelect = document.getElementById('direzionePredefinita');
            const slider = document.getElementById('angoloRotazioneSlider');
            const hiddenInput = document.getElementById('angoloRotazione');
            const display = document.getElementById('angoloRotazioneDisplay');
            const compass = document.querySelector('.rotation-compass');
            
            if (hiddenInput) hiddenInput.value = '0';
            if (slider) slider.value = '0';
            if (direzioneSelect) direzioneSelect.value = '0';
            if (display) display.textContent = '0¬∞';
            if (compass) compass.style.transform = 'rotate(0deg)';
            
            if (typeof onParametriChanged === 'function') {
                onParametriChanged();
            }
        }

        // Avvia inizializzazione
        init();
    </script>
</body>
</html>
